<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>算法篇-双指针 | Huang Blog</title><meta name="author" content="Huang RD"><meta name="copyright" content="Huang RD"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="双指针简介双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。 双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。 力扣题目1、数组 字符串1.1、LC11. 盛最多水的容器给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, hei">
<meta property="og:type" content="article">
<meta property="og:title" content="算法篇-双指针">
<meta property="og:url" content="http://www.haungrd.top/2023/04/11/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/index.html">
<meta property="og:site_name" content="Huang Blog">
<meta property="og:description" content="双指针简介双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。 双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。 力扣题目1、数组 字符串1.1、LC11. 盛最多水的容器给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, hei">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.huangrd.top/images/agentina/5.jpg">
<meta property="article:published_time" content="2023-04-11T13:12:57.000Z">
<meta property="article:modified_time" content="2023-04-12T01:20:56.503Z">
<meta property="article:author" content="Huang RD">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="计算机基础">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="数组">
<meta property="article:tag" content="链表">
<meta property="article:tag" content="双指针">
<meta property="article:tag" content="字符串">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.huangrd.top/images/agentina/5.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.haungrd.top/2023/04/11/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法篇-双指针',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-12 09:20:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://getwallpapers.com/wallpaper/full/a/1/8/1057222-free-download-cool-nature-backgrounds-1920x1200-windows-10.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">64</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.huangrd.top/images/agentina/5.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Huang Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法篇-双指针</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-11T13:12:57.000Z" title="发表于 2023-04-11 21:12:57">2023-04-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-12T01:20:56.503Z" title="更新于 2023-04-12 09:20:56">2023-04-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法篇-双指针"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>
<p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p>
<h2 id="力扣题目"><a href="#力扣题目" class="headerlink" title="力扣题目"></a>力扣题目</h2><h3 id="1、数组-字符串"><a href="#1、数组-字符串" class="headerlink" title="1、数组 字符串"></a>1、数组 字符串</h3><h4 id="1-1、LC11-盛最多水的容器"><a href="#1-1、LC11-盛最多水的容器" class="headerlink" title="1.1、LC11. 盛最多水的容器"></a>1.1、LC11. 盛最多水的容器</h4><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p><strong>说明：</strong>你不能倾斜容器。</p>
<p><strong>示例 1：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/question_11.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>面积：高*宽 min(height[left], height[right]) * (right - left)</p>
<ol>
<li><p>初始化两个指针指向两个边，这个时候宽是最大的。</p>
</li>
<li><p>当两个边向内缩小的时候,如果高是增大的话，才有可能会增大，如果高是减小的就不能增大。</p>
</li>
<li><p>因此在缩小的时候，让高尽可能变大，即缩小高小的一边。相等的话，任意。（有可能存在山峰的形状）</p>
</li>
<li><p>这样保证了在每一次选择时都是选择最大的，在遍历过程中用result记录最大值返回。</p>
</li>
</ol>
<p>只进行了一次遍历。<br>时间复杂度O(N)<br>空间复杂度O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双指针</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (Math.min(height[left], height[right]) * (right - left));</span><br><span class="line">            result = Math.max(sum, result);</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2、剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#1-2、剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="1.2、剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a>1.2、剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= nums.length &lt;= 50000</code></li>
<li><code>0 &lt;= nums[i] &lt;= 10000</code></li>
</ol>
<p>Related Topics</p>
<p>数组</p>
<p>双指针</p>
<p>排序</p>
<p>👍 268</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>考虑定义双指针 i , j 分列数组左右两端，循环执行：</p>
<ol>
<li>指针 i 从左向右寻找偶数；</li>
<li>指针 j 从右向左寻找奇数；</li>
<li>将 偶数 nums[i] 和 奇数 nums[j] 交换。</li>
</ol>
<p>可始终保证： 指针 i 左边都是奇数，指针 j 右边都是偶数 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/43e965485da89efa688947bc108232f10b65b5ba5c0dbd6a68227a82c7e451e4-Picture1.png" alt="Picture1.png"></p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>初始化： i , j 双指针，分别指向数组 nums 左右两端；</li>
<li>循环交换： 当 i &#x3D; j 时跳出；<ol>
<li>指针 i 遇到奇数则执行 i &#x3D; i + 1 跳过，直到找到偶数；</li>
<li>指针 j 遇到偶数则执行 j &#x3D; j - 1 跳过，直到找到奇数；</li>
<li>交换 nums[i] 和 nums[j] 值；</li>
</ol>
</li>
<li>返回值： 返回已修改的 nums 数组。</li>
</ol>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N ： N 为数组 nums 长度，双指针 i, j 共同遍历整个数组。</li>
<li>空间复杂度 O(1) ： 双指针 i, j 使用常数大小的额外空间。</li>
</ul>
<p><em>x</em>&amp;1 位运算 等价于 x*%2 取余运算，即皆可用于判断数字奇偶性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>, tmp;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; (nums[i] &amp; <span class="number">1</span>) == <span class="number">1</span>) i++; <span class="comment">// 找不是奇数</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; (nums[j] &amp; <span class="number">1</span>) == <span class="number">0</span>) j--; <span class="comment">// 找不是偶数</span></span><br><span class="line">            tmp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3、LC1750-删除字符串两端相同字符后的最短长度"><a href="#1-3、LC1750-删除字符串两端相同字符后的最短长度" class="headerlink" title="1.3、LC1750. 删除字符串两端相同字符后的最短长度"></a>1.3、LC1750. 删除字符串两端相同字符后的最短长度</h4><p>给你一个只包含字符 <code>&#39;a&#39;</code>，<code>&#39;b&#39;</code> 和 <code>&#39;c&#39;</code> 的字符串 <code>s</code> ，你可以执行下面这个操作（5 个步骤）任意次：</p>
<ol>
<li>选择字符串 <code>s</code> 一个 <strong>非空</strong> 的前缀，这个前缀的所有字符都相同。</li>
<li>选择字符串 <code>s</code> 一个 <strong>非空</strong> 的后缀，这个后缀的所有字符都相同。</li>
<li>前缀和后缀在字符串中任意位置都不能有交集。</li>
<li>前缀和后缀包含的所有字符都要相同。</li>
<li>同时删除前缀和后缀。</li>
</ol>
<p>请你返回对字符串 <code>s</code> 执行上面操作任意次以后（可能 0 次），能得到的 <strong>最短长度</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ca&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：你没法删除任何一个字符，所以字符串长度仍然保持不变。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;cabaabac&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：最优操作序列为：</span><br><span class="line">- 选择前缀 &quot;c&quot; 和后缀 &quot;c&quot; 并删除它们，得到 s = &quot;abaaba&quot; 。</span><br><span class="line">- 选择前缀 &quot;a&quot; 和后缀 &quot;a&quot; 并删除它们，得到 s = &quot;baab&quot; 。</span><br><span class="line">- 选择前缀 &quot;b&quot; 和后缀 &quot;b&quot; 并删除它们，得到 s = &quot;aa&quot; 。</span><br><span class="line">- 选择前缀 &quot;a&quot; 和后缀 &quot;a&quot; 并删除它们，得到 s = &quot;&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aabccabba&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最优操作序列为：</span><br><span class="line">- 选择前缀 &quot;aa&quot; 和后缀 &quot;a&quot; 并删除它们，得到 s = &quot;bccabb&quot; 。</span><br><span class="line">- 选择前缀 &quot;b&quot; 和后缀 &quot;bb&quot; 并删除它们，得到 s = &quot;cca&quot; 。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s</code> 只包含字符 <code>&#39;a&#39;</code>，<code>&#39;b&#39;</code> 和 <code>&#39;c&#39;</code> 。</li>
</ul>
<p>Related Topics</p>
<p>双指针</p>
<p>字符串</p>
<p>👍 29</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>定义双指针分别指向两侧，当两侧字符的值相同时，进行收缩，不相等时，结束循环，返回结果。</p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>定义双指针 i &#x3D; 0, j &#x3D; s.length() - 1。</li>
<li>i &lt; j &amp;&amp; s.charAt(i) &#x3D;&#x3D; s.charAt(j) 时，开始收缩。</li>
<li>看循环终止条件，当终止时 i &gt; j，则说明可以把字符串全部删除完。返回 0.否则就返回 i到 j 字符串的长度。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumLength</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = s.length() - <span class="number">1</span>, j = n;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="comment">// 收缩右边界</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; c == s.charAt(j)) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 收缩左边界</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n &amp;&amp; c == s.charAt(i)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> j - i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度O(N)</li>
<li>空间复杂度O(1)</li>
</ul>
<h4 id="1-4、LC15-三数之和"><a href="#1-4、LC15-三数之和" class="headerlink" title="1.4、LC15. 三数之和"></a>1.4、LC15. 三数之和</h4><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p>
<p>你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p>Related Topics</p>
<p>数组</p>
<p>双指针</p>
<p>排序</p>
<p>👍 5500</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif" alt="15.三数之和"></p>
<p>使用双指针法，进行遍历。</p>
<p>首先对数组进行排序，排序后固定一个数 nums[i]，再使用左右指针指向 nums[i]后面的两端，数字分别为 nums[L] 和 nums[R]，计算三个数的和 sum 判断是否满足为 0，满足则添加进结果集。</p>
<ul>
<li>如果 nums[i]大于 0，则三数之和必然无法等于 0，结束循环。</li>
<li>如果 nums[i] &#x3D;&#x3D; nums[i-1]，则说明该数字重复，会导致结果重复，所以应该跳过。</li>
<li>当 sum &#x3D;&#x3D; 0 时，nums[L] &#x3D;&#x3D; nums[L+1] 则会导致结果重复，应该跳过，L++。</li>
<li>当 sum &#x3D;&#x3D; 0 时，nums[R] &#x3D;&#x3D; nums[R-1] 则会导致结果重复，应该跳过，R–。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length &lt; <span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// nums[i]大于 0，则三数之和必然无法等于 0，结束循环。</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// nums[i] == nums[i-1]，则说明该数字重复，会导致结果重复，所以应该跳过。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--; <span class="comment">// 收缩右边</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++; <span class="comment">// 收缩左边</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[left], nums[right])); <span class="comment">// 添加元素</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++; <span class="comment">// 第二个元素进行去重</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--; <span class="comment">// 第三个元素进行去重</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--; <span class="comment">// 找到元素后，自然的收缩</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n^2)，n 为数组长度。</li>
<li>空间复杂度：O(1),不算快排的开销是O(1)的，快排可以用其他排序代替。</li>
</ul>
<h4 id="1-5、LC1658-将-x-减到-0-的最小操作数"><a href="#1-5、LC1658-将-x-减到-0-的最小操作数" class="headerlink" title="1.5、LC1658. 将 x 减到 0 的最小操作数"></a>1.5、LC1658. 将 x 减到 0 的最小操作数</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>x</code> 。每一次操作时，你应当移除数组 <code>nums</code> 最左边或最右边的元素，然后从 <code>x</code> 中减去该元素的值。请注意，需要 <strong>修改</strong> 数组以供接下来的操作使用。</p>
<p>如果可以将 <code>x</code> <strong>恰好</strong> 减到 <code>0</code> ，返回 <strong>最小操作数</strong> ；否则，返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,4,2,3], x = 5</span><br><span class="line">输出：2</span><br><span class="line">解释：最佳解决方案是移除后两个元素，将 x 减到 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,6,7,8,9], x = 4</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,20,1,1,3], x = 10</span><br><span class="line">输出：5</span><br><span class="line">解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 104</code></li>
<li><code>1 &lt;= x &lt;= 109</code></li>
</ul>
<p>Related Topics</p>
<p>数组</p>
<p>哈希表</p>
<p>二分查找</p>
<p>前缀和</p>
<p>滑动窗口</p>
<p>👍 158</p>
<p>👎 0</p>
<p><strong>方法一：逆向思维+双指针</strong></p>
<p><strong>解题思路</strong></p>
<p>把问题转换成「从 nums 中移除一个最长的子数组，使得剩余元素的和为 x」。</p>
<p>换句话说，要从 nums 中找最长的子数组，其元素和等于 s - x，这里 s 为 nums 所有元素之和。</p>
<p>这可以用双指针实现.</p>
<blockquote>
<p>注：我一般把窗口大小不固定的叫做双指针，窗口大小固定的叫做滑动窗口。</p>
</blockquote>
<p>最后答案为 nums 的长度减去最长子数组的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> - x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            target += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123; <span class="comment">// 全部移除也无法满足要求</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>, left = <span class="number">0</span>, sum = <span class="number">0</span>, n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt; target) &#123;</span><br><span class="line">                sum -= nums[left++]; <span class="comment">// 缩小子数组的长度</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123; <span class="comment">// 找最长子数组</span></span><br><span class="line">                res = Math.max(res, right - left + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res &lt; <span class="number">0</span> ? -<span class="number">1</span> : n - res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针遍历了所有子数组存在的可能。</p>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为 nums 的长度。虽然写了个二重循环，但是 left++ 的执行次数不会超过 n 次，所以总的时间复杂度为 O(n)。</li>
<li>空间复杂度：O(1)，仅用到若干额外变量。</li>
</ul>
<p><strong>方法二：直接双指针</strong></p>
<p>如果要正向计算也是可以的，就是写起来稍微有点麻烦：首先算出最长的元素和不超过 x 的后缀，然后不断枚举前缀长度，另一个指针指向后缀最左元素，答案就是前缀+后缀长度之和的最小值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, n = nums.length, right = n;</span><br><span class="line">        <span class="keyword">while</span> (right &gt; <span class="number">0</span> &amp;&amp; sum + nums[right - <span class="number">1</span>] &lt;= x) <span class="comment">// 计算最长后缀</span></span><br><span class="line">            sum += nums[--right];</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">0</span> &amp;&amp; sum &lt; x) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 全部移除也无法满足要求</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> sum == x ? n - right : n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; n; ++left) &#123;</span><br><span class="line">            sum += nums[left];</span><br><span class="line">            <span class="keyword">while</span> (right &lt; n &amp;&amp; sum &gt; x) <span class="comment">// 缩小后缀长度</span></span><br><span class="line">                sum -= nums[right++];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; x) <span class="keyword">break</span>; <span class="comment">// 缩小失败，说明前缀过长</span></span><br><span class="line">            <span class="keyword">if</span> (sum == x) ans = Math.min(ans, left + <span class="number">1</span> + n - right); <span class="comment">// 前缀+后缀长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &gt; n ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6、LC1813-句子相似性-III"><a href="#1-6、LC1813-句子相似性-III" class="headerlink" title="1.6、LC1813. 句子相似性 III"></a>1.6、LC1813. 句子相似性 III</h4><p>一个句子是由一些单词与它们之间的单个空格组成，且句子的开头和结尾没有多余空格。比方说，<code>&quot;Hello World&quot;</code> ，<code>&quot;HELLO&quot;</code> ，<code>&quot;hello world hello world&quot;</code> 都是句子。每个单词都 <strong>只</strong> 包含大写和小写英文字母。</p>
<p>如果两个句子 <code>sentence1</code> 和 <code>sentence2</code> ，可以通过往其中一个句子插入一个任意的句子（<strong>可以是空句子</strong>）而得到另一个句子，那么我们称这两个句子是 <strong>相似的</strong> 。比方说，<code>sentence1 = &quot;Hello my name is Jane&quot;</code> 且 <code>sentence2 = &quot;Hello Jane&quot;</code> ，我们可以往 <code>sentence2</code> 中 <code>&quot;Hello&quot;</code> 和 <code>&quot;Jane&quot;</code> 之间插入 <code>&quot;my name is&quot;</code> 得到 <code>sentence1</code> 。</p>
<p>给你两个句子 <code>sentence1</code> 和 <code>sentence2</code> ，如果 <code>sentence1</code> 和 <code>sentence2</code> 是相似的，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：sentence1 = &quot;My name is Haley&quot;, sentence2 = &quot;My Haley&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：可以往 sentence2 中 &quot;My&quot; 和 &quot;Haley&quot; 之间插入 &quot;name is&quot; ，得到 sentence1 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：sentence1 = &quot;of&quot;, sentence2 = &quot;A lot of words&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：没法往这两个句子中的一个句子只插入一个句子就得到另一个句子。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：sentence1 = &quot;Eating right now&quot;, sentence2 = &quot;Eating&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：可以往 sentence2 的结尾插入 &quot;right now&quot; 得到 sentence1 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：sentence1 = &quot;Luky&quot;, sentence2 = &quot;Lucccky&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= sentence1.length, sentence2.length &lt;= 100</code></li>
<li><code>sentence1</code> 和 <code>sentence2</code> 都只包含大小写英文字母和空格。</li>
<li><code>sentence1</code> 和 <code>sentence2</code> 中的单词都只由单个空格隔开。</li>
</ul>
<p>Related Topics</p>
<p>数组</p>
<p>双指针</p>
<p>字符串</p>
<p>👍 66</p>
<p>👎 0</p>
<p><strong>方法一：字符串按空格分割 + 双指针</strong></p>
<p><strong>思路</strong></p>
<p>根据题意，两个句子 sentence1 和 sentence2，如果是相似的，那么这两个句子按空格分割得到的字符串数组 words1 和 words2，一定能通过往其中一个字符串数组中插入某个字符串数组（可以为空），得到另一个字符串数组。这个验证可以通过双指针完成。<em>i</em> 表示两个字符串数组从左开始，最多有 i 个字符串相同。<em>j</em> 表示剩下的字符串数组从右开始，最多有 <em>j</em> 个字符串相同。如果 i*+*j 正好是某个字符串数组的长度，那么原字符串就是相似的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">areSentencesSimilar</span><span class="params">(String sentence1, String sentence2)</span> &#123;</span><br><span class="line">        String[] words1 = sentence1.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        String[] words2 = sentence2.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; words1.length &amp;&amp; i &lt; words2.length &amp;&amp; words1[i].equals(words2[i])) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; words1.length - i &amp;&amp; j &lt; words2.length - i &amp;&amp; words1[words1.length - j - <span class="number">1</span>].equals(words2[words2.length - j - <span class="number">1</span>])) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + j == Math.min(words1.length, words2.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O*(<em>m</em>+<em>n</em>)，其中 m* 是 sentence<em>1 的长度，n</em> 是 sentence<em>2 的长度。字符串分割和双指针判断操作都需要遍历 O</em>(<em>m</em>+<em>n</em>) 个字符。</li>
<li>空间复杂度：O*(<em>m</em>+<em>n</em>)。字符串分割需要 O*(<em>m</em>+<em>n</em>) 的空间，双指针消耗 O(1) 空间。</li>
</ul>
<h4 id="1-7、LC88-合并两个有序数组"><a href="#1-7、LC88-合并两个有序数组" class="headerlink" title="1.7、LC88. 合并两个有序数组"></a>1.7、LC88. 合并两个有序数组</h4><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p>
<p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p>
<p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line">解释：需要合并 [1,2,3] 和 [2,5,6] 。</span><br><span class="line">合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并 [1] 和 [] 。</span><br><span class="line">合并结果是 [1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [0], m = 0, nums2 = [1], n = 1</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并的数组是 [] 和 [1] 。</span><br><span class="line">合并结果是 [1] 。</span><br><span class="line">注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>nums1.length == m + n</code></li>
<li><code>nums2.length == n</code></li>
<li><code>0 &lt;= m, n &lt;= 200</code></li>
<li><code>1 &lt;= m + n &lt;= 200</code></li>
<li><code>-109 &lt;= nums1[i], nums2[j] &lt;= 109</code></li>
</ul>
<p><strong>进阶：</strong>你可以设计实现一个时间复杂度为 <code>O(m + n)</code> 的算法解决此问题吗？</p>
<p>Related Topics</p>
<p>数组</p>
<p>双指针</p>
<p>排序</p>
<p>👍 1705</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<ol>
<li>双指针从后向前遍历，每次选取大的数放在数组上。</li>
<li>注意循环的边界处理，当 len2 &lt; 0 也就是 nums2 的数已经完了，就直接遍历 nums1 的数，同理 len1 &lt; 0也是一样的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> m - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums1.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (len &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (len2 &lt; <span class="number">0</span> || (len1 &gt;= <span class="number">0</span> &amp;&amp; nums1[len1] &gt;= nums2[len2])) &#123;</span><br><span class="line">                nums1[len--] = nums1[len1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[len--] = nums2[len2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度O(M + N)</li>
<li>空间复杂度O(1)</li>
</ul>
<h4 id="1-8、LC165-比较版本号"><a href="#1-8、LC165-比较版本号" class="headerlink" title="1.8、LC165. 比较版本号"></a>1.8、LC165. 比较版本号</h4><p>给你两个版本号 <code>version1</code> 和 <code>version2</code> ，请你比较它们。</p>
<p>版本号由一个或多个修订号组成，各修订号由一个 <code>&#39;.&#39;</code> 连接。每个修订号由 <strong>多位数字</strong> 组成，可能包含 <strong>前导零</strong> 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，<code>2.5.33</code> 和 <code>0.1</code> 都是有效的版本号。</p>
<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 <strong>忽略任何前导零后的整数值</strong> 。也就是说，修订号 <code>1</code> 和修订号 <code>001</code> <strong>相等</strong> 。如果版本号没有指定某个下标处的修订号，则该修订号视为 <code>0</code> 。例如，版本 <code>1.0</code> 小于版本 <code>1.1</code> ，因为它们下标为 <code>0</code> 的修订号相同，而下标为 <code>1</code> 的修订号分别为 <code>0</code> 和 <code>1</code> ，<code>0 &lt; 1</code> 。</p>
<p>返回规则如下：</p>
<ul>
<li>如果 <code>*version1* &gt; *version2*</code> 返回 <code>1</code>，</li>
<li>如果 <code>*version1* &lt; *version2*</code> 返回 <code>-1</code>，</li>
<li>除此之外返回 <code>0</code>。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：忽略前导零，&quot;01&quot; 和 &quot;001&quot; 都表示相同的整数 &quot;1&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：version1 没有指定下标为 2 的修订号，即视为 &quot;0&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：version1 中下标为 0 的修订号是 &quot;0&quot;，version2 中下标为 0 的修订号是 &quot;1&quot; 。0 &lt; 1，所以 version1 &lt; version2</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= version1.length, version2.length &lt;= 500</code></li>
<li><code>version1</code> 和 <code>version2</code> 仅包含数字和 <code>&#39;.&#39;</code></li>
<li><code>version1</code> 和 <code>version2</code> 都是 <strong>有效版本号</strong></li>
<li><code>version1</code> 和 <code>version2</code> 的所有修订号都可以存储在 <strong>32 位整数</strong> 中</li>
</ul>
<p>Related Topics</p>
<p>双指针</p>
<p>字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareVersion</span><span class="params">(String version1, String version2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="number">0</span>, v2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (v1 &lt; version1.length() || v2 &lt; version2.length()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (v1 &lt; version1.length() &amp;&amp; version1.charAt(v1) != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                sum1 = sum1 * <span class="number">10</span> + version1.charAt(v1) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                v1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (v2 &lt; version2.length() &amp;&amp; version2.charAt(v2) != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                sum2 = sum2 * <span class="number">10</span> + version2.charAt(v2) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                v2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum1 &lt; sum2) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum1 &gt; sum2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                v1++;</span><br><span class="line">                v2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-9、移动零"><a href="#1-9、移动零" class="headerlink" title="1.9、移动零"></a>1.9、移动零</h4><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure>



<p><strong>提示</strong>:</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
</ul>
<p><strong>进阶：</strong>你能尽量减少完成的操作次数吗？</p>
<p>Related Topics</p>
<p>数组</p>
<p>双指针</p>
<p>👍 1964</p>
<p>👎 0</p>
<p>双指针发，left指向为0元素的下标，right指向非0元素的下标，right给一个大于left的提前量，保证left在right的前表。进行交换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] == <span class="number">0</span> &amp;&amp; nums[right] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[left] ^= nums[right];</span><br><span class="line">                nums[right] ^= nums[left];</span><br><span class="line">                nums[left] ^= nums[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] != <span class="number">0</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="2、链表"><a href="#2、链表" class="headerlink" title="2、链表"></a>2、链表</h3><h4 id="2-1、LC141-环形链表"><a href="#2-1、LC141-环形链表" class="headerlink" title="2.1、LC141. 环形链表"></a>2.1、LC141. 环形链表</h4><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p>
<p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/circularlinkedlist.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 104]</code></li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>
</ul>
<p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p>
<p>判断链表有没有环</p>
<ol>
<li>定义快慢指针，快指针每次走两步，慢指针每次走一步。</li>
<li>如果快指针先到达了null证明没有环。</li>
<li>如果慢指针追上快指针，则说明有环。</li>
<li>当快慢指针相遇后，让快指针开始每次走一步，慢指针回到原点，再次让他们相遇就是环的入口节</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双指针</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2、LC142-环形链表II"><a href="#2-2、LC142-环形链表II" class="headerlink" title="2.2、LC142. 环形链表II"></a>2.2、LC142. 环形链表II</h4><p>给定一个链表的头节点 <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/circularlinkedlist-16812197239291.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../images/算法篇-双指针/202210181732061.png" alt="image-20221018173023802" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123; <span class="comment">//有环</span></span><br><span class="line">            slow = head;</span><br><span class="line">            <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3、剑指-Offer-18-删除链表的节点"><a href="#2-3、剑指-Offer-18-删除链表的节点" class="headerlink" title="2.3、剑指 Offer 18. 删除链表的节点"></a>2.3、剑指 Offer 18. 删除链表的节点</h4><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p><strong>注意：</strong>此题对比原题有改动</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], val = 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], val = 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong></p>
<ul>
<li>题目保证链表中节点的值互不相同</li>
<li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li>
</ul>
<p>Related Topics</p>
<p>链表</p>
<p>👍 268</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>本题删除值为 val 的节点分需为两步：定位节点、修改引用。</p>
<ol>
<li>定位节点： 遍历链表，直到 head.val &#x3D;&#x3D; val 时跳出，即可定位目标节点。</li>
<li>修改引用： 设节点 cur 的前驱节点为 pre ，后继节点为 cur.next ；则执行 pre.next &#x3D; cur.next ，即可实现删除 cur 节点。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/1613757478-NBOvjn-Picture1.png" alt="Picture1.png"></p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>特例处理： 当应删除头节点 head 时，直接返回 head.next 即可。</li>
<li>初始化： pre &#x3D; head , cur &#x3D; head.next 。</li>
<li>定位节点： 当 cur 为空 或 cur 节点值等于 val 时跳出。<ol>
<li>保存当前节点索引，即 pre &#x3D; cur 。</li>
<li>遍历下一节点，即 cur &#x3D; cur.next 。</li>
</ol>
</li>
<li>删除节点： 若 cur 指向某节点，则执行 pre.next &#x3D; cur.next ；若 cur 指向 null ，代表链表中不包含值为 val 的节点。</li>
<li>返回值： 返回链表头部节点 head 即可。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/1599417705-nRNZwN-Picture5.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 只能删除一个节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span>(head.val == val) <span class="keyword">return</span> head.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head, cur = head.next;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span> &amp;&amp; cur.val != val) &#123;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur != <span class="literal">null</span>) pre.next = cur.next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 可以删多个节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.val == val) &#123; <span class="comment">// 处理头节点</span></span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        <span class="keyword">if</span> (next.val == val) &#123;</span><br><span class="line">            cur.next = next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N) ： N 为链表长度，删除操作平均需循环 N&#x2F;2 次，最差 N 次。</li>
<li>空间复杂度 O(1) ： cur, pre 占用常数大小额外空间。</li>
</ul>
<h4 id="2-4、剑指-Offer-22-链表中倒数第-k-个节点"><a href="#2-4、剑指-Offer-22-链表中倒数第-k-个节点" class="headerlink" title="2.4、剑指 Offer 22. 链表中倒数第 k 个节点"></a>2.4、剑指 Offer 22. 链表中倒数第 k 个节点</h4><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>
<p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<p>Related Topics</p>
<p>链表</p>
<p>双指针</p>
<p>👍 418</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：<br>第一时间想到的解法：</p>
<ol>
<li>先遍历统计链表长度，记为 len ；</li>
<li>设置一个指针走 (len-k) 步，即可找到链表倒数第 k 个节点；</li>
</ol>
<p>使用双指针则可以不用统计链表长度。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/1600794523-AAMvoP-Picture1.png" alt="Picture1.png"></p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>初始化： 前指针 former 、后指针 latter ，双指针都指向头节点 head 。</li>
<li>构建双指针距离： 前指针 former 先向前走 k 步（结束后，双指针 former 和 latter 间相距 k 步）。</li>
<li>双指针共同移动： 循环中，双指针 former 和 latter 每轮都向前走一步，直至 former 走过链表 尾节点 时跳出（跳出后， latter 与尾节点距离为 k-1，即 latter 指向倒数第 k 个节点）。</li>
<li>返回值： 返回 latter 即可。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/1600794523-NHOoqg-Picture8.png" alt="img"></p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N) ： N 为链表长度；总体看， former 走了 N 步， latter 走了 (N-k) 步。</li>
<li>空间复杂度 O(1) ： 双指针 former , latter 使用常数大小的额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">former</span> <span class="operator">=</span> head, latter = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            <span class="keyword">if</span>(former == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            former = former.next;</span><br><span class="line">        <span class="keyword">while</span>(former != <span class="literal">null</span>) &#123;</span><br><span class="line">            former = former.next;</span><br><span class="line">            latter = latter.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> latter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>code2:先统计链表长度，再遍历一次返回倒数第k个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 统计长度</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    len = len - k;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span> (len != <span class="number">0</span>) &#123;</span><br><span class="line">        len--;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5、LC206-反转链表"><a href="#2-5、LC206-反转链表" class="headerlink" title="2.5、LC206. 反转链表"></a>2.5、LC206. 反转链表</h4><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/rev1ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/rev1ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<p>Related Topics</p>
<p>递归</p>
<p>链表</p>
<p>👍 2890</p>
<p>👎 0</p>
<p><strong>双指针</strong></p>
<ul>
<li>我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的。</li>
<li>第二个指针 cur 指向 head，然后不断遍历 cur。</li>
<li>每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。</li>
<li>都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。<br>动画演示如下：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/7d8712af4fbb870537607b1dd95d66c248eb178db4319919c32d9304ee85b602-%E8%BF%AD%E4%BB%A3.gif" alt="迭代.gif"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head, next;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        next = cur.next; <span class="comment">// 记录当前节点的下一个节点</span></span><br><span class="line">        cur.next = pre; <span class="comment">// 然后将当前节点指向pre</span></span><br><span class="line">        <span class="comment">// pre和cur节点都前进一位</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度O(N)</li>
<li>空间复杂度O(1)</li>
</ul>
<p><strong>递归</strong></p>
<p>递归的两个条件：</p>
<p>终止条件是当前节点或者下一个节点&#x3D;&#x3D;null<br>在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head.next.next = head</span><br></pre></td></tr></table></figure>

<p>很不好理解，其实就是 head 的下一个节点指向head。</p>
<p>递归函数中每次返回的 cur 其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。</p>
<p>动画演示如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif" alt="递归.gif"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">//递归终止条件是当前为空，或者下一个节点为空</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的cur就是最后一个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">    <span class="comment">//这里请配合动画演示理解</span></span><br><span class="line">    <span class="comment">//如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span></span><br><span class="line">    <span class="comment">//而head是4，head的下一个是5，下下一个是空</span></span><br><span class="line">    <span class="comment">//所以head.next.next 就是5-&gt;4</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    <span class="comment">//防止链表循环，需要将head.next设置为空</span></span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6、LC234-回文链表"><a href="#2-6、LC234-回文链表" class="headerlink" title="2.6、LC234. 回文链表"></a>2.6、LC234. 回文链表</h4><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/pal1linked-list.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/pal2linked-list.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围<code>[1, 105]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
</ul>
<p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p>
<p>Related Topics</p>
<p>栈</p>
<p>递归</p>
<p>链表</p>
<p>双指针</p>
<p>👍 1656</p>
<p>👎 0</p>
<p><strong>解法一：辅助空间法</strong></p>
<p>用数组，栈，或者线性表记录下链表遍历过的数字，通过转化为数组来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性表记录</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome2</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        list.add(head.val);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size() / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.get(i) != list.get(list.size() - <span class="number">1</span> - i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(N)</li>
</ul>
<p><strong>解法二：双指针法</strong></p>
<p>根据回文的特性，从中间进行分割，两边的数据应该是一样的。</p>
<p>因此，可以对链表进行以下处理：</p>
<ol>
<li>先进行分割<ul>
<li>如果链表结点个数为偶数，则分割后两个链表的元素数相同；</li>
<li>如果链表的节点数为基数，则分割后，两个链表的元素个数不相同，左边的个数大于右边，忽略这一个节点。</li>
</ul>
</li>
<li>对链表进行翻转</li>
<li>对两个链表进行比较</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分割链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummy, slow = dummy;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> slow.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    slow.next = <span class="literal">null</span>;</span><br><span class="line">    slow = dummy.next;</span><br><span class="line">    <span class="comment">// 反转链表</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较</span></span><br><span class="line">    <span class="keyword">while</span> (pre != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre.val != slow.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(N)</li>
<li>空间复杂度：O(1)</li>
</ul>
<blockquote>
<p>参考：</p>
<ul>
<li>力扣Krahets：<a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/5dj09d/">https://leetcode.cn/leetbook/read/illustration-of-algorithm/5dj09d/</a></li>
</ul>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://www.haungrd.top">Huang RD</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.haungrd.top/2023/04/11/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/">http://www.haungrd.top/2023/04/11/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.haungrd.top" target="_blank">Huang Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E7%BB%84/">数组</a><a class="post-meta__tags" href="/tags/%E9%93%BE%E8%A1%A8/">链表</a><a class="post-meta__tags" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/">双指针</a><a class="post-meta__tags" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a></div><div class="post_share"><div class="social-share" data-image="https://www.huangrd.top/images/agentina/5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/11/%E7%AE%97%E6%B3%95%E7%AF%87-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">算法篇-滑动窗口</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/10/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/14.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法篇-二分搜索</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/26/%E7%AE%97%E6%B3%95%E7%AF%87-%E9%93%BE%E8%A1%A8/" title="算法篇-链表"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-26</div><div class="title">算法篇-链表</div></div></a></div><div><a href="/2023/04/11/%E7%AE%97%E6%B3%95%E7%AF%87-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" title="算法篇-滑动窗口"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">算法篇-滑动窗口</div></div></a></div><div><a href="/2023/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构篇-高级数据结构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="title">数据结构篇-高级数据结构</div></div></a></div><div><a href="/2023/04/10/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/" title="算法篇-二分搜索"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-10</div><div class="title">算法篇-二分搜索</div></div></a></div><div><a href="/2023/04/13/%E7%AE%97%E6%B3%95%E7%AF%87-%E6%8E%92%E5%BA%8F/" title="算法篇-排序"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="title">算法篇-排序</div></div></a></div><div><a href="/2023/02/11/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" title="算法总结"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-11</div><div class="title">算法总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9B%E6%89%A3%E9%A2%98%E7%9B%AE"><span class="toc-text">力扣题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">1、数组 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E3%80%81LC11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">1.1、LC11. 盛最多水的容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E3%80%81%E5%89%91%E6%8C%87-Offer-21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="toc-text">1.2、剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E3%80%81LC1750-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%A4%E7%AB%AF%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%E5%90%8E%E7%9A%84%E6%9C%80%E7%9F%AD%E9%95%BF%E5%BA%A6"><span class="toc-text">1.3、LC1750. 删除字符串两端相同字符后的最短长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4%E3%80%81LC15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">1.4、LC15. 三数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5%E3%80%81LC1658-%E5%B0%86-x-%E5%87%8F%E5%88%B0-0-%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="toc-text">1.5、LC1658. 将 x 减到 0 的最小操作数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6%E3%80%81LC1813-%E5%8F%A5%E5%AD%90%E7%9B%B8%E4%BC%BC%E6%80%A7-III"><span class="toc-text">1.6、LC1813. 句子相似性 III</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7%E3%80%81LC88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">1.7、LC88. 合并两个有序数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8%E3%80%81LC165-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-text">1.8、LC165. 比较版本号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9%E3%80%81%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-text">1.9、移动零</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%93%BE%E8%A1%A8"><span class="toc-text">2、链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E3%80%81LC141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-text">2.1、LC141. 环形链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E3%80%81LC142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II"><span class="toc-text">2.2、LC142. 环形链表II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E3%80%81%E5%89%91%E6%8C%87-Offer-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">2.3、剑指 Offer 18. 删除链表的节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4%E3%80%81%E5%89%91%E6%8C%87-Offer-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-text">2.4、剑指 Offer 22. 链表中倒数第 k 个节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5%E3%80%81LC206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">2.5、LC206. 反转链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6%E3%80%81LC234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-text">2.6、LC234. 回文链表</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Huang RD</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>