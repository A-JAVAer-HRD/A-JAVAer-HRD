<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Redis 复习提升 | Huang Blog</title><meta name="author" content="Huang RD"><meta name="copyright" content="Huang RD"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Redis 复习提升一、基础概念定义Redis 是一个基于内存实现的 Key-Value 数据结构的 Nosql 数据库。 它提供了 5 种常用的数据类型，String、Map、Set、ZSet、List。针对不同的结构，可以解决不同场景的问题。如 热点排序，点赞关注，最小距离等 Redis 还可以用来做 布式锁、分布式 session、做查询缓存、消息队列等 其次，由于 Redis 是基于内存存">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 复习提升">
<meta property="og:url" content="http://www.haungrd.top/2023/03/03/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/index.html">
<meta property="og:site_name" content="Huang Blog">
<meta property="og:description" content="Redis 复习提升一、基础概念定义Redis 是一个基于内存实现的 Key-Value 数据结构的 Nosql 数据库。 它提供了 5 种常用的数据类型，String、Map、Set、ZSet、List。针对不同的结构，可以解决不同场景的问题。如 热点排序，点赞关注，最小距离等 Redis 还可以用来做 布式锁、分布式 session、做查询缓存、消息队列等 其次，由于 Redis 是基于内存存">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.huangrd.top/images/agentina/5.jpg">
<meta property="article:published_time" content="2023-03-03T12:12:57.000Z">
<meta property="article:modified_time" content="2023-06-09T02:27:02.136Z">
<meta property="article:author" content="Huang RD">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="底层">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.huangrd.top/images/agentina/5.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.haungrd.top/2023/03/03/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis 复习提升',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-09 10:27:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://getwallpapers.com/wallpaper/full/a/1/8/1057222-free-download-cool-nature-backgrounds-1920x1200-windows-10.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">74</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.huangrd.top/images/agentina/5.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Huang Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis 复习提升</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-03T12:12:57.000Z" title="发表于 2023-03-03 20:12:57">2023-03-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-09T02:27:02.136Z" title="更新于 2023-06-09 10:27:02">2023-06-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>41分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis 复习提升"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Redis-复习提升"><a href="#Redis-复习提升" class="headerlink" title="Redis 复习提升"></a>Redis 复习提升</h1><h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Redis 是一个基于<code>内存</code>实现的 <code>Key-Value</code> 数据结构的 <code>Nosql 数据库</code>。</p>
<p>它提供了 5 种常用的数据类型，String、Map、Set、ZSet、List。针对不同的结构，可以解决不同场景的问题。如 热点排序，点赞关注，最小距离等</p>
<p>Redis 还可以用来做 布式锁、分布式 session、做查询缓存、消息队列等</p>
<p>其次，由于 Redis 是基于内存存储，并且在数据结构上做了大量的优化所以 IO <code>性能比较好</code>，在实际开发中，会把它作为应用与数据库之间的一个<code>分布式缓存组件</code>。</p>
<p>并且它又是一个非关系型数据的存储，不存在表之间的关联查询问题，所以它可以很好的提升应用程序的数据 IO 效率。</p>
<p>最后，作为企业级开发来说，它又提供了主从复制+哨兵、以及集群方式实现高可用在 Redis 集群里面，通过 hash 槽的方式实现了数据分片，进一步提升了性能。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303103110007.png" alt="image-20230303103110007"></p>
<h2 id="二、常见的应用场景"><a href="#二、常见的应用场景" class="headerlink" title="二、常见的应用场景"></a>二、常见的应用场景</h2><h3 id="分布式-session"><a href="#分布式-session" class="headerlink" title="分布式 session"></a>分布式 session</h3><p>Http 是无状态的连接，需要服务器保证用户的信息，可以存在服务器的 session 中，但是对于分布式项目来说，可能有多台应用服务器，要实现 session 共享的话，就可以使用 redis 来缓存用户信息。</p>
<p>通过 cookie 把 redis 中存入用户信息的 key 发给用户，用户每次请求来携带就可以识别用户的信息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303104453272.png" alt="image-20230303104453272"></p>
<p>对于拦截器的处理</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303104555709.png" alt="image-20230303104555709"></p>
<h3 id="做查询缓存"><a href="#做查询缓存" class="headerlink" title="做查询缓存"></a>做查询缓存</h3><p>对于一些频繁被用户所查寻的数据，正常情况下他每次都会去数据库查询，数据库的压力太大，严重情况下可能会让数据库挂掉。因此将常见的数据缓存在 redis 中可以提高系统的可用性和效率。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303104640130.png" alt="image-20230303104640130"></p>
<p>例如：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303104742233.png" alt="image-20230303104742233"></p>
<h4 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h4><p>缓存更新是 redis 为了节约内存，为了<code>防止缓存中的数据过多</code>，所以redis会对部分数据进行更新或者淘汰。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303105259684.png" alt="image-20230303105259684"></p>
<p><strong>数据库缓存不一致解决方案</strong></p>
<p>由于我们的缓存的数据源来自于<code>数据库</code>,而数据库的<strong>数据是会发生变化的</strong>,因此,如果当数据库中<strong>数据发生变化,而缓存却没有同步</strong>,此时就会有<strong>一致性问题存在</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303105702368.png" alt="image-20230303105702368"></p>
<p>如何保证缓存与数据库的操作的同时成功或失败？</p>
<ul>
<li>单体系统，将缓存与数据库操作放在一个事务</li>
<li>分布式系统，利用 TCC 等分布式事务方案</li>
</ul>
<p>对于缓存的处理一般是<code>直接删除</code>，在下一次查询的时候重新建立缓存。</p>
<p>应当<code>先操作数据库，再删除缓存</code>，原因在于，如果先删缓存，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p>
<h4 id="缓存的存在问题"><a href="#缓存的存在问题" class="headerlink" title="缓存的存在问题"></a>缓存的存在问题</h4><p>但是缓存又会引入相关的一些问题如：<strong>缓存击穿，缓存穿透，缓存雪崩</strong>等问题。</p>
<h5 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h5><p><code>缓存穿透</code>是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>缓存空对象<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤<ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303110232531.png" alt="image-20230303110232531"></p>
<p>利用缓存空对象解决缓存穿透</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303110341436.png" alt="image-20230303110341436"></p>
<p><strong>缓存穿透的解决方案</strong>：</p>
<ul>
<li>缓存null值</li>
<li>布隆过滤</li>
<li>增强id的复杂度，避免被猜测id规律</li>
<li>做好数据的基础格式校验</li>
<li>加强用户权限校验</li>
<li>做好热点参数的限流</li>
</ul>
<p>后几种方案都是避免缓存穿透</p>
<h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><p>缓存雪崩是指在<code>同一时段大量的缓存key同时失效或者Redis服务宕机</code>，导致大量请求到达数据库，带来巨大压力。</p>
<p>解决方案：</p>
<ul>
<li>给不同的Key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303110711169.png" alt="image-20230303110711169"></p>
<h5 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h5><p>缓存击穿问题也叫热点Key问题，就是<code>一个被高并发访问并且缓存重建业务较复杂的key突然失效了</code>，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>互斥锁</li>
<li>逻辑过期</li>
</ul>
<p><strong>使用互斥锁来解决</strong>：</p>
<p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303111220132.png" alt="image-20230303111220132"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303111628470.png" alt="image-20230303111628470"></p>
<p>解决方案二、逻辑过期方案</p>
<p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p>
<p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p>
<p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303111800433.png" alt="image-20230303111800433"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303111911996.png" alt="image-20230303111911996"></p>
<p><strong>总结</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303111832831.png" alt="image-20230303111832831"></p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p>
<p>分布式锁的核心思想:<code>让不同服务器的不同进程共享一把锁</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303112145766.png" alt="image-20230303112145766"></p>
<p><strong>分布式的条件</strong>：</p>
<ul>
<li><p>可见性：多个线程都能看到相同的结果</p>
</li>
<li><p>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</p>
</li>
<li><p>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</p>
</li>
<li><p>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p>
</li>
<li><p>安全性：安全也是程序中必不可少的一环</p>
</li>
</ul>
<h4 id="布式锁的分类"><a href="#布式锁的分类" class="headerlink" title="布式锁的分类"></a>布式锁的分类</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303112456673.png" alt="image-20230303112456673"></p>
<p>实现分布式锁时需要实现的两个基本方法：</p>
<ul>
<li><p>获取锁：</p>
<ul>
<li>互斥：确保只能有一个线程获取锁</li>
<li>非阻塞：尝试一次，成功返回true，失败返回false</li>
</ul>
</li>
<li><p>释放锁：</p>
<ul>
<li>手动释放</li>
<li>超时释放：获取锁时添加一个超时时间</li>
</ul>
</li>
</ul>
<h4 id="分布式锁核心思路"><a href="#分布式锁核心思路" class="headerlink" title="分布式锁核心思路"></a>分布式锁核心思路</h4><p>利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的线程，等待一定时间后重试。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303112658807.png" alt="image-20230303112658807"></p>
<h4 id="分布式锁的误删"><a href="#分布式锁的误删" class="headerlink" title="分布式锁的误删"></a>分布式锁的误删</h4><p>逻辑说明：</p>
<p>持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除。</p>
<p>解决方案：解决方案就是在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/1653385920025.png" alt="1653385920025"></p>
<p>解决流程：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303113043046.png" alt="image-20230303113043046"></p>
<h4 id="Lua-脚本解决多条命令原子性问题"><a href="#Lua-脚本解决多条命令原子性问题" class="headerlink" title="Lua 脚本解决多条命令原子性问题"></a>Lua 脚本解决多条命令原子性问题</h4><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。</p>
<p><strong>分布式锁的原子性问题</strong></p>
<p>极端的误删逻辑说明：</p>
<p>线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，出现阻塞（JVM垃圾回收），之后锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的。</p>
<p>可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>Java代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用lua脚本</span></span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br><span class="line">经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~</span><br></pre></td></tr></table></figure>

<h4 id="分布式锁-Redission"><a href="#分布式锁-Redission" class="headerlink" title="分布式锁 Redission"></a>分布式锁 Redission</h4><p>基于 setnx 实现的分布式锁存在下面的问题：</p>
<p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p>
<p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p>
<p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p>
<p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/1653546070602.png" alt="1653546070602"></p>
<p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p>
<p>Redission提供了分布式锁的多种多样的功能</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/1653546736063.png" alt="1653546736063"></p>
<h5 id="分布式锁-Redission-可重入锁原理"><a href="#分布式锁-Redission-可重入锁原理" class="headerlink" title="分布式锁 Redission 可重入锁原理"></a>分布式锁 Redission 可重入锁原理</h5><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state&#x3D;0，假如有人持有这把锁，那么state&#x3D;1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。  </p>
<p>在redission中，我们的也支持支持可重入锁</p>
<p>在分布式锁中，他采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，用小key表示当前这把锁被哪个线程持有.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303115825182.png" alt="image-20230303115825182"></p>
<h5 id="分布式锁-Redission-锁的-MutiLock-原理"><a href="#分布式锁-Redission-锁的-MutiLock-原理" class="headerlink" title="分布式锁 Redission 锁的 MutiLock 原理"></a>分布式锁 Redission 锁的 MutiLock 原理</h5><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p>
<p>此时我们去写命令，写在主机上， 主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/1653553998403.png" alt="1653553998403"></p>
<p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁咱们就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/1653554055048.png" alt="1653554055048"></p>
<p>那么MutiLock 加锁原理是什么呢？笔者画了一幅图来说明</p>
<p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功， 那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/1653553093967.png" alt="1653553093967"></p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p>
<ul>
<li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li>
<li>生产者：发送消息到消息队列</li>
<li>消费者：从消息队列获取消息并处理消息</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/1653574849336.png" alt="1653574849336"></p>
<p>使用队列的好处在于 <strong>解耦：</strong>所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。</p>
<p>这种场景在我们秒杀中就变成了：我们下单之后，利用redis去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。</p>
<h4 id="基于List结构模拟消息队列"><a href="#基于List结构模拟消息队列" class="headerlink" title="基于List结构模拟消息队列"></a>基于List结构模拟消息队列</h4><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/1653575176451.png" alt="1653575176451"></p>
<p>基于List的消息队列有哪些优缺点？<br>优点：</p>
<ul>
<li>利用Redis存储，不受限于JVM内存上限</li>
<li>基于Redis的持久化机制，数据安全性有保证</li>
<li>可以满足消息有序性</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法避免消息丢失 （redis自己也有可能挂）</li>
<li>只支持单消费者 （没法实现一条消息被多个消费者消费）</li>
</ul>
<h4 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h4><p>PubSub（发布订阅）是Redis 2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p>
<ul>
<li>SUBSCRIBE channel [channel] ：订阅一个或多个频道</li>
<li>PUBLISH channel msg ：向一个频道发送消息</li>
<li>PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/1653575506373.png" alt="1653575506373"></p>
<p>基于PubSub的消息队列有哪些优缺点？<br>优点：</p>
<ul>
<li>采用发布订阅模型，支持多生产、多消费</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持数据持久化 （发送的消息，如果没人接受的话会直接丢失， 不会保存在redis）</li>
<li>无法避免消息丢失</li>
<li>消息堆积有上限，超出时数据丢失</li>
</ul>
<h4 id="基于Stream的消息队列-消费者组"><a href="#基于Stream的消息队列-消费者组" class="headerlink" title="基于Stream的消息队列-消费者组"></a>基于Stream的消息队列-消费者组</h4><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/1653577801668.png" alt="1653577801668"></p>
<p>创建消费者组：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/1653577984924.png" alt="1653577984924"><br>key：队列名称<br>groupName：消费者组名称<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息<br>MKSTREAM：队列不存在时自动创建队列</p>
<p>队列的XREADGROUP命令特点：</p>
<ul>
<li>消息可回溯</li>
<li>可以多消费者争抢消息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有消息漏读的风险</li>
<li>有消息确认机制，保证消息至少被消费一次</li>
</ul>
<p>最后我们来个小对比</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/1653578560691.png" alt="1653578560691"></p>
<h3 id="Redis-集群问题"><a href="#Redis-集群问题" class="headerlink" title="Redis 集群问题"></a>Redis 集群问题</h3><p>Redis 集群一共有三种 <code>主从集群</code>、<code>哨兵集群</code>、<code>Redis Cluster</code></p>
<p>主从集群，就是在 Redis 集中包括一个 Master 节点和多个 Slave 节点。Master 负责数据的读写，Slave 节点负责数据的读取。Master 上收到的数据变更，会同步到 Slave 节点上实现数据的同步。通过这种架构实现可以 Redis 的<code>读写分离</code>，提升数据的查询性能。</p>
<p>Redis 主从集群<code>不提供容错和恢复功能</code>，一旦 Master 节点挂了，不会自动选出新的 Master，导致后续客户端所有写请求直接失败。所以 Redis 提供了哨兵机制，专门用来监听 Redis 主从集群提供故障的自动处理能力。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303205503547.png" alt="image-20230303205503547"></p>
<p>哨兵会监控 Redis 主从节点的状态，当 Master 节点出现故障，会自动从剩余的Slave 节点中选一个新的 Master。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303205627929.png" alt="image-20230303205627929"></p>
<p>哨兵模式下虽然解决了 <code>Master 选举</code>的问题，但是在线扩容的问题还是没有解决。</p>
<p>Redis Cluster，它实现了 Redis 的分布式存储，也就是每个节点存储不同的数据实现数据的分片.在高可用方面，Redis Cluster 引入了主从复制模式， 一个 Master 节点对应一个或多个 Slave 节点，当 Master 出现故障，会从 Slave 节点中选举一个新的Master 继续提供服务。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230303205753258.png" alt="image-20230303205753258"></p>
<p>Redis Cluster 虽然解决了在线扩容以及故障转移的能力，但也同样有缺点，比如</p>
<ul>
<li>客户端的实现会更加复杂</li>
<li>Slave 节点只是一个冷备节点，不提供分担读操作的压力</li>
<li>Redis 里面的批量操作指令会有限制</li>
</ul>
<p>因此主从模式和 Cluster 模式各有优缺点，在使用的时候需要根据场景需求来选择。</p>
<h2 id="三、面试题"><a href="#三、面试题" class="headerlink" title="三、面试题"></a>三、面试题</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="关系型数据库和NoSQL的区别？"><a href="#关系型数据库和NoSQL的区别？" class="headerlink" title="关系型数据库和NoSQL的区别？"></a>关系型数据库和NoSQL的区别？</h4><ol>
<li><strong>存储方式不同</strong>。关系型数据库采用表的储存方式，而非关系型数据通常以数据集的方式，大量的数据集中存储在一起，类似于键值对、图结构或者文档；</li>
<li><strong>存储结构不同</strong>。关系型数据库按照结构化的方法存储数据。而NoSQL数据库采用的是动态结构，可以根据数据存储的需要灵活的改变数据库的结构；</li>
<li><strong>存储规范不同</strong>。关系型数据库为了避免重复、规范化数据以及充分利用好存储空间，把数据按照最小关系表的形式进行存储。而NoSQL数据库的数据存储方式是用平面数据集的方式集中存放。</li>
<li><strong>扩展方式不同</strong>。关系型数据库为缓解多张数据表的操作中数据操作的瓶颈只能提高处理能力，关系型数据库只具备纵向扩展能力。而NoSQL数据库由于使用的是数据集的存储方式，它的存储方式一定是分布式的，它可以采用横向的方式来开展数据库，也就是可以添加更多数据库服务器到资源池，然后由这些增加的服务器来负担数据量增加的开销。</li>
<li><strong>查询方式不同</strong>。关系型数据库采用结构化查询语言（即<code>SQL</code>）来对数据库进行查询。NoSQL数据库使用的是非结构化查询语言（UnQL），它以数据集（像文档）为单位来管理和操作数据，由于它没有一个统一的标准。</li>
<li><strong>规范化不同</strong>。关系型数据库必须进行数据规范化处理这个过程实现复杂。对于NoSQL数据库则没有这方面的问题，它需要规范化数据，它通常是在一个单独的存储单元中存入一个复杂的数据实体。</li>
<li><strong>事务性不同</strong>。关系型数据库强调ACID规则（原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）），可以满足对事务性要求较高或者需要进行复杂数据查询的数据操作。NoSQL数据库的性能和优点更多的体现在大数据的处理和数据库的扩展方面。</li>
<li><strong>读写性能不同</strong>。关系型数据库十分强调数据的一致性，并为此降低读写性能付出了巨大的代价。而NoSQL数据库在应对大数据方面无论是扩展还是读写都非常容易并且NoSQL数据库大数据管理、检索、读写、分析以及可视化方面具有关系型数据库不可比拟的优势。</li>
<li><strong>授权方式不同</strong>。非关系型数据库大多为开源产品。</li>
</ol>
<h4 id="Redis-有什么用"><a href="#Redis-有什么用" class="headerlink" title="Redis 有什么用?"></a>Redis 有什么用?</h4><p>Redis 是一个基于<code>内存</code>实现的 <code>Key-Value</code> 数据结构的 <code>Nosql 数据库</code>,Redis 读写速度非常快，被广泛应用于缓存方向。</p>
<p>它提供了 5 种常用的数据类型，String、Map、Set、ZSet、List。针对不同的结构，可以解决不同场景的问题。Redis 还支持事务 、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）.</p>
<p>由于 Redis 是基于内存存储，并且在数据结构上做了大量的优化所以 IO <code>性能比较好</code>，在实际开发中，会把它作为应用与数据库之间的一个<code>分布式缓存组件</code>。还可以用来做 <strong>布式锁</strong>、<strong>分布式 session</strong>、做<strong>查询缓存</strong>、<strong>消息队列</strong>等。</p>
<p>最后，作为企业级开发来说，它又提供了主从复制+哨兵、以及集群方式实现高可用在 Redis 集群里面，通过 hash 槽的方式实现了数据分片，进一步提升了性能。</p>
<h4 id="Redis-除了做缓存，还可以做什么？"><a href="#Redis-除了做缓存，还可以做什么？" class="headerlink" title="Redis 除了做缓存，还可以做什么？"></a>Redis 除了做缓存，还可以做什么？</h4><ul>
<li><strong>分布式锁</strong> ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。</li>
<li><strong>限流</strong> ：一般是通过 Redis + Lua 脚本的方式来实现限流。</li>
<li><strong>消息队列</strong> ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li>
<li><strong>复杂业务场景</strong> ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li>
</ul>
<h4 id="Redis-如何实现分布式锁？"><a href="#Redis-如何实现分布式锁？" class="headerlink" title="Redis 如何实现分布式锁？"></a>Redis 如何实现分布式锁？</h4><p>分布式锁需要满足：</p>
<ul>
<li><strong>互斥</strong> ：任意一个时刻，锁只能被一个线程持有；</li>
<li><strong>高可用</strong> ：锁服务是高可用的。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。</li>
<li><strong>可重入</strong>：一个节点获取了锁之后，还可以再次获取锁。</li>
</ul>
<ol>
<li>在 Redis 中， <code>SETNX</code> 命令是可以帮助我们实现互斥。如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， <code>SETNX</code> 啥也不做。</li>
<li>为了防止误删到其他的锁，可以使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。Lua 脚本保证解锁操作的原子性。</li>
<li>为了避免锁无法被释放，我们可以想到的一个解决办法就是： <strong>给这个 key（也就是锁） 设置一个过期时间</strong> 。要保证设置指定 key 的值和过期时间是一个原子操作，通过 Lua 脚本实现。                                    如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。通过 <strong>Redisson</strong> 来实现。</li>
</ol>
<h4 id="Redisson-分布式锁续期原理？"><a href="#Redisson-分布式锁续期原理？" class="headerlink" title="Redisson 分布式锁续期原理？"></a>Redisson 分布式锁续期原理？</h4><p>Redisson 提供了一个专门用来监控和续期锁的 <strong>Watch Dog（ 看门狗）</strong>，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/distributed-lock-redisson-renew-expiration.878c6f2a.png" alt="Redisson 看门狗自动续期"></p>
<h4 id="如何实现可重入锁？"><a href="#如何实现可重入锁？" class="headerlink" title="如何实现可重入锁？"></a>如何实现可重入锁？</h4><p>一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。像 Java 中的 <code>synchronized</code> 和 <code>ReentrantLock</code> 都属于可重入锁。</p>
<p>为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。实际上 Redisson 做好了支持可重入锁的一些类型。</p>
<h4 id="Redis-如何解决集群情况下分布式锁的可靠性？"><a href="#Redis-如何解决集群情况下分布式锁的可靠性？" class="headerlink" title="Redis 如何解决集群情况下分布式锁的可靠性？"></a>Redis 如何解决集群情况下分布式锁的可靠性？</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/redis-master-slave-distributed-lock.ccc5be73.png" alt="img"></p>
<p>Redlock(红锁) 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。</p>
<p>如果要实现一个绝对可靠的分布式锁，可以基于 ZooKeeper，性能会差一些。</p>
<h4 id="如何基于-ZooKeeper-实现分布式锁？"><a href="#如何基于-ZooKeeper-实现分布式锁？" class="headerlink" title="如何基于 ZooKeeper 实现分布式锁？"></a>如何基于 ZooKeeper 实现分布式锁？</h4><p>ZooKeeper 分布式锁是基于 <strong>临时顺序节点</strong> 和 <strong>Watcher（事件监听器）</strong> 实现的。</p>
<p>获取锁：</p>
<ol>
<li>首先我们要有一个持久节点<code>/locks</code>，客户端获取锁就是在<code>locks</code>下创建临时顺序节点。</li>
<li>假设客户端 1 创建了<code>/locks/lock1</code>节点，创建成功之后，会判断 <code>lock1</code>是否是 <code>/locks</code> 下最小的子节点。</li>
<li>如果 <code>lock1</code>是最小的子节点，则获取锁成功。否则，获取锁失败。</li>
<li>如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 并不会不停地循环去尝试加锁，而是在前一个节点比如<code>/locks/lock0</code>上注册一个事件监听器。这个监听器的作用是当前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。</li>
</ol>
<p>释放锁：</p>
<ol>
<li>成功获取锁的客户端在执行完业务流程之后，会将对应的子节点删除。</li>
<li>成功获取锁的客户端在出现故障之后，对应的子节点由于是临时顺序节点，也会被自动删除，避免了锁无法被释放。</li>
<li>我们前面说的事件监听器其实监听的就是这个子节点删除事件，子节点删除就意味着锁被释放。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/distributed-lock-zookeeper.f476fb11-16794881489798.png" alt="img"></p>
<h4 id="Redis-实现消息队列？"><a href="#Redis-实现消息队列？" class="headerlink" title="Redis 实现消息队列？"></a>Redis 实现消息队列？</h4><p>Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 <code>List</code> 来实现。Redis 还提供了 <code>BLPOP</code>、<code>BRPOP</code> 这种阻塞式读取的命令（带 B-Bloking 的都是阻塞式），并且还支持一个超时参数。如果 List 为空，Redis 服务端不会立刻返回结果，它会等待 List 中有新数据后在返回或者是等待最多一个超时时间后返回空。</p>
<hr>
<p>List 实现消息队列功能太简单，像消息确认机制等功能还需要我们自己实现，最要命的是没有广播机制，消息也只能被消费一次.</p>
<p>Redis 2.0 引入了 发布订阅 (pub&#x2F;sub) 解决了 List 实现消息队列没有<strong>广播</strong>机制的问题。</p>
<p>pub&#x2F;sub 涉及发布者和订阅者（也叫消费者）两个角色：</p>
<ul>
<li>发布者通过 <code>PUBLISH</code> 投递消息给指定 channel。</li>
<li>订阅者通过<code>SUBSCRIBE</code>订阅它关心的 channel。并且，订阅者可以订阅一个或者多个 channel。</li>
</ul>
<hr>
<p>pub&#x2F;sub 既能单播又能广播，还支持 channel 的简单正则匹配。不过，消息丢失（客户端断开连接或者 Redis 宕机都会导致消息丢失）、消息堆积（发布者发布消息的时候不会管消费者的具体消费能力如何）等问题依然没有一个比较好的解决办法。</p>
<p>为此，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 来做消息队列。<code>Stream</code> 支持：</p>
<ul>
<li>发布 &#x2F; 订阅模式</li>
<li>按照消费者组进行消费</li>
<li>消息持久化（ RDB 和 AOF）</li>
</ul>
<p><code>Stream</code> 使用起来相对要麻烦一些，这里就不演示了。而且，<code>Stream</code> 在实际使用中依然会有一些小问题不太好解决比如在 Redis 发生故障恢复后不能保证消息至少被消费一次。</p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="Redis-常用的数据结构有哪些？"><a href="#Redis-常用的数据结构有哪些？" class="headerlink" title="Redis 常用的数据结构有哪些？"></a>Redis 常用的数据结构有哪些？</h4><ul>
<li><strong>5 种基础数据结构</strong> ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li>
<li><strong>3 种特殊数据结构</strong> ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</li>
</ul>
<p>Redis 基本数据结构的底层数据结构实现如下：</p>
<table>
<thead>
<tr>
<th align="left">String</th>
<th align="left">List</th>
<th align="left">Hash</th>
<th align="left">Set</th>
<th align="left">Zset</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SDS</td>
<td align="left">LinkedList&#x2F;ZipList&#x2F;QuickList</td>
<td align="left">Hash Table、ZipList</td>
<td align="left">ZipList、Intset</td>
<td align="left">ZipList、SkipList</td>
</tr>
</tbody></table>
<p>简单动态字符串（SDS）、LinkedList（双向链表）、Hash Table（哈希表）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。</p>
<h4 id="使用-HyperLogLog-统计页面-UV-怎么做？"><a href="#使用-HyperLogLog-统计页面-UV-怎么做？" class="headerlink" title="使用 HyperLogLog 统计页面 UV 怎么做？"></a>使用 HyperLogLog 统计页面 UV 怎么做？</h4><p>1、将访问指定页面的每个用户 ID 添加到 <code>HyperLogLog</code> 中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFADD PAGE_1:UV USER1 USER2 ...... USERn</span><br></pre></td></tr></table></figure>

<p>2、统计指定页面的 UV。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFCOUNT PAGE_1:UV</span><br></pre></td></tr></table></figure>

<h4 id="使用-Redis-实现一个排行榜怎么做？"><a href="#使用-Redis-实现一个排行榜怎么做？" class="headerlink" title="使用 Redis 实现一个排行榜怎么做？"></a>使用 Redis 实现一个排行榜怎么做？</h4><p>Redis 中有一个叫做 <code>sorted set</code> 的数据结构经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</p>
<p>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</p>
<h3 id="Redis-的线程模型"><a href="#Redis-的线程模型" class="headerlink" title="Redis 的线程模型"></a>Redis 的线程模型</h3><p>对于读写命令来说，Redis 一直是<strong>单线程</strong>模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。</p>
<h4 id="Redis-单线程模型了解吗？"><a href="#Redis-单线程模型了解吗？" class="headerlink" title="Redis 单线程模型了解吗？"></a>Redis 单线程模型了解吗？</h4><p>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型 <strong>文件事件处理器</strong>（file event handler）。</p>
<p>文件事件处理器使用 <strong>I&#x2F;O 多路复用</strong>（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
<p> I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗。</p>
<p>文件事件处理器（file event handler）主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/redis-event-handler.png" alt="文件事件处理器"></p>
<h4 id="那-Redis6-0-之前为什么不使用多线程？"><a href="#那-Redis6-0-之前为什么不使用多线程？" class="headerlink" title="那 Redis6.0 之前为什么不使用多线程？"></a>那 Redis6.0 之前为什么不使用多线程？</h4><ul>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ul>
<h4 id="Redis6-0-之后为何引入了多线程？"><a href="#Redis6-0-之后为何引入了多线程？" class="headerlink" title="Redis6.0 之后为何引入了多线程？"></a>Redis6.0 之后为何引入了多线程？</h4><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p>
<p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p>
<p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置 IO 线程数 &gt; 1，需要修改 redis 配置文件 <code>redis.conf</code>。</p>
<h3 id="Redis-内存管理"><a href="#Redis-内存管理" class="headerlink" title="Redis 内存管理"></a>Redis 内存管理</h3><h4 id="Redis-给缓存数据设置过期时间有啥用？"><a href="#Redis-给缓存数据设置过期时间有啥用？" class="headerlink" title="Redis 给缓存数据设置过期时间有啥用？"></a>Redis 给缓存数据设置过期时间有啥用？</h4><p>内存是有限的，如果缓存中的所有数据都是一直保存的话，会造成 Out of memory。</p>
<p>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。</p>
<p>除了能够节省内存外，有些业务，比如验证码之类的交给 Redis 做效率更高。</p>
<h4 id="Redis-是如何判断数据是否过期的呢？"><a href="#Redis-是如何判断数据是否过期的呢？" class="headerlink" title="Redis 是如何判断数据是否过期的呢？"></a>Redis 是如何判断数据是否过期的呢？</h4><p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<h4 id="过期的数据的删除策略了解么？"><a href="#过期的数据的删除策略了解么？" class="headerlink" title="过期的数据的删除策略了解么？"></a>过期的数据的删除策略了解么？</h4><ol>
<li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ol>
<p>Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong>。</p>
<h4 id="Redis-内存淘汰机制了解么？"><a href="#Redis-内存淘汰机制了解么？" class="headerlink" title="Redis 内存淘汰机制了解么？"></a>Redis 内存淘汰机制了解么？</h4><p>Redis 提供 6 种数据淘汰策略：</p>
<p>volatile –&gt; 已设置过期时间的数据集</p>
<p>allkeys –&gt; 整个数据集</p>
<p>LRU –&gt; 最近最少使用</p>
<p>TTL –&gt; 将要过期的数据淘汰</p>
<p>Random –&gt; 随机淘汰</p>
<p>LFU –&gt; 最不经常使用</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ol>
<h3 id="Redis-持久化机制"><a href="#Redis-持久化机制" class="headerlink" title="Redis 持久化机制"></a>Redis 持久化机制</h3><h4 id="怎么保证-Redis-挂掉之后再重启数据可以进行恢复？"><a href="#怎么保证-Redis-挂掉之后再重启数据可以进行恢复？" class="headerlink" title="怎么保证 Redis 挂掉之后再重启数据可以进行恢复？"></a>怎么保证 Redis 挂掉之后再重启数据可以进行恢复？</h4><ul>
<li>RDB 快照读</li>
<li>AOF 追加文件</li>
</ul>
<h4 id="什么是-RDB-持久化？"><a href="#什么是-RDB-持久化？" class="headerlink" title="什么是 RDB 持久化？"></a>什么是 RDB 持久化？</h4><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p>
<h4 id="RDB-的执行时机"><a href="#RDB-的执行时机" class="headerlink" title="RDB 的执行时机?"></a>RDB 的执行时机?</h4><p>RDB持久化在四种情况下会执行：</p>
<ul>
<li>执行save命令:主动执行save命令，会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</li>
<li>执行bgsave命令：主动执行bgsave命令可以异步执行RDB，这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</li>
<li>Redis停机时：Redis停机时会执行一次save命令，实现RDB持久化。</li>
<li>触发RDB条件时：Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</li>
</ul>
<h4 id="RDB-的原理了解吗？"><a href="#RDB-的原理了解吗？" class="headerlink" title="RDB 的原理了解吗？"></a>RDB 的原理了解吗？</h4><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p>
<p>fork采用的是copy-on-write技术：</p>
<ul>
<li>当主进程执行读操作时，访问共享内存；</li>
<li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20210725151319695.png" alt="image-20210725151319695"></p>
<h4 id="什么是-AOF-持久化？"><a href="#什么是-AOF-持久化？" class="headerlink" title="什么是 AOF 持久化？"></a>什么是 AOF 持久化？</h4><p>与快照持久化相比，AOF 持久化的实时性更好。</p>
<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p>
<p>三种同步方案</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    <span class="comment">#每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span></span><br><span class="line">appendfsync everysec  <span class="comment">#每秒钟同步一次，显式地将多个写命令同步到硬盘</span></span><br><span class="line">appendfsync no        <span class="comment">#让操作系统决定何时进行同步</span></span><br></pre></td></tr></table></figure>

<h4 id="什么是AOF"><a href="#什么是AOF" class="headerlink" title="什么是AOF?"></a>什么是AOF?</h4><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p>
<h4 id="AOF的配置？"><a href="#AOF的配置？" class="headerlink" title="AOF的配置？"></a>AOF的配置？</h4><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230609101924276.png" alt="image-20230609101924276"></p>
<p>AOF还可以设置文件重写，来减少AOF文件大小。</p>
<h4 id="AOF-日志是如何实现的？"><a href="#AOF-日志是如何实现的？" class="headerlink" title="AOF 日志是如何实现的？"></a>AOF 日志是如何实现的？</h4><p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/redis-aof-write-log-disc.ca22bd65-167949208995011.png" alt="AOF 记录日志过程"></p>
<p><strong>为什么是在执行完命令之后记录日志呢？</strong></p>
<ul>
<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
</ul>
<p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p>
<ul>
<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>
<li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li>
</ul>
<h4 id="RDB-和-AOF-的选择？"><a href="#RDB-和-AOF-的选择？" class="headerlink" title="RDB 和 AOF 的选择？"></a>RDB 和 AOF 的选择？</h4><ul>
<li><p>RDB 的优点是体积更小，恢复更快，性能更高。缺点是故障丢失，耐久性差。</p>
</li>
<li><p>AOF 的优点是数据保证，自动缩小。缺点是性能相对较差，体积相对更大，恢复速度更慢。</p>
</li>
</ul>
<h4 id="Redis-4-0-对于持久化机制做了什么优化？"><a href="#Redis-4-0-对于持久化机制做了什么优化？" class="headerlink" title="Redis 4.0 对于持久化机制做了什么优化？"></a>Redis 4.0 对于持久化机制做了什么优化？</h4><p>由于 RDB 和 AOF 各有优势，于是，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<h3 id="Redis-的事务"><a href="#Redis-的事务" class="headerlink" title="Redis 的事务"></a>Redis 的事务</h3><h4 id="如何使用-Redis-事务？"><a href="#如何使用-Redis-事务？" class="headerlink" title="如何使用 Redis 事务？"></a>如何使用 Redis 事务？</h4><p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能。</p>
<p><code>MULTI</code> 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <code>EXEC</code> 命令后，再执行所有的命令。</p>
<p>这个过程是这样的：</p>
<ol>
<li>开始事务（<code>MULTI</code>）；</li>
<li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；</li>
<li>执行事务(<code>EXEC</code>)。</li>
</ol>
<p>可以通过 <code>DISCARD</code> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p>
<p>你可以通过<code>WATCH</code> 命令监听指定的 Key，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的 Key 被 <strong>其他客户端&#x2F;Session</strong> 修改的话，整个事务都不会被执行。只有在自己的 session 中才可以修改。</p>
<h4 id="Redis-事务支持原子性吗-缺陷-？"><a href="#Redis-事务支持原子性吗-缺陷-？" class="headerlink" title="Redis 事务支持原子性吗(缺陷)？"></a>Redis 事务支持原子性吗(缺陷)？</h4><ul>
<li>不支持原子性</li>
<li>多个命令，多次请求，浪费网络资源</li>
</ul>
<p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的（而且不满足持久性）。</p>
<p>Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>
<p>除了不满足原子性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。</p>
<h4 id="如何解决-Redis-事务的缺陷？"><a href="#如何解决-Redis-事务的缺陷？" class="headerlink" title="如何解决 Redis 事务的缺陷？"></a>如何解决 Redis 事务的缺陷？</h4><p>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</p>
<p>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</p>
<p>如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，仍然不能实现回滚。因此， <strong>严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。</strong></p>
<p>如果想要让 Lua 脚本中的命令全部执行，必须保证语句语法和命令都是对的。</p>
<h3 id="Redis-性能优化"><a href="#Redis-性能优化" class="headerlink" title="Redis 性能优化"></a>Redis 性能优化</h3><h4 id="大量-key-集中过期问题"><a href="#大量-key-集中过期问题" class="headerlink" title="大量 key 集中过期问题"></a>大量 key 集中过期问题</h4><p>对于过期 key，Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 策略。</p>
<p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</p>
<p>常见的方法：</p>
<ol>
<li>给 key 设置随机过期时间。</li>
<li>开启 lazy-free（惰性删除&#x2F;延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li>
</ol>
<h4 id="big-key-问题"><a href="#big-key-问题" class="headerlink" title="big key 问题"></a>big key 问题</h4><p>如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。</p>
<p>寻找 big key:</p>
<ol>
<li>使用 Redis 自带的 <code>--bigkeys</code> 参数来查找。这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。</li>
<li>分析 <code>RDB</code> 文件来找出 big key。</li>
</ol>
<h4 id="Redis-的内存碎片问题"><a href="#Redis-的内存碎片问题" class="headerlink" title="Redis 的内存碎片问题"></a>Redis 的内存碎片问题</h4><p><strong>什么是内存碎片</strong>?</p>
<p>内存碎片简单地理解为那些不可用的空闲内存。Redis 内存碎片虽然不会影响 Redis 性能，但是会增加内存消耗。</p>
<p><strong>为什么会有 Redis 内存碎片?</strong></p>
<ol>
<li>Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。</li>
</ol>
<blockquote>
<p>Redis 使用 <code>zmalloc</code> 方法(Redis 自己实现的内存分配方法)进行内存分配的时候，除了要分配 <code>size</code> 大小的内存之外，还会多分配 <code>PREFIX_SIZE</code> 大小的内存。</p>
</blockquote>
<ol start="2">
<li>频繁修改 Redis 中的数据也会产生内存碎片。</li>
</ol>
<h4 id="如何清理-Redis-内存碎片"><a href="#如何清理-Redis-内存碎片" class="headerlink" title="如何清理 Redis 内存碎片?"></a>如何清理 Redis 内存碎片?</h4><p>Redis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。</p>
<p>直接通过 <code>config set</code> 命令将 <code>activedefrag</code> 配置项设置为 <code>yes</code> 即可。</p>
<p>具体什么时候清理需要通过下面两个参数控制：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内存碎片占用空间达到 500mb 的时候开始清理</span></span><br><span class="line">config <span class="built_in">set</span> active-defrag-ignore-bytes 500mb</span><br><span class="line"><span class="comment"># 内存碎片率大于 1.5 的时候开始清理</span></span><br><span class="line">config <span class="built_in">set</span> active-defrag-threshold-lower 50</span><br></pre></td></tr></table></figure>

<h3 id="Redis-缓存的一些问题"><a href="#Redis-缓存的一些问题" class="headerlink" title="Redis 缓存的一些问题"></a>Redis 缓存的一些问题</h3><h4 id="缓存穿透-1"><a href="#缓存穿透-1" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透说简单点就是大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/redis-cache-penetration.png" alt="缓存穿透"></p>
<p><strong>解决方法</strong></p>
<p><strong>缓存空对象</strong></p>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。</p>
<p>存在的问题：</p>
<ol>
<li>如果有大量恶意请求，会缓存大量空对象；</li>
<li>存在 Redis 和 数据库不一致的问题。</li>
</ol>
<p><strong>布隆过滤器</strong></p>
<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/redis-cache-penetration-bloom-filter.png" alt="加入布隆过滤器之后的缓存处理流程图"></p>
<p>布隆过滤器(hash + bit 图)可能会产生误判问题。<strong>不同的字符串可能哈希出来的位置相同</strong>。</p>
<h4 id="缓存击穿-1"><a href="#缓存击穿-1" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/redis-cache-breakdown.png" alt="缓存击穿"></p>
<p>举个例子 ：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p>
<p><strong>解决方法</strong>：</p>
<ul>
<li>设置热点数据永不过期或者过期时间比较长。</li>
<li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>
<li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li>
</ul>
<h4 id="缓存雪崩-1"><a href="#缓存雪崩-1" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p><strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/redis-cache-avalanche.png" alt="缓存雪崩"></p>
<p><strong>解决办法</strong>：</p>
<p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效（不太推荐，实用性太差）。</li>
<li>设置二级缓存。</li>
</ol>
<h4 id="如何保证缓存和数据库数据的一致性？"><a href="#如何保证缓存和数据库数据的一致性？" class="headerlink" title="如何保证缓存和数据库数据的一致性？"></a>如何保证缓存和数据库数据的一致性？</h4><p>引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。</p>
<p>下面单独对 <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</p>
<p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>
<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加 cache 更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>
</ol>
<h3 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h3><h4 id="如何保证-Redis-服务的高可用"><a href="#如何保证-Redis-服务的高可用" class="headerlink" title="如何保证 Redis 服务的高可用"></a>如何保证 Redis 服务的高可用</h4><p>Redis 高可用的手段主要有以下四种： </p>
<ul>
<li>数据持久化 </li>
<li>主从同步（主从复制） </li>
<li>Redis 哨兵模式（Sentinel） </li>
<li>Redis 集群（Cluster）</li>
</ul>
<p>其中，主从复制是高可用 Redis 的基础，哨兵和集群都是在主从复制基础上实现高可用的。</p>
<h4 id="Redis-的哨兵集群"><a href="#Redis-的哨兵集群" class="headerlink" title="Redis 的哨兵集群"></a>Redis 的哨兵集群</h4><p>哨兵模式是 Redis 的一种特殊模式，它是一个独立的进程，能够独立运行。哨兵模式主要用于监控 Redis 的主从复制集群，当<strong>主节点</strong>出现故障时，哨兵会自动将<strong>从节点</strong>切换为新的主节点，以保证 Redis 集群的高可用性。</p>
<p>哨兵模式的工作原理如下：</p>
<ul>
<li>哨兵通过发送命令向 Redis 服务器询问集群状态。</li>
<li>当哨兵发现某个节点不可用时，它会将该节点标记为“<strong>主观下线</strong>”。</li>
<li>当一个节点被标记为“主观下线”时，哨兵会请求其他哨兵的意见，并根据大多数哨兵的意见来决定该节点是否应该被标记为“客观下线”。</li>
<li>当一个节点被标记为“客观下线”时，哨兵会执行故障转移操作，将从节点切换为新的主节点。</li>
</ul>
<h4 id="Redis-缓存的数据量太大怎么办"><a href="#Redis-缓存的数据量太大怎么办" class="headerlink" title="Redis 缓存的数据量太大怎么办?"></a>Redis 缓存的数据量太大怎么办?</h4><p>哨兵模式可以解决缓存数据量大的问题。当数据量较大时，可以采用 Redis 主从+哨兵模式的解决方案。</p>
<h4 id="Redis-Cluster-虚拟槽分区有什么优点？"><a href="#Redis-Cluster-虚拟槽分区有什么优点？" class="headerlink" title="Redis Cluster 虚拟槽分区有什么优点？"></a>Redis Cluster 虚拟槽分区有什么优点？</h4><p><strong>每个 node 均匀的分配了 slot，缩小增减节点影响的范围</strong> ，提高了集群的横向拓展性和容错性。</p>
<p>缺点：需要存储 node 和 slot 的对应信息</p>
<h4 id="Redis-Cluster-中的各个节点是如何实现数据一致性的？"><a href="#Redis-Cluster-中的各个节点是如何实现数据一致性的？" class="headerlink" title="Redis Cluster 中的各个节点是如何实现数据一致性的？"></a>Redis Cluster 中的各个节点是如何实现数据一致性的？</h4><p>Redis 集群没有使用一致性 hash，而是引入了哈希槽的概念。Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽。集群的每个节点负责一部分哈希槽。这种结构很容易添加或者删除节点，并且无论是添加、删除或者修改某一个节点，都不会造成集群不可用的状态。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://www.haungrd.top">Huang RD</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.haungrd.top/2023/03/03/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/">http://www.haungrd.top/2023/03/03/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.haungrd.top" target="_blank">Huang Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/%E5%BA%95%E5%B1%82/">底层</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="https://www.huangrd.top/images/agentina/5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/03/RabbitMQ%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/9.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Rabbit MQ复习提升</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">面试题整理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" title="面试题整理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-27</div><div class="title">面试题整理</div></div></a></div><div><a href="/2023/03/10/Nginx%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/" title="Nginx 复习提升"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-10</div><div class="title">Nginx 复习提升</div></div></a></div><div><a href="/2023/03/03/RabbitMQ%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/" title="Rabbit MQ复习提升"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-03</div><div class="title">Rabbit MQ复习提升</div></div></a></div><div><a href="/2023/03/07/JavaSE%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/" title="JavaSE 复习提升"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-07</div><div class="title">JavaSE 复习提升</div></div></a></div><div><a href="/2023/03/16/Linux%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/" title="Linux 复习提升"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-16</div><div class="title">Linux 复习提升</div></div></a></div><div><a href="/2023/02/13/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="Java 集合源码分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-13</div><div class="title">Java 集合源码分析</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87"><span class="toc-text">Redis 复习提升</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-text">一、基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">二、常见的应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-session"><span class="toc-text">分布式 session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9A%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-text">做查询缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-text">缓存更新策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98"><span class="toc-text">缓存的存在问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-text">缓存击穿</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">布式锁的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF"><span class="toc-text">分布式锁核心思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E8%AF%AF%E5%88%A0"><span class="toc-text">分布式锁的误删</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lua-%E8%84%9A%E6%9C%AC%E8%A7%A3%E5%86%B3%E5%A4%9A%E6%9D%A1%E5%91%BD%E4%BB%A4%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-text">Lua 脚本解决多条命令原子性问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redission"><span class="toc-text">分布式锁 Redission</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redission-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-text">分布式锁 Redission 可重入锁原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redission-%E9%94%81%E7%9A%84-MutiLock-%E5%8E%9F%E7%90%86"><span class="toc-text">分布式锁 Redission 锁的 MutiLock 原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EList%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">基于List结构模拟消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EPubSub%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">基于PubSub的消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EStream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="toc-text">基于Stream的消息队列-消费者组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E9%9B%86%E7%BE%A4%E9%97%AE%E9%A2%98"><span class="toc-text">Redis 集群问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">三、面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CNoSQL%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">关系型数据库和NoSQL的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-text">Redis 有什么用?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E9%99%A4%E4%BA%86%E5%81%9A%E7%BC%93%E5%AD%98%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Redis 除了做缓存，还可以做什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F"><span class="toc-text">Redis 如何实现分布式锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%BB%AD%E6%9C%9F%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">Redisson 分布式锁续期原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%9F"><span class="toc-text">如何实现可重入锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%9B%86%E7%BE%A4%E6%83%85%E5%86%B5%E4%B8%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9F"><span class="toc-text">Redis 如何解决集群情况下分布式锁的可靠性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E-ZooKeeper-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F"><span class="toc-text">如何基于 ZooKeeper 实现分布式锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-text">Redis 实现消息队列？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Redis 常用的数据结构有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-HyperLogLog-%E7%BB%9F%E8%AE%A1%E9%A1%B5%E9%9D%A2-UV-%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-text">使用 HyperLogLog 统计页面 UV 怎么做？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Redis-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%8E%92%E8%A1%8C%E6%A6%9C%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-text">使用 Redis 实现一个排行榜怎么做？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">Redis 的线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">Redis 单线程模型了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%A3-Redis6-0-%E4%B9%8B%E5%89%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">那 Redis6.0 之前为什么不使用多线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis6-0-%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">Redis6.0 之后为何引入了多线程？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">Redis 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E7%BB%99%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E6%9C%89%E5%95%A5%E7%94%A8%EF%BC%9F"><span class="toc-text">Redis 给缓存数据设置过期时间有啥用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-text">Redis 是如何判断数据是否过期的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F"><span class="toc-text">过期的数据的删除策略了解么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F"><span class="toc-text">Redis 内存淘汰机制了解么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-text">Redis 持久化机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81-Redis-%E6%8C%82%E6%8E%89%E4%B9%8B%E5%90%8E%E5%86%8D%E9%87%8D%E5%90%AF%E6%95%B0%E6%8D%AE%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E6%81%A2%E5%A4%8D%EF%BC%9F"><span class="toc-text">怎么保证 Redis 挂掉之后再重启数据可以进行恢复？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-RDB-%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9F"><span class="toc-text">什么是 RDB 持久化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB-%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA"><span class="toc-text">RDB 的执行时机?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB-%E7%9A%84%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">RDB 的原理了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-AOF-%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9F"><span class="toc-text">什么是 AOF 持久化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAOF"><span class="toc-text">什么是AOF?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E7%9A%84%E9%85%8D%E7%BD%AE%EF%BC%9F"><span class="toc-text">AOF的配置？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E6%97%A5%E5%BF%97%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">AOF 日志是如何实现的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB-%E5%92%8C-AOF-%E7%9A%84%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-text">RDB 和 AOF 的选择？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-4-0-%E5%AF%B9%E4%BA%8E%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">Redis 4.0 对于持久化机制做了什么优化？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%9A%84%E4%BA%8B%E5%8A%A1"><span class="toc-text">Redis 的事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Redis-%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-text">如何使用 Redis 事务？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97-%E7%BC%BA%E9%99%B7-%EF%BC%9F"><span class="toc-text">Redis 事务支持原子性吗(缺陷)？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-Redis-%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%BC%BA%E9%99%B7%EF%BC%9F"><span class="toc-text">如何解决 Redis 事务的缺陷？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">Redis 性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E9%87%8F-key-%E9%9B%86%E4%B8%AD%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98"><span class="toc-text">大量 key 集中过期问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#big-key-%E9%97%AE%E9%A2%98"><span class="toc-text">big key 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E7%9A%84%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98"><span class="toc-text">Redis 的内存碎片问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%B8%85%E7%90%86-Redis-%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="toc-text">如何清理 Redis 内存碎片?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-text">Redis 缓存的一些问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-1"><span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-1"><span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-1"><span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-text">如何保证缓存和数据库数据的一致性？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E9%9B%86%E7%BE%A4"><span class="toc-text">Redis 集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-Redis-%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-text">如何保证 Redis 服务的高可用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E7%9A%84%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4"><span class="toc-text">Redis 的哨兵集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E7%BC%93%E5%AD%98%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%8F%E5%A4%AA%E5%A4%A7%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-text">Redis 缓存的数据量太大怎么办?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-Cluster-%E8%99%9A%E6%8B%9F%E6%A7%BD%E5%88%86%E5%8C%BA%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-text">Redis Cluster 虚拟槽分区有什么优点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-Cluster-%E4%B8%AD%E7%9A%84%E5%90%84%E4%B8%AA%E8%8A%82%E7%82%B9%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-text">Redis Cluster 中的各个节点是如何实现数据一致性的？</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Huang RD</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>