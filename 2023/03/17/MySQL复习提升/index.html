<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Mysql 复习提升 | Huang Blog</title><meta name="author" content="Huang RD"><meta name="copyright" content="Huang RD"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="MySQL 复习提升参考  https:&#x2F;&#x2F;cloud.tencent.com&#x2F;developer&#x2F;article&#x2F;2159576 https:&#x2F;&#x2F;blog.csdn.net&#x2F;wangfeijiu&#x2F;article&#x2F;details&#x2F;113409719 https:&#x2F;&#x2F;javaguide.cn&#x2F;database&#x2F;mysql&#x2F;mysql-logs.html  1、索引索引：提高MySQL的检索速度 索引">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql 复习提升">
<meta property="og:url" content="http://www.haungrd.top/2023/03/17/MySQL%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/index.html">
<meta property="og:site_name" content="Huang Blog">
<meta property="og:description" content="MySQL 复习提升参考  https:&#x2F;&#x2F;cloud.tencent.com&#x2F;developer&#x2F;article&#x2F;2159576 https:&#x2F;&#x2F;blog.csdn.net&#x2F;wangfeijiu&#x2F;article&#x2F;details&#x2F;113409719 https:&#x2F;&#x2F;javaguide.cn&#x2F;database&#x2F;mysql&#x2F;mysql-logs.html  1、索引索引：提高MySQL的检索速度 索引">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.huangrd.top/images/agentina/10.jpg">
<meta property="article:published_time" content="2023-03-17T04:12:57.000Z">
<meta property="article:modified_time" content="2023-04-10T10:49:22.987Z">
<meta property="article:author" content="Huang RD">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="Mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.huangrd.top/images/agentina/10.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.haungrd.top/2023/03/17/MySQL%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Mysql 复习提升',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-10 18:49:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://getwallpapers.com/wallpaper/full/a/1/8/1057222-free-download-cool-nature-backgrounds-1920x1200-windows-10.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">67</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.huangrd.top/images/agentina/10.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Huang Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Mysql 复习提升</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-17T04:12:57.000Z" title="发表于 2023-03-17 12:12:57">2023-03-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-10T10:49:22.987Z" title="更新于 2023-04-10 18:49:22">2023-04-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">26.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>81分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Mysql 复习提升"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="MySQL-复习提升"><a href="#MySQL-复习提升" class="headerlink" title="MySQL 复习提升"></a>MySQL 复习提升</h1><p>参考</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2159576">https://cloud.tencent.com/developer/article/2159576</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangfeijiu/article/details/113409719">https://blog.csdn.net/wangfeijiu/article/details/113409719</a></p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/mysql-logs.html">https://javaguide.cn/database/mysql/mysql-logs.html</a></p>
</blockquote>
<h2 id="1、索引"><a href="#1、索引" class="headerlink" title="1、索引"></a>1、索引</h2><p><strong>索引</strong>：<code>提高MySQL的检索速度</code></p>
<p>索引是对数据库表中一列或多列的值进行排序的一种结构。MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。</p>
<p>索引的<strong>优点</strong>：</p>
<ol>
<li>索引大大减小了服务器需要扫描的数据量，从而大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>索引可以帮助服务器避免排序和创建临时表。</li>
<li>索引可以将随机IO变成顺序IO。</li>
<li>索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组，提高了表访问并发性。</li>
<li>关于InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）。</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ol>
<p>索引的<strong>缺点</strong>：</p>
<ol>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li>
<li>索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，如果需要建立聚簇索引，那么需要占用的空间会更大</li>
<li>对表中的数据进行增、删、改的时候，索引也要动态的维护，这就降低了整数的维护速度</li>
<li>如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</li>
<li>对于非常小的表，大部分情况下简单的全表扫描更高效；</li>
</ol>
<p>应该添加索引的列：</p>
<ol>
<li>在经常需要搜索的列上，可以加快搜索的速度</li>
<li>在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构</li>
<li>在经常用在连接（JOIN）的列上，这些列主要是一外键，可以加快连接的速度</li>
<li>在经常需要根据范围（&lt;，&lt;&#x3D;，&#x3D;，&gt;，&gt;&#x3D;，BETWEEN，IN）进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的</li>
<li>在经常需要排序（order by）的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>
<li>在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li>
</ol>
<h3 id="索引的结构"><a href="#索引的结构" class="headerlink" title="索引的结构"></a>索引的结构</h3><ul>
<li>B tree</li>
<li>B+ tree<ul>
<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li>
<li>不可能在非叶子结点命中；</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li>
<li>每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。</li>
<li>更适合文件索引系统；</li>
</ul>
</li>
<li>Hash</li>
</ul>
<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>按功能分：</p>
<ul>
<li><p><strong>主键索引</strong>：一张表只能有一个主键索引，不允许重复、不允许为 NULL；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TableName <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(column_list); </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>唯一索引</strong>：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX IndexName <span class="keyword">ON</span> `TableName`(`字段名`(length));</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TableName <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (column_list); </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>普通索引</strong>：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX IndexName <span class="keyword">ON</span> `TableName`(`字段名`(length));</span><br><span class="line"># 或者</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TableName <span class="keyword">ADD</span> INDEX IndexName(`字段名`(length));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>全文索引</strong>：它查找的是文本中的关键词，主要用于全文检索。（篇幅较长，下文有独立主题说明）</p>
</li>
</ul>
<p><strong>按列数分</strong>：</p>
<ul>
<li>单例索引：一个索引只包含一个列，一个表可以有多个单例索引。</li>
<li>组合索引：一个组合索引包含两个或两个以上的列。查询的时候遵循 mysql 组合索引的 “最左前缀”原则，即使用 where 时条件要按照建立索引的时候字段的排列方式放置索引才会生效。</li>
</ul>
<p><strong>物理分类</strong>：</p>
<ul>
<li><p>聚簇索引（clustered index）不是单独的一种索引类型，而是一种数据存储方式。这种存储方式是依靠B+树来实现的，根据表的主键构造一棵B+树且B+树叶子节点存放的都是表的行记录数据时，方可称该主键索引为聚簇索引。聚簇索引也可理解为将数据存储与索引放到了一块，找到索引也就找到了数据。</p>
</li>
<li><p>非聚簇索引：数据和索引是分开的，B+树叶子节点存放的不是数据表的行记录。</p>
</li>
</ul>
<p>聚簇索引优缺点：</p>
<ul>
<li><p>优点：</p>
<ul>
<li>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li>
<li>聚簇索引对于主键的排序查找和范围查找速度非常快</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键（主键列不要选没有意义的自增列，选经常查询的条件列才好，不然无法体现其主键索引性能）</li>
<li>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</li>
<li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</li>
</ul>
</li>
</ul>
<p><strong>聚簇索引（主键索引）</strong></p>
<p>B+树 叶子节点包含数据表中行记录就是聚簇索引（索引和数据是存放在一块的）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQL%E4%BA%8B%E5%8A%A1%E3%80%81%E7%B4%A2%E5%BC%95%E3%80%81%E9%94%81%E7%AD%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdmZWlqaXU=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>可以看到叶子节点包含了完整的数据记录，这就是聚簇索引。因为InnoDB的数据文件（.idb）按主键聚集，所以InnoDB必须有主键（MyISAM可以没有），如果没有显示指定主键，则选取首个为唯一且非空的列作为主键索引，如果还没具备，则MySQL将自动创建一个名字为<code>GEN_CLUST_INDEX</code>的隐藏聚簇索引，这个字段长度为6个字节，类型为长整形。</p>
<p>主键索引结构分析：</p>
<ul>
<li>B+树单个叶子节点内的行数据按主键顺序排列，物理空间是连续的（聚簇索引的数据的物理存放顺序与索引顺序是一致的）；</li>
<li>叶子节点之间是通过指针连接，相邻叶子节点的数据在逻辑上也是连续的（根据主键值排序），实际存储时的数据页（叶子节点）可能相距甚远。</li>
</ul>
<p><strong>非聚簇索引（辅助索引或二级索引）</strong></p>
<p>在聚簇索引之外创建的索引（不是根据主键创建的）称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行数据记录，而是主键值。首先通过辅助索引找到主键值，然后到主键索引树中通过主键值找到数据行。也就是<strong>回表</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQL%E4%BA%8B%E5%8A%A1%E3%80%81%E7%B4%A2%E5%BC%95%E3%80%81%E9%94%81%E7%AD%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdmZWlqaXU=,size_16,color_FFFFFF,t_70-16765442311522.png" alt="在这里插入图片描述"></p>
<p>InnoDB<strong>索引优化</strong></p>
<p>InnoDB中主键不宜定义太大，因为辅助索引也会包含主键列，如果主键定义的比较大，其他索引也将很大。如果想在表上定义 、很多索引，则争取尽量把主键定义得小一些。InnoDB 不会压缩索引。</p>
<p>InnoDB中尽量不使用非单调字段作主键（不使用多列），因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<h3 id="Mysql-的一些用法"><a href="#Mysql-的一些用法" class="headerlink" title="Mysql 的一些用法"></a>Mysql 的一些用法</h3><p>Mysql中key 、primary key 、unique key 与index区别：</p>
<ul>
<li><p>key具有两层含义</p>
<ul>
<li>约束（约束和规范数据库的结构完整性）</li>
<li>索引</li>
</ul>
</li>
<li><p>index：索引</p>
</li>
</ul>
<p>key：等价普通索引 key 键名 (列)</p>
<p><strong>primary key</strong>：</p>
<ol>
<li>约束作用（constraint），主键约束（unique，not null，一表一主键，唯一标识记录），规范存储主键和强调唯一性</li>
<li>为这个key建立主键索引</li>
</ol>
<p><strong>unique key</strong>：</p>
<ol>
<li>约束作用（constraint），unique约束（保证列或列集合提供了唯一性）</li>
<li>为这个key建立一个唯一索引；</li>
</ol>
<p><strong>foreign key：</strong></p>
<ol>
<li>约束作用（constraint），外键约束，规范数据的引用完整性</li>
<li>为这个key建立一个普通索引；</li>
</ol>
<h2 id="2、事务"><a href="#2、事务" class="headerlink" title="2、事务"></a>2、事务</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>数据库中的事务是指对数据库执行一批操作，在同一个事务当中，这些操作最终要么全部执行成功，要么全部失败，不会存在部分成功的情况。</p>
<p>事务是一个原子操作。是一个最小执行单元。可以甶一个或多个SQL语句组成在同一个事务当中，所有的SQL语句都成功执行时，整 个事务成功，有一个SQL语句执行失败，整个事务都执行失败。</p>
<p><strong>事务的几个特性(ACID)</strong></p>
<p><strong>原子性(Atomicity)</strong></p>
<p>事务的整个过程如原子操作一样，最终要么全部成功，或者全部失败，这个原子性是从最终结果来看的，从最终结果来看这个过程是不可分割的。</p>
<p><strong>一致性(Consistency)</strong></p>
<p>一个事务必须使数据库从一个一致性状态变换到另一个一致性状态。</p>
<p>所谓一致性，指的是数据处于一种有意义的状态，这种状态是语义上的而不是语法上的。例如从帐户A转一笔钱到帐户B上，如果帐户A上的钱减少了，而帐户B上的钱却没有增加，那么我们认为此时数据处于不一致的状态。</p>
<p>从这段话的理解来看，所谓一致性，即，从实际的业务逻辑上来说，最终结果是对的、是跟程序员的所期望的结果完全符合的。</p>
<p><strong>隔离性(Isolation)</strong></p>
<p>一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>事务的隔离级别：</p>
<ul>
<li>读未提交：read uncommitted</li>
<li>读已提交：read committed</li>
<li>可重复读：repeatable read</li>
<li>串行化：serializable</li>
</ul>
<p><strong>持久性(Durability)</strong></p>
<p>一个事务一旦提交，他对数据库中数据的改变就应该是永久性的。当事务提交之后，数据会持久化到硬盘，修改是永久性的。</p>
<h3 id="Mysql中事务操作"><a href="#Mysql中事务操作" class="headerlink" title="Mysql中事务操作"></a>Mysql中事务操作</h3><p>事务分为隐式事务和显式事务。</p>
<p>mysql中事务默认是隐式事务，执行insert、update、delete操作的时候，数据库自动开启事务、提交或回滚事务。</p>
<p>是否开启隐式事务是由变量autocommit控制的。</p>
<p><strong>隐式事务</strong></p>
<p>事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由mysql内部自动控制的。</p>
<p>查看变量autocommit是否开启了自动提交</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;autocommit&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> autocommit   <span class="operator">|</span> <span class="keyword">ON</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>autocommit为ON表示开启了自动提交。</p>
<p><strong>显式事务</strong></p>
<p>事务需要手动开启、提交或回滚，由开发者自己控制。</p>
<p>2种方式手动控制事务：</p>
<p><strong>方式1</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>设置不自动提交事务</span><br><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>执行事务操作</span><br><span class="line"><span class="keyword">commit</span><span class="operator">|</span><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure>

<p><strong>方式2</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;<span class="operator">/</span><span class="operator">/</span>开启事务</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>执行事务操作</span><br><span class="line"><span class="keyword">commit</span><span class="operator">|</span><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure>

<p><code>savepoint</code>关键字可以用来分割事务</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">savepoint</span> part1;<span class="operator">/</span><span class="operator">/</span>设置一个保存点</span><br><span class="line">....</span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> part1;<span class="operator">/</span><span class="operator">/</span>将savepint <span class="operator">=</span> part1的语句到当前语句之间所有的操作回滚</span><br><span class="line">....</span><br><span class="line"><span class="keyword">commit</span>;<span class="operator">/</span><span class="operator">/</span>提交事务</span><br></pre></td></tr></table></figure>

<p><strong>只读事务</strong></p>
<p>表示在事务中执行的是一些只读操作，如查询，但是不会做insert、update、delete操作，数据库内部对只读事务可能会有一些性能上的优化。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction read <span class="keyword">only</span>;</span><br></pre></td></tr></table></figure>

<p>开启只读事务的话，增删改会报错。</p>
<h3 id="事务存在的问题"><a href="#事务存在的问题" class="headerlink" title="事务存在的问题"></a>事务存在的问题</h3><p>这些问题主要是基于数据在多个事务中的可见性来说的。也是<strong>并发事务</strong>产生的问题。</p>
<p><strong>更新丢失</strong><br>丢失更新就是两个不同的事务（线程）在某一时刻对同一数据进行读取后，先后进行修改。导致第一次操作数据丢失。</p>
<p>第一类丢失更新 ：A，B 事务同时操作同一数据，A先对改数据进行了更改，B再次更改时失败然后回滚，把A更新的数据也回滚了。（事务撤销造成的撤销丢失）</p>
<p>第二类丢失更新：A，B 事务同时操作同一数据，A先对改数据进行了更改，B再次更改并且提交，把A提交的数据给覆盖了。（事务提交造成的覆盖丢失）</p>
<p><strong>脏读</strong><br>一个事务在执行的过程中读取到了其他事务还没有提交的数据。</p>
<p>两个事务同时操作同一数据，A事务对该数据进行了修改还没提交的时候，B事务访问了该条事务，并且使用了该数据，此时A事务回滚，那么B事务读到的就是脏数据。</p>
<p>比如事务1，修改了某个数据 事务2，刚好访问了事务1修改后的数据</p>
<p>此时事务1，回滚了操作 事务2，读到还是回滚前的数据</p>
<p><strong>读已提交</strong><br>一个事务操作过程中可以读取到其他事务已经提交的数据。事务中的每次读取操作，读取到的都是数据库中其他事务已提交的最新的数据（相当于当前读）。</p>
<p><strong>不可重复读</strong></p>
<p>在同一事务中，多次读取同一数据返回的结果不同（后续读取可以读到另一事务已提交的更新数据）。</p>
<p>相反，“可重复读” 在同一事务中多次读取数据时, 能够保证所读数据一样, 也就是后续读取不能读到另一事务已提交的更新数据。</p>
<p>这种情况发生 在一个事务内多次读同一数据。A事务查询某条数据，该事务未结束时，B事务也访问同一数据并进行了修改。那么在A事务中的两 次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。</p>
<p><strong>可重复读</strong></p>
<p>一个事务操作中对于一个读取操作不管多少次，读取到的结果都是一样的。</p>
<p><strong>幻读</strong></p>
<p>脏读、不可重复读、可重复读、幻读，其中最难理解的是幻读</p>
<p>幻读现象例子：</p>
<p>可重复读模式下，比如有个用户表，手机号码为主键，有两个事物进行如下操作</p>
<ul>
<li>事务A操作如下：<ol>
<li>打开事务 </li>
<li>查询号码为X的记录，不存在 </li>
<li>插入号码为X的数据，插入报错（为什么会报错，先向下看）</li>
<li>查询号码为X的记录，发现还是不存在（由于是可重复读，所以读取记录X还是不存在的）</li>
</ol>
</li>
<li>事物B操作：在事务A第2步操作时插入了一条X的记录，所以会导致A中第3步插入报错（违反了唯一约束）<br>上面操作对A来说就像发生了幻觉一样，明明查询X（A中第二步、第四步）不存在，但却无法插入成功</li>
</ul>
<p>幻读可以这么理解：事务中后面的操作（插入号码X）需要上面的读取操作（查询号码X的记录）提供支持，但读取操作却不能支持下面的操作时产生的错误，就像发生了幻觉一样。</p>
<p>看第二种解释：</p>
<p>事务A在操作一堆数据的时候，事务B插入了一条数据，A事务再次（第二次）查询，发现多了一条数据，像是幻觉。与不可重复读类似，不同的是一个是修改删除操作，一个是新增操作。</p>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p><strong>用来保证并发情况下前事务中数据的正确性</strong>。</p>
<p>事务隔离级别主要是解决了上面多个事务之间数据可见性及数据正确性的问题。</p>
<p><strong>隔离级别</strong>：</p>
<ol>
<li>读未提交：READ-UNCOMMITTED</li>
<li>读已提交：READ-COMMITTED</li>
<li>可重复读：REPEATABLE-READ</li>
<li>串行化：SERIALIZABLE</li>
</ol>
<blockquote>
<p> 隔离级别越来越强，会数据库的并发性也越来越低。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看隔离级别</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改隔离级别 修改mysql中的my.init文件</span></span><br><span class="line"># 隔离级别设置,READ<span class="operator">-</span>UNCOMMITTED读未提交,READ<span class="operator">-</span>COMMITTED读已提交,REPEATABLE<span class="operator">-</span>READ可重复读,SERIALIZABLE串行</span><br><span class="line">transaction<span class="operator">-</span>isolation<span class="operator">=</span>READ<span class="operator">-</span>UNCOMMITTED</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读可能性</th>
<th>不可重复读可能性</th>
<th>幻读可能性</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>有</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>无</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>无</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
</tbody></table>
<p>SERIALIZABLE会让并发的事务串行执行（多个事务之间读写、写读、写写会产生互斥，效果就是串行执行，多个事务之间的读读不会产生互斥）。</p>
<p>读写互斥：事务A中先读取操作，事务B发起写入操作，事务A中的读取会导致事务B中的写入处于等待状态，直到A事务完成为止。</p>
<p>表示我开启一个事务，为了保证事务中不会出现上面说的问题（脏读、不可重复读、读已提交、幻读），那么我读取的时候，其他事务有修改数据的操作需要排队等待，等待我读取完成之后，他们才可以继续。</p>
<p>写读、写写也是互斥的，读写互斥类似。</p>
<p><strong>小结</strong><br><strong>读未提交</strong>( Read Uncommitted )</p>
<ul>
<li>读未提交是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。</li>
</ul>
<p><strong>读已提交</strong>( Read Committed )</p>
<ul>
<li>在 Read Committed 隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。</li>
</ul>
<p><strong>可重复读</strong>( Repeatable Read )</p>
<ul>
<li>在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。</li>
</ul>
<p><strong>可串行化</strong>( Serializable )</p>
<ul>
<li>Serializable 是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。</li>
<li>虽然 Serializable 隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。</li>
</ul>
<p>默认隔离级别：如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用 InnoDB，默认的隔离级别是Repeatable Read。</p>
<p><strong>结合具体的业务来选择</strong></p>
<h3 id="事务的分类"><a href="#事务的分类" class="headerlink" title="事务的分类"></a>事务的分类</h3><p><strong>扁平事务</strong></p>
<ul>
<li><p>扁平事务是事务类型中最简单的一种，但在实际生产环境中，这可能是使用最为频繁的事务</p>
</li>
<li><p>在扁平事务中，所有操作都处于同一层次，其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束，其间的操作是原子的，要么都执行，要么都回滚。因此扁平事务是应用程序成为原子操作的基本组成模块</p>
</li>
<li><p>下图显示了扁平事务的三种不同结果：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/mysql45%E8%AE%B2%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXNpbmdfX0RyZWFtcw==,size_16,color_FFFFFF,t_70#pic_center.png" alt="在这里插入图片描述"></p>
</li>
<li><p>图中给出了扁平事务的三种情况，同时也给出了在一个典型的事务处理应用中，每个结果大概占用的百分比。再次提醒，扁平事务虽然简单，但在实际生产环境中使用最为频繁。正因为其简单，使用频繁，故每个数据库系统都实现了对扁平事务的支持</p>
</li>
<li><p>扁平事务的主要限制是不能提交或者回滚事务的某一部分，或分几个步骤提交</p>
</li>
</ul>
<p><strong>带有保存点的扁平事务</strong></p>
<ul>
<li>带有保存点的扁平事务，除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态。这是因为某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销也太大</li>
</ul>
<p><strong>链事务</strong></p>
<ul>
<li>链事务可视为保存点模式的一种变种</li>
<li>带有保存点的扁平事务，当发生系统崩溃时，所有的保存点都将消失，因为其保存点是易失的（volatile），而非持久的( persistent)。这意味着当进行恢复时，事务需要从开始处重新执行，而不能从最近的一个保存点继续执行</li>
<li>链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务</li>
<li>注意，提交事务操作和开始下一个事务操作将合并为一个原子操作。这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行的一样。下图显示了链事务的工作方式：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/mysql45%E8%AE%B2%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXNpbmdfX0RyZWFtcw==,size_16,color_FFFFFF,t_70#pic_center-16765499041825.png" alt="在这里插入图片描述"></p>
<ul>
<li>链事务与带有保存点的扁平事务不同的是：<ul>
<li>带有保存点的扁平事务<strong>能回滚到任意正确的保存点</strong></li>
<li>而链事务中的回滚<strong>仅限于当前事务，即只能恢复到最近一个的保存点</strong></li>
<li>对于锁的处理，两者也不相同：<ul>
<li>链事务在执行COMMIT后即释放了当前事务所持有的锁</li>
<li>而带有保存点的扁平事务不影响迄今为止所持有的锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>嵌套事务</strong></p>
<ul>
<li>嵌套事务是一个层次结构框架。由一个顶层事务控制着各个层次的事务。顶层事务之下嵌套的事务被称为子事务（subtransaction），其控制每一个局部的变换</li>
<li>嵌套事务的层次结构如图所示：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/mysql45%E8%AE%B2%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXNpbmdfX0RyZWFtcw==,size_16,color_FFFFFF,t_70#pic_center-16765499945177.png" alt="在这里插入图片描述"></p>
<p> <strong>布式事务</strong></p>
<ul>
<li>分布式事务通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点</li>
</ul>
<h3 id="并发事务的控制方式有哪些？"><a href="#并发事务的控制方式有哪些？" class="headerlink" title="并发事务的控制方式有哪些？"></a>并发事务的控制方式有哪些？</h3><blockquote>
<p>MySQL 中并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>MVCC</strong>。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。</p>
</blockquote>
<p><strong>锁</strong> 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过 <strong>读写锁</strong> 来实现并发控制。</p>
<ul>
<li><strong>共享锁（S 锁）</strong> ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>
<li><strong>排他锁（X 锁）</strong> ：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li>
</ul>
<p>读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 <strong>表级锁(table-level locking)</strong> 和 <strong>行级锁(row-level locking)</strong> 。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。</p>
<p><strong>MVCC</strong> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p>
<p>MVCC 在 MySQL 中实现所依赖的手段主要是: <strong>隐藏字段、read view、undo log</strong>。</p>
<ul>
<li>undo log : undo log 用于记录某行数据的多个版本的数据。</li>
<li>read view 和 隐藏字段 : 用来判断当前版本数据的可见性。</li>
</ul>
<p>关于 InnoDB 对 MVCC 的具体实现可以看这篇文章：<a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html">InnoDB 存储引擎对 MVCC 的实现open in new window</a> </p>
<h2 id="3、锁机制"><a href="#3、锁机制" class="headerlink" title="3、锁机制"></a>3、锁机制</h2><p><strong>如何理解锁？</strong></p>
<p>锁是计算机用以协调多个进程间并发访问同一共享资源的一种机制。</p>
<p>MySQL中为了保证数据访问的一致性与有效性等功能，实现了锁机制，MySQL中的锁是在服务器层或者存储引擎层实现的。</p>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p>主要分为：</p>
<ul>
<li><strong>行锁</strong></li>
<li><strong>表锁</strong></li>
</ul>
<p>各引擎对锁的支持情况如下：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">行锁</th>
<th align="left">表锁</th>
<th align="left">页锁</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MyISAM</td>
<td align="left"></td>
<td align="left">√</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">BDB</td>
<td align="left"></td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
<tr>
<td align="left">InnoDB</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>行锁是作用在索引上的，即使建表时没有定义一个索引，InnoDB也会创建一个聚簇索引并将其作为锁作用的索引。</p>
<p>图示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/1620.png" alt="img"></p>
<p>InnoDB对于单行数据的加锁原理：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">49</span>;</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">10</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Tom&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>第一条SQL使用主键查询，只需要在 id &#x3D; 49 这个主键索引上加上锁。第二条 SQL 使用二级索引来查询，那么首先在 name &#x3D; Tom 这个索引上加写锁，然后由于使用 InnoDB 二级索引还需再次根据主键索引查询，所以还需要在 id &#x3D; 49 这个主键索引上加锁。</p>
<p>也就是说使用主键索引需要加一把锁，使用二级索引需要在二级索引和主键索引上各加一把锁。</p>
<p>根据索引对单行数据进行更新的加锁原理了解了，那如果更新操作涉及多个行呢，比如下面 SQL 的执行场景。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">49</span>;</span><br></pre></td></tr></table></figure>

<p>上述 SQL 的执行过程如下图所示。MySQL Server 会根据 WHERE 条件读取第一条满足条件的记录，然后 InnoDB 引擎会将第一条记录返回并加锁，接着 MySQL Server 发起更新改行记录的 UPDATE 请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有匹配的记录为止。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/1620-16766047752102.png" alt="img"></p>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>因为行锁是需要索引来支撑的，所以对于没有索引的行，直接进行表锁。</p>
<p>表锁使用的是一次性锁技术，也就是说，在会话开始的地方使用 lock 命令将后续需要用到的表都加上锁，在表释放前，只能访问这些加锁的表，不能访问其他表，直到最后通过 unlock tables 释放所有表锁。</p>
<p>除了使用 unlock tables 显示释放锁之外，会话持有其他表锁时执行lock table 语句会释放会话之前持有的锁；会话持有其他表锁时执行 start transaction 或者 begin 开启事务时，也会释放之前持有的锁。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/1620-16766053727754.png" alt="img"></p>
<p>表锁由 MySQL Server 实现，行锁则是存储引擎实现，不同的引擎实现的不同。在 MySQL 的常用引擎中 InnoDB 支持行锁，而 MyISAM 则只能使用 MySQL Server 提供的表锁。</p>
<h4 id="两者锁的比较"><a href="#两者锁的比较" class="headerlink" title="两者锁的比较"></a>两者锁的比较</h4><p>表锁：加锁过程的开销小，加锁的速度快；不会出现死锁的情况；锁定的粒度大，发生锁冲突的几率大，并发度低；</p>
<ul>
<li>一般在执行DDL语句时会对整个表进行加锁，比如说 ALTER TABLE 等操作； </li>
<li>如果对InnoDB的表使用行锁，被锁定字段不是主键，也没有针对它建立索引的话，那么将会锁整张表； </li>
<li>表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用。</li>
</ul>
<p>行锁：加锁过程的开销大，加锁的速度慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；</p>
<ul>
<li>最大程度的支持并发，同时也带来了最大的锁开销。</li>
<li>在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。</li>
<li>行级锁只在存储引擎层实现，而 MySQL 服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</li>
</ul>
<h3 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a>MyISAM表锁</h3><p><strong>MyISAM表级锁模式</strong></p>
<ul>
<li>表共享读锁（Table Read Lock）：不会阻塞其他线程对同一个表的读操作请求，但会阻塞其他线程的写操作请求； </li>
<li>表独占写锁（Table Write Lock）：一旦表被加上独占写锁，那么无论其他线程是读操作还是写操作，都会被阻塞；</li>
</ul>
<p>默认情况下，写锁比读锁具有更高的优先级；当一个锁释放后，那么它会优先相应写锁等待队列中的锁请求，然后再是读锁中等待的获取锁的请求。</p>
<blockquote>
<p>这种设定也是MyISAM表不适合于有大量更新操作和查询操作的原因。大量更新操作可能会造成查询操作很难以获取读锁，从而过长的阻塞。同时一些需要长时间运行的查询操作，也会使得线程<code>饿死</code>，应用中应尽量避免出现长时间运行的查询操作（在可能的情况下可以通过使用中间表等措施对SQL语句做一定的分解，使每一步查询都能在较短的时间内完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行。）</p>
</blockquote>
<p>可以通过一些设置来调节MyISAM的调度行为：</p>
<ul>
<li>通过指定启动参数<code>low-priority-updates</code>，使MyISAM引擎默认给予读请求以优先的权利；</li>
<li>通过执行命令<code>SET LOW_PRIORITY_UPDATES=1</code>，使该连接发出的更新请求优先级降低；</li>
<li>通过指定INSERT、UPDATE、DELETE语句的<code>LOW_PRIORITY</code>属性，降低该语句的优先级；</li>
<li>给系统参数<code>max_write_lock_count</code>设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。</li>
</ul>
<p><strong>MyISAM对表加锁分析</strong></p>
<p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，这也正是 <strong>MyISAM 表不会出现死锁</strong>（Deadlock Free）的原因。</p>
<p>MyISAM存储引擎支持并发插入，以减少给定表的读操作和写操作之间的争用：</p>
<p>如果MyISAM表在数据文件中没有空闲块（由于删除或更新导致的空行），则行始终插入数据文件的末尾。在这种情况下，你可以自由混合并发使用MyISAM表的 INSERT 和 SELECT 语句而不需要加锁（你可以在其他线程进行读操作的情况下，同时将行插入到MyISAM表中）。如果文件中有空闲块，则并发插入会被禁止，但当所有的空闲块重新填充有新数据时，它又会自动启用。 要控制此行为，可以使用MySQL的concurrent_insert系统变量。</p>
<ul>
<li>当concurrent_insert&#x3D;0时，不允许并发插入功能。 </li>
<li>当concurrent_insert&#x3D;1时，允许对没有空闲块的表使用并发插入，新数据位于数据文件结尾（缺省）。 </li>
<li>当concurrent_insert&#x3D;2时，不管表有没有空想快，都允许在数据文件结尾并发插入。</li>
</ul>
<p><strong>显式加表锁的应用</strong></p>
<p>表锁的加锁方式，一般表锁都是隐式加锁的，不需要我们去主动声明，但是也有需要显式加锁的情况：</p>
<p>给MyISAM表显式加锁，一般是为了一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。例如，有一个订单表orders，其中记录有订单的总金额total，同时还有一个订单明细表 order_detail，其中记录有订单每一产品的金额小计 subtotal，假设我们需要检查这两个表的金额合计是否相等，可能就需要执行如下两条SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(total) <span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(subtotal) <span class="keyword">FROM</span> order_detail;</span><br></pre></td></tr></table></figure>

<p>这时，如果不先给这两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail表可能已经发生了改变。因此，正确的方法应该是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOCK tables orders read <span class="keyword">local</span>,order_detail read <span class="keyword">local</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(total) <span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(subtotal) <span class="keyword">FROM</span> order_detail;</span><br><span class="line">Unlock tables;</span><br></pre></td></tr></table></figure>

<p><strong>查看表锁争用情况</strong></p>
<p>可以通过检查 table_locks_waited 和 table_locks_immediate 状态变量来分析系统上的表锁的争夺，如果 Table_locks_waited 的值比较高，则说明存在着较严重的表级锁争用情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Table%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> Table_locks_immediate <span class="operator">|</span> <span class="number">1151552</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Table_locks_waited <span class="operator">|</span> <span class="number">15324</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+---------+</span></span><br></pre></td></tr></table></figure>

<h3 id="InnoDB行锁与表锁"><a href="#InnoDB行锁与表锁" class="headerlink" title="InnoDB行锁与表锁"></a>InnoDB行锁与表锁</h3><p><strong>InnoDB锁模式</strong></p>
<p>1）InnoDB中的行锁</p>
<p>InnoDB实现了以下两种类型的行锁：</p>
<ul>
<li><strong>共享锁</strong>（S）：加了锁的记录，所有事务都能去读取但不能修改，同时阻止其他事务获得相同数据集的排他锁；</li>
<li><strong>排他锁</strong>（X）：允许已经获得排他锁的事务去更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁；</li>
</ul>
<p>2）InnoDB表锁——<strong>意向锁</strong></p>
<p>由于表锁和行锁虽然锁定范围不同，但是会相互冲突。当要加表锁时，要先遍历该表的所有记录，判断是否有排他锁。这种遍历检查的方式显然是一种低效的方式，MySQL引入了意向锁，来检测表锁和行锁的冲突。</p>
<p>意向锁也是表级锁，分为<strong>读意向锁</strong>（IS锁）和<strong>写意向锁</strong>（IX锁）。当事务要在记录上加上行锁时，要首先在表上加上意向锁。这样判断表中是否有记录正在加锁就很简单了，只要看下表上是否有意向锁就行了，从而就能提高效率。</p>
<p>意向锁之间是不会产生冲突的，它只会阻塞表级读锁或写锁。意向锁不于行级锁发生冲突。</p>
<p><strong>锁模式的兼容矩阵</strong></p>
<p>下面表显示了了各种锁之间的兼容情况：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">X</th>
<th align="left">IX</th>
<th align="left">S</th>
<th align="left">IS</th>
</tr>
</thead>
<tbody><tr>
<td align="left">X</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">IX</td>
<td align="left"></td>
<td align="left">兼容</td>
<td align="left"></td>
<td align="left">兼容</td>
</tr>
<tr>
<td align="left">S</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">兼容</td>
<td align="left">兼容</td>
</tr>
<tr>
<td align="left">IS</td>
<td align="left"></td>
<td align="left">兼容</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
</tr>
</tbody></table>
<p>（注意上面的X与S是说表级的X锁和S锁，意向锁不和行级锁发生冲突）</p>
<p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；如果两者不兼容，那么该事务就需要等待锁的释放。</p>
<p><strong>select for update</strong></p>
<p>在执行这个 select 查询语句的时候，会将对应的索引访问条目加上排他锁（X锁），也就是说这个语句对应的锁就相当于update带来的效果；</p>
<p><strong>使用场景</strong>：为了让确保自己查找到的数据一定是最新数据，并且查找到后的数据值允许自己来修改，此时就需要用到select for update语句；</p>
<p><strong>性能分析</strong>：select for update语句相当于一个update语句。在业务繁忙的情况下，如果事务没有及时地commit或者rollback可能会造成事务长时间的等待，从而影响数据库的并发使用效率。</p>
<p><strong>select lock in share mode</strong></p>
<p>in share mode 子句的作用就是将查找的数据加上一个share锁，这个就是表示其他的事务只能对这些数据进行简单的 select 操作，而不能进行 DML 操作。</p>
<p><strong>使用场景</strong>：为了确保自己查询的数据不会被其他事务正在修改，也就是确保自己查询到的数据是最新的数据，并且不允许其他事务来修改数据。与select for update不同的是，本事务在查找完之后不一定能去更新数据，因为有可能其他事务也对同数据集使用了 in share mode 的方式加上了S锁；</p>
<p><strong>性能分析</strong>：select lock in share mode 语句是一个给查找的数据上一个共享锁（S 锁）的功能，它允许其他的事务也对该数据上S锁，但是不能够允许对该数据进行修改。如果不及时的commit 或者rollback 也可能会造成大量的事务等待。</p>
<p><strong>InnoDB的锁争用情况</strong></p>
<p>可以通过检查 InnoDB_row_lock 状态变量来分析系统上的行锁的争夺情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like <span class="string">&#x27;innodb_row_lock%&#x27;</span>; </span><br><span class="line">+-------------------------------+-------+ </span><br><span class="line">| <span class="title class_">Variable</span>_name | <span class="title class_">Value</span> | </span><br><span class="line">+-------------------------------+-------+ </span><br><span class="line">| <span class="title class_">InnoDB</span>_row_lock_current_waits | <span class="number">0</span> | </span><br><span class="line">| <span class="title class_">InnoDB</span>_row_lock_time | <span class="number">0</span> | </span><br><span class="line">| <span class="title class_">InnoDB</span>_row_lock_time_avg | <span class="number">0</span> | </span><br><span class="line">| <span class="title class_">InnoDB</span>_row_lock_time_max | <span class="number">0</span> | </span><br><span class="line">| <span class="title class_">InnoDB</span>_row_lock_waits | <span class="number">0</span> | </span><br><span class="line">+-------------------------------+-------+ </span><br><span class="line"><span class="number">5</span> rows <span class="keyword">in</span> set (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="行锁的类型"><a href="#行锁的类型" class="headerlink" title="行锁的类型"></a>行锁的类型</h3><p>根据了锁的粒度将锁分为了行锁与表锁，接下来根据使用场景的不同，又可以将行锁进行进一步的划分：Next-Key Lock、Gap Lock、Record Lock以及插入意向GAP锁。</p>
<p>不同的锁锁定的位置是不同的，比如说记录锁只锁定对应的记录，而间隙锁锁住记录和记录之间的间隙，Next-key Lock则锁住所属记录之间的间隙。不同的锁类型锁定的范围大致如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/1620-16766067921166.png" alt="img"></p>
<p><strong>记录锁（Record Lock）</strong></p>
<p>记录锁最简单的一种行锁形式,行锁是加在索引上的，如果当你的查询语句不走索引的话，那么它就会升级到表锁，最终造成效率低下，所以在写SQL语句时需要特别注意。</p>
<p><strong>间隙锁（Gap Lock）</strong></p>
<p>当我们使用范围条件而不是相等条件去检索，并请求锁时，InnoDB就会给符合条件的记录的索引项加上锁；而对于键值在条件范围内但并不存在（参考上面所说的空闲块）的记录，就叫做间隙，InnoDB在此时也会对间隙加锁，这种记录锁+间隙锁的机制叫Next-Key Lock。</p>
<p>从上面这句话可以表明间隙锁是所在两个存在的索引之间，是一个开区间，像最开始的那张索引图，15和18之间，是有（16，17）这个间隙存在的。</p>
<p>间隙锁是可以共存的，共享间隙锁与独占间隙锁之间是没有区别的，两者之间并不冲突。其存在的目的都是防止其他事务往间隙中插入新的纪录，故而一个事务所采取的间隙锁是不会去阻止另外一个事务在同一个间隙中加锁的。</p>
<p>当然也不是在什么时候都会去加间隙锁的：</p>
<p>在 RU 和 RC 两种隔离级别下，即使你使用 select in share mode 或 select for update，也无法防止<strong>幻读</strong>（读后写的场景）。因为这两种隔离级别下只会有<strong>行锁</strong>，而不会有<strong>间隙锁</strong>。而如果是 RR 隔离级别的话，就会在间隙上加上间隙锁。</p>
<p><strong>临键锁（Next-key Lock）</strong></p>
<p>临键锁是记录锁与与间隙锁的结合，所以临键锁与间隙锁是一个同时存在的概念，并且临键锁是个左开右闭的区间比如(16, 18]。</p>
<p>关于临键锁与幻读，MySQL 默认隔离级别是RR，在这种级别下，如果你使用 select in share mode 或者 select for update 语句，那么InnoDB会使用临键锁（记录锁 + 间隙锁），因而可以防止幻读；</p>
<p>但是我也在网上看到相关描述：即使你的隔离级别是 RR，如果你这是使用普通的select语句，那么此时 InnoDB 引擎将是使用快照读，而不会使用任何锁，因而还是无法防止幻读。</p>
<p><strong>插入意向锁（Insert Intention Lock）</strong></p>
<p>插入意图锁是一种间隙锁，在行执行 INSERT 之前的插入操作设置。如果多个事务 INSERT 到同一个索引间隙之间，但没有在同一位置上插入，则不会产生任何的冲突。假设有值为4和7的索引记录，现在有两事务分别尝试插入值为 5 和 6 的记录，在获得插入行的排他锁之前，都使用插入意向锁锁住 4 和 7 之间的间隙，但两者之间并不会相互阻塞，因为这两行并不冲突。</p>
<p>插入意向锁只会和 间隙或者 Next-key 锁冲突，正如上面所说，间隙锁作用就是防止其他事务插入记录造成幻读，正是由于在执行 INSERT 语句时需要加插入意向锁，而插入意向锁和间隙锁冲突，从而阻止了插入操作的执行。</p>
<p><strong>不同类型锁之间的兼容</strong></p>
<p>不同类型的锁之间的兼容如下表所示：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">RECORED</th>
<th align="left">GAP</th>
<th align="left">NEXT-KEY</th>
<th align="left">II GAP（插入意向锁）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">RECORED</td>
<td align="left"></td>
<td align="left">兼容</td>
<td align="left"></td>
<td align="left">兼容</td>
</tr>
<tr>
<td align="left">GAP</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
</tr>
<tr>
<td align="left">NEXT-KEY</td>
<td align="left"></td>
<td align="left">兼容</td>
<td align="left"></td>
<td align="left">兼容</td>
</tr>
<tr>
<td align="left">II GAP</td>
<td align="left">兼容</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">兼容</td>
</tr>
</tbody></table>
<p>（其中行表示已有的锁，列表示意图加上的锁）</p>
<p>其中，第一行表示已有的锁，第一列表示要加的锁。插入意向锁较为特殊：</p>
<ul>
<li>插入意向锁不影响其他事务加其他任何锁。也就是说，一个事务已经获取了插入意向锁，对其他事务是没有任何影响的；</li>
<li>插入意向锁与间隙锁和 Next-key 锁冲突。也就是说，一个事务想要获取插入意向锁，如果有其他事务已经加了间隙锁或 Next-key 锁，则会阻塞。</li>
</ul>
<p>其他类型的锁的规则较为简单：</p>
<ul>
<li>间隙锁不和其他锁（不包括插入意向锁）冲突；</li>
<li>记录锁和记录锁冲突，Next-key 锁和 Next-key 锁冲突，记录锁和 Next-key 锁冲突；</li>
</ul>
<h2 id="4、日志"><a href="#4、日志" class="headerlink" title="4、日志"></a>4、日志</h2><p>MySQL的日志记录了MySQL的日常操作和错误信息，通过这些日志我们可以知道MySQL内部发生的事情，可以为MySQL的优化和管理提供必要的信息。</p>
<p>日志的分类：</p>
<ol>
<li>重做日志（redo log）</li>
<li>回滚日志（undo log）</li>
<li>二进制日志（binlog）</li>
<li>错误日志（errorlog）</li>
<li>慢查询日志（slow query log）</li>
<li>一般查询日志（general log）</li>
<li>中继日志（relay log）</li>
</ol>
<h3 id="重做日志（redo-log）"><a href="#重做日志（redo-log）" class="headerlink" title="重做日志（redo log）"></a>重做日志（redo log）</h3><p><strong>作用：</strong></p>
<p>　　确保事务的持久性。redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</p>
<p><strong>内容：</strong></p>
<p>　　物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。</p>
<p><strong>什么时候产生：</strong></p>
<p>　　事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。</p>
<p><strong>什么时候释放：</strong></p>
<p>　　当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</p>
<p><strong>对应的物理文件：</strong></p>
<p>　　默认情况下，对应的物理文件位于数据库</p>
<p>　　innodb_log_group_home_dir 指定日志文件组所在的路径，默认.&#x2F; ，表示在数据库的数据目录下。</p>
<p>　　innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2</p>
<p><strong>关于文件的大小和数量，由以下两个参数配置：</strong></p>
<p>　　innodb_log_file_size 重做日志文件的大小。</p>
<p>　　innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1</p>
<p><strong>其他：</strong></p>
<p>　　很重要一点，redo log是什么时候写盘的？前面说了是在事物开始之后逐步写盘的。</p>
<p>　　之所以说重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存，原因就是，重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中。</p>
<p>然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘</p>
<ol>
<li>Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。</li>
<li>每个事务提交时会将重做日志刷新到重做日志文件。</li>
<li>当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件</li>
</ol>
<p>　　由此可以看出，重做日志通过不止一种方式写入到磁盘，尤其是对于第一种方式，Innodb_log_buffer到重做日志文件是Master Thread线程的定时任务。</p>
<p>　　因此重做日志的写盘，并不一定是随着事务的提交才写入重做日志文件的，而是随着事务的开始，逐步开始的。</p>
<p>另外引用《MySQL技术内幕 Innodb 存储引擎》（page37）上的原话：</p>
<blockquote>
<p>即使某个事务还没有提交，Innodb存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。</p>
</blockquote>
<p>　　这一点是必须要知道的，因为这可以很好地解释再大的事务的提交（commit）的时间也是很短暂的。</p>
<h3 id="回滚日志（undo-log）"><a href="#回滚日志（undo-log）" class="headerlink" title="回滚日志（undo log）"></a>回滚日志（undo log）</h3><p><strong>作用：</strong></p>
<p>　　保证数据的原子性，保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</p>
<p><strong>内容：</strong></p>
<p>　　逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。</p>
<p><strong>什么时候产生：</strong></p>
<p>　　事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性</p>
<p><strong>什么时候释放：</strong></p>
<p>　　当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。</p>
<p><strong>对应的物理文件：</strong></p>
<p>　　MySQL5.6之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata，位于数据文件目录中。</p>
<p>　　MySQL5.6之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数</p>
<p>　　如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。</p>
<p><strong>关于MySQL5.7之后的独立undo 表空间配置参数如下：</strong></p>
<p>　　innodb_undo_directory &#x3D; &#x2F;data&#x2F;undospace&#x2F; –undo独立表空间的存放目录 innodb_undo_logs &#x3D; 128 –回滚段为128KB innodb_undo_tablespaces &#x3D; 4 –指定有4个undo log文件</p>
<p>　　如果undo使用的共享表空间，这个共享表空间中又不仅仅是存储了undo的信息，共享表空间的默认为与MySQL的数据目录下面，其属性由参数innodb_data_file_path配置。</p>
<p><strong>其他：</strong></p>
<p>　　undo是在事务开始之前保存的被修改数据的一个版本，产生undo日志的时候，同样会伴随类似于保护事务持久化机制的redolog的产生。</p>
<p>　　默认情况下undo文件是保持在共享表空间的，也即ibdatafile文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的undo信息，全部保存在共享表空间中的。</p>
<p>　　因此共享表空间可能会变的很大，默认情况下，也就是undo 日志使用共享表空间的时候，被“撑大”的共享表空间是不会也不能自动收缩的。</p>
<p>　　因此，mysql5.7之后的“独立undo 表空间”的配置就显得很有必要了。</p>
<h3 id="二进制日志（binlog）"><a href="#二进制日志（binlog）" class="headerlink" title="二进制日志（binlog）"></a>二进制日志（binlog）</h3><p><strong>作用：</strong></p>
<p>　　用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。</p>
<p>　　用于数据库的基于时间点的还原。</p>
<p><strong>内容：</strong></p>
<p>　　逻辑格式的日志，可以简单认为就是执行过的事务中的sql语句。</p>
<p>　　但又不完全是sql语句这么简单，而是包括了执行的sql语句（增删改）反向的信息，也就意味着delete对应着delete本身和其反向的insert；update对应着update执行前后的版本的信息；insert对应着delete和insert本身的信息。</p>
<p>　　在使用mysqlbinlog解析binlog之后一些都会真相大白。</p>
<p>　　因此可以基于binlog做到类似于oracle的闪回功能，其实都是依赖于binlog中的日志记录。</p>
<p><strong>什么时候产生：</strong></p>
<p>　　事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。</p>
<p>　　这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘，redo log是在事务开始之后就开始逐步写入磁盘。</p>
<p>　　因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了bin_log的情况下，对于较大事务的提交，可能会变得比较慢一些。</p>
<p>　　这是因为binlog是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。</p>
<p><strong>什么时候释放：</strong></p>
<p>　　binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。</p>
<p><strong>对应的物理文件：</strong></p>
<p>　　配置文件的路径为log_bin_basename，binlog日志文件按照指定大小，当日志文件达到指定的最大的大小之后，进行滚动更新，生成新的日志文件。</p>
<p>　　对于每个binlog日志文件，通过一个统一的index文件来组织。</p>
<p><strong>其他：</strong></p>
<p>　　二进制日志的作用之一是还原数据库的，这与redo log很类似，很多人混淆过，但是两者有本质的不同</p>
<p>　　<strong>作用不同</strong>：redo log是保证事务的持久性的，是事务层面的，binlog作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的。</p>
<p>　　<strong>内容不同</strong>：redo log是物理日志，是数据页面的修改之后的物理记录，binlog是逻辑日志，可以简单认为记录的就是sql语句</p>
<p>　　另外，两者日志产生的时间，可以释放的时间，在可释放的情况下清理机制，都是完全不同的。</p>
<p>　　恢复数据时候的效率，基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog</p>
<p>　　关于事务提交时，redo log 和 binlog 的写入顺序，为了保证主从复制时候的主从一致（当然也包括使用 binlog 进行基于时间点还原的情况），是要严格一致的，MySQL通过两阶段提交过程来完成事务的一致性的，也即 redo log 和binlog 的一致性的，理论上是先写 redo log ，再写 binlog ，两个日志都提交成功（刷入磁盘），事务才算真正的完成。</p>
<h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>　　错误日志记录着mysqld启动和停止,以及服务器在运行过程中发生的错误的相关信息。在默认情况下，系统记录错误日志的功能是关闭的，错误信息被输出到标准错误输出。</p>
<p>　　指定日志路径两种方法:</p>
<ul>
<li>编辑my.cnf 写入 log-error&#x3D;[path]</li>
<li>通过命令参数错误日志 mysqld_safe –user&#x3D;mysql –log-error&#x3D;[path] &amp;</li>
</ul>
<p>显示错误日志的命令（如下图所示）</p>
<p>　　<a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/885859/201904/885859-20190418111428261-484993255.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/885859-20190418111428261-484993255.png" alt="img"></a></p>
<h3 id="普通查询日志-general-query-log"><a href="#普通查询日志-general-query-log" class="headerlink" title="普通查询日志 (general query log)"></a>普通查询日志 (general query log)</h3><p>　　记录了服务器接收到的每一个查询或是命令，无论这些查询或是命令是否正确甚至是否包含语法错误，general log 都会将其记录下来 ，记录的格式为 {Time ，Id ，Command，Argument }。也正因为mysql服务器需要不断地记录日志，开启General log会产生不小的系统开销。 因此，Mysql默认是把General log关闭的。</p>
<p>查看日志的存放方式：show variables like ‘log_output’;</p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/885859/201904/885859-20190418111501042-772781517.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/885859-20190418111501042-772781517.png" alt="img"></a></p>
<p>如果设置mysql&gt; set global log_output&#x3D;’table’ 的话，则日志结果会记录到名为gengera_log的表中，这表的默认引擎都是CSV</p>
<p>如果设置表数据到文件set global log_output&#x3D;file;</p>
<p>设置general log的日志文件路径：</p>
<p>set global general_log_file&#x3D;’&#x2F;tmp&#x2F;general.log’;</p>
<ul>
<li>开启general log： set global general_log&#x3D;on;</li>
<li>关闭general log： set global general_log&#x3D;off;</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/885859/201904/885859-20190418111533830-280934584.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/885859-20190418111533830-280934584.png" alt="img"></a></p>
<p>　　然后在用：show global variables like ‘general_log’</p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/885859/201904/885859-20190418111551171-1738333923.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/885859-20190418111551171-1738333923.png" alt="img"></a></p>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>　　慢日志记录执行时间过长和没有使用索引的查询语句，报错select、update、delete以及insert语句，慢日志只会记录执行成功的语句。<br>　　1. 查看慢查询时间：<br>　　show variables like “long_query_time”;默认10s</p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/885859/201904/885859-20190418111638450-1186782386.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/885859-20190418111638450-1186782386.png" alt="img"></a></p>
<p>　　2. 查看慢查询配置情况：<br>　　show status like “%slow_queries%”;</p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/885859/201904/885859-20190418111656450-521011638.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/885859-20190418111656450-521011638.png" alt="img"></a></p>
<p>　　3. 查看慢查询日志路径：<br>　　show variables like “%slow%”;</p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/885859/201904/885859-20190418111712973-766266117.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/885859-20190418111712973-766266117.png" alt="img"></a></p>
<p>　　4. 开启慢日志</p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/885859/201904/885859-20190418111737882-1420825238.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/885859-20190418111737882-1420825238.png" alt="img"></a></p>
<p>　　查看已经开启：</p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/885859/201904/885859-20190418111753391-1884429309.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/885859-20190418111753391-1884429309.png" alt="img"></a></p>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/160d2202b9548ba1471a7b8c2fb1af34.png" alt="img"></p>
<h3 id="细究-redo-log-和-bin-log"><a href="#细究-redo-log-和-bin-log" class="headerlink" title="细究 redo log 和 bin log"></a>细究 redo log 和 bin log</h3><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p>
<p>比如 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的持久性与完整性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/02.png" alt="img"></p>
<p><code>MySQL</code> 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p>
<p>后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p>
<p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p>
<p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/03.png" alt="img"></p>
<blockquote>
<p>图片笔误提示：第 4 步 “清空 redo log buffe 刷盘到 redo 日志中”这句话中的 buffe 应该是 buffer。</p>
</blockquote>
<p>理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。</p>
<blockquote>
<p>小贴士：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p>
</blockquote>
<p><strong>刷盘时机</strong></p>
<p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p>
<ul>
<li><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</li>
<li><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li>
<li><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li>
</ul>
<p><code>innodb_flush_log_at_trx_commit</code> 参数默认为 1 ，也就是说当事务提交时会调用 <code>fsync</code> 对 redo log 进行刷盘</p>
<p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/04.png" alt="img"></p>
<p>也就是说，一个没有提交事务的 <code>redo log</code> 记录，也可能会刷盘。</p>
<p><strong>为什么呢？</strong></p>
<p>因为在事务执行过程 <code>redo log</code> 记录是会写入<code>redo log buffer</code> 中，这些 <code>redo log</code> 记录会被后台线程刷盘。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/05.png" alt="img"></p>
<p>除了后台线程每秒<code>1</code>次的轮询操作，还有一种情况，当 <code>redo log buffer</code> 占用的空间即将达到 <code>innodb_log_buffer_size</code> 一半的时候，后台线程会主动刷盘。</p>
<p>下面是不同刷盘策略的流程图。</p>
<p><strong>innodb_flush_log_at_trx_commit&#x3D;0</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/06.png" alt="img"></p>
<p>为<code>0</code>时，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失。</p>
<p><strong>innodb_flush_log_at_trx_commit&#x3D;1</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/07.png" alt="img"></p>
<p>为<code>1</code>时， 只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p>
<p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。</p>
<p><strong>innodb_flush_log_at_trx_commit&#x3D;2</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/09.png" alt="img"></p>
<p>为<code>2</code>时， 只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p>
<p>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是宕机可能会有<code>1</code>秒数据的丢失。</p>
<p><strong>日志文件组</strong></p>
<p>硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。</p>
<p>比如可以配置为一组<code>4</code>个文件，每个文件的大小是 <code>1GB</code>，整个 <code>redo log</code> 日志文件组可以记录<code>4G</code>的内容。</p>
<p>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/10.png" alt="img"></p>
<p>在个<strong>日志文件组</strong>中还有两个重要的属性，分别是 <code>write pos、checkpoint</code></p>
<ul>
<li><strong>write pos</strong> 是当前记录的位置，一边写一边后移</li>
<li><strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移</li>
</ul>
<p>每次刷盘 <code>redo log</code> 记录到<strong>日志文件组</strong>中，<code>write pos</code> 位置就会后移更新。</p>
<p>每次 <code>MySQL</code> 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 <code>redo log</code> 记录，并把 <code>checkpoint</code> 后移更新。</p>
<p><code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 <code>redo log</code> 记录。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/11.png" alt="img"></p>
<p>如果 <code>write pos</code> 追上 <code>checkpoint</code> ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 <code>redo log</code> 记录，<code>MySQL</code> 得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/12.png" alt="img"></p>
<p><strong>redo log 小结</strong></p>
<p>相信大家都知道 <code>redo log</code> 的作用和它的刷盘时机、存储形式。</p>
<p>现在我们来思考一个问题： <strong>只要每次把修改后的数据页直接刷盘不就好了，还有 <code>redo log</code> 什么事？</strong></p>
<p>它们不都是刷盘么？差别在哪里？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> Byte = 8bit</span><br><span class="line"><span class="number">1</span> KB = <span class="number">1024</span> Byte</span><br><span class="line"><span class="number">1</span> MB = <span class="number">1024</span> KB</span><br><span class="line"><span class="number">1</span> GB = <span class="number">1024</span> MB</span><br><span class="line"><span class="number">1</span> TB = <span class="number">1024</span> GB</span><br></pre></td></tr></table></figure>

<p>实际上，数据页大小是<code>16KB</code>，刷盘比较耗时，可能就修改了数据页里的几 <code>Byte</code> 数据，有必要把完整的数据页刷盘吗？</p>
<p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p>
<p>如果是写 <code>redo log</code>，一行记录可能就占几十 <code>Byte</code>，只包含表空间号、数据页号、磁盘文件偏移 量、更新值，再加上是顺序写，所以刷盘速度很快。</p>
<p>所以用 <code>redo log</code> 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p>
<blockquote>
<p>其实内存的数据页在一定时机也会刷盘，我们把这称为页合并，讲 <code>Buffer Pool</code>的时候会对这块细说</p>
</blockquote>
<h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p>
<p>而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p>
<p>不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志。</p>
<p>那 <code>binlog</code> 到底是用来干嘛的？</p>
<p>可以说<code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/01-20220305234724956.png" alt="img"></p>
<p><code>binlog</code>会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p>
<p><strong>记录格式</strong></p>
<p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p>
<ul>
<li><strong>statement</strong></li>
<li><strong>row</strong></li>
<li><strong>mixed</strong></li>
</ul>
<p>指定<code>statement</code>，记录的内容是<code>SQL</code>语句原文，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/02-20220305234738688.png" alt="img"></p>
<p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题，<code>update_time=now()</code>这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p>
<p>为了解决这种问题，我们需要指定为<code>row</code>，记录的内容不再是简单的<code>SQL</code>语句了，还包含操作的具体数据，记录内容如下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/03-20220305234742460.png" alt="img"></p>
<p><code>row</code>格式记录的内容看不到详细信息，要通过<code>mysqlbinlog</code>工具解析出来。</p>
<p><code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）。</p>
<p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。</p>
<p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p>
<p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p>
<p><code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</p>
<p><strong>写入机制</strong></p>
<p><code>binlog</code>的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。</p>
<p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p>
<p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）。</p>
<p><code>binlog</code>日志刷盘流程如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/04-20220305234747840.png" alt="img"></p>
<ul>
<li><strong>上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li>
<li><strong>上图的 fsync，才是将数据持久化到磁盘的操作</strong></li>
</ul>
<p><code>write</code>和<code>fsync</code>的时机，可以由参数<code>sync_binlog</code>控制，默认是<code>0</code>。</p>
<p>为<code>0</code>的时候，表示每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/05-20220305234754405.png" alt="img"></p>
<p>虽然性能得到提升，但是机器宕机，<code>page cache</code>里面的 binlog 会丢失。</p>
<p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行<code>fsync</code>，就如同 <strong>redo log 日志刷盘流程</strong> 一样。</p>
<p>最后还有一种折中方式，可以设置为<code>N(N&gt;1)</code>，表示每次提交事务都<code>write</code>，但累积<code>N</code>个事务后才<code>fsync</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/06-20220305234801592.png" alt="img"></p>
<p>在出现<code>IO</code>瓶颈的场景里，将<code>sync_binlog</code>设置成一个比较大的值，可以提升性能。</p>
<p>同样的，如果机器宕机，会丢失最近<code>N</code>个事务的<code>binlog</code>日志。</p>
<h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</p>
<p><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性。</p>
<p>虽然它们都属于持久化的保证，但是侧重点不同。</p>
<p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/01-20220305234816065.png" alt="img"></p>
<p>回到正题，<code>redo log</code>与<code>binlog</code>两份日志之间的逻辑不一致，会出现什么问题？</p>
<p>我们以<code>update</code>语句为例，假设<code>id=2</code>的记录，字段<code>c</code>值是<code>0</code>，把字段<code>c</code>值更新成<code>1</code>，<code>SQL</code>语句为<code>update T set c=1 where id=2</code>。</p>
<p>假设执行过程中写完<code>redo log</code>日志后，<code>binlog</code>日志写期间发生了异常，会出现什么情况呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/02-20220305234828662.png" alt="img"></p>
<p>由于<code>binlog</code>没写完就异常，这时候<code>binlog</code>里面没有对应的修改记录。因此，之后用<code>binlog</code>日志恢复数据时，就会少这一次更新，恢复出来的这一行<code>c</code>值是<code>0</code>，而原库因为<code>redo log</code>日志恢复，这一行<code>c</code>值是<code>1</code>，最终数据不一致。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/03-20220305235104445.png" alt="img"></p>
<p>为了解决两份日志之间的逻辑一致问题，<code>InnoDB</code>存储引擎使用<strong>两阶段提交</strong>方案。</p>
<p>原理很简单，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>，这就是<strong>两阶段提交</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/04-20220305234956774.png" alt="img"></p>
<p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/05-20220305234937243.png" alt="img"></p>
<p>再看一个场景，<code>redo log</code>设置<code>commit</code>阶段发生异常，那会不会回滚事务呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQ%E6%8F%90%E5%8D%87/06-20220305234907651.png" alt="img"></p>
<p>并不会回滚事务，它会执行上图框住的逻辑，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据。</p>
<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><blockquote>
<p>这部分内容为 JavaGuide 的补充：</p>
</blockquote>
<p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>
<p>另外，<code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>这部分内容为 JavaGuide 的补充：</p>
</blockquote>
<p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p>
<p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>
<h2 id="5、面试题"><a href="#5、面试题" class="headerlink" title="5、面试题"></a>5、面试题</h2><h3 id="MySQL-的基础架构"><a href="#MySQL-的基础架构" class="headerlink" title="MySQL 的基础架构"></a>MySQL 的基础架构</h3><h4 id="MySQL-基础架构（一条-SQL-的执行流程）"><a href="#MySQL-基础架构（一条-SQL-的执行流程）" class="headerlink" title="MySQL 基础架构（一条 SQL 的执行流程）"></a>MySQL 基础架构（一条 SQL 的执行流程）</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQL%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/13526879-3037b144ed09eb88.png" alt="img"></p>
<ul>
<li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li>
<li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>
<li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li>
<li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li>
<li><strong>插件式存储引擎</strong> ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li>
</ul>
<h4 id="MySQL-的存储引擎了解吗？"><a href="#MySQL-的存储引擎了解吗？" class="headerlink" title="MySQL 的存储引擎了解吗？"></a>MySQL 的存储引擎了解吗？</h4><p>MySQL 默认的存储引擎是 <code>InnoDB</code>,除此之外 MySQL 还支持多种存储引擎：</p>
<ul>
<li>MyISAM</li>
<li>Memory</li>
</ul>
<p>MySQL 存储引擎采用的是 <strong>插件式架构</strong> ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p>
<ol>
<li><p><strong>InnoDB</strong>引擎支持MySQL事务，具有提交，回滚和崩溃恢复功能能够更加安全的保护用户数据；支持行级锁，提高多用户并发和性能；支持外键，维护数据完整性。 </p>
</li>
<li><p><strong>MyISAM</strong>引擎，占用空间较小，支持表级锁，能够限制读写工作的负载的性能，查询效率较高，常用于只读场景。 </p>
</li>
<li><p><strong>Memory</strong>引擎，将所有数据存储在RAM（主存）中，在非关键字查询时，查询效率较高。</p>
</li>
</ol>
<h4 id="InnoDB-和-MyISAM-的区别"><a href="#InnoDB-和-MyISAM-的区别" class="headerlink" title="InnoDB 和 MyISAM 的区别?"></a>InnoDB 和 MyISAM 的区别?</h4><table>
<thead>
<tr>
<th></th>
<th>InnoDB</th>
<th>MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td>锁的粒度</td>
<td>行锁</td>
<td>表锁</td>
</tr>
<tr>
<td>是否支持事务</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>是否支持外键</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>是否支持数据库异常崩溃后的安全恢复</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>是否支持 MVCC</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>索引实现不一样</td>
<td>数据文件本身就是索引</td>
<td>数据文件和索引分开</td>
</tr>
<tr>
<td>性能有差别</td>
<td>强</td>
<td>弱</td>
</tr>
</tbody></table>
<p><strong>总结</strong> ：</p>
<ul>
<li>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</li>
<li>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</li>
<li>MyISAM 不支持外键，而 InnoDB 支持。</li>
<li>MyISAM 不支持 MVCC，而 InnoDB 支持。</li>
<li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li>
<li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li>
<li>InnoDB 的性能比 MyISAM 更强大。</li>
</ul>
<p>在某些<strong>读密集</strong>的情况下，忽略不支持事务、崩溃恢复等缺点，使用 MyISAM 也是合适的。</p>
<h4 id="MySQL-的存储引擎架构了解吗？"><a href="#MySQL-的存储引擎架构了解吗？" class="headerlink" title="MySQL 的存储引擎架构了解吗？"></a>MySQL 的存储引擎架构了解吗？</h4><p>MySQL 存储引擎采用的是 <strong>插件式架构</strong> ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于<code>表</code>的，而不是数据库。</strong></p>
<h3 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQL%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/%E7%B4%A2%E5%BC%95.png" alt="索引"></p>
<h4 id="请你说说MySQL索引-以及它们的好处和坏处"><a href="#请你说说MySQL索引-以及它们的好处和坏处" class="headerlink" title="请你说说MySQL索引,以及它们的好处和坏处"></a>请你说说MySQL索引,以及它们的好处和坏处</h4><p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p>
<p><strong>优点</strong>：</p>
<ul>
<li>使用索引可以大大加快数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>比如索引必定会增加存储资源的消耗；</li>
<li>同时也增大了插入、更新和删除操作的维护成本,因为每个增删改操作后相应列的索引都必须被更新。</li>
</ul>
<p>只要创建了索引,就一定会走索引吗？ 不一定。 比如,在使用组合索引的时候,如果没有遵从“最左前缀”的原则进行搜索,则索引是不起作用的。</p>
<h4 id="索引底层的数据结构了解吗？"><a href="#索引底层的数据结构了解吗？" class="headerlink" title="索引底层的数据结构了解吗？"></a>索引底层的数据结构了解吗？</h4><p>MySQL 中的索引 <code>B+树</code>(多路平衡查找树) 实现的，无论是 Innodb 还是 MyIsam，都使用了 B+树 作为索引结构。。除此之外，MySQL 的索引还有 <code>Hash表</code>,<code>AVL树</code>,<code>红黑树</code>,<code>B树</code>。</p>
<ul>
<li><strong>哈希表(Hash 表)</strong> ：查询效率的确最高,基于内存，而数据库存储的数据又很大；哈希表也不支持范围查询；</li>
<li><strong>二叉查找树(BST)</strong> ：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表； </li>
<li><strong>平衡二叉树(AVL)</strong> ：通过旋转解决了平衡的问题，但是旋转操作效率太低；</li>
<li><strong>红黑树</strong> ：通过舍弃严格的平衡和引入红黑节点，解决了 AVL 旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO 次数太多；</li>
<li><strong>B 树</strong> ：通过将二叉树改为多路平衡查找树，解决了树过高的问题； </li>
<li><strong>B+树</strong> ：在 B 树的基础上，将非叶节点改造为不存储数据的纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效；</li>
</ul>
<p>B+树的优点：树深度小、IO次数少、访问速度快。</p>
<h4 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h4><p>根据底层<code>存储方式</code>角度划分聚簇索引和非聚簇索引。只有 InnoDB 才有聚簇索引。</p>
<p><strong>聚簇索引</strong>：索引结果和数据一起存放的索引。 </p>
<ul>
<li>优点：聚簇索引的查询速度非常快，因为聚簇索引本身就是一个B+树，数据节点属于有序的，当定位到索引上的时候就相当于找到了数据。</li>
<li>缺点：更新的时候代价大，依赖有序的数据。</li>
</ul>
<p><strong>非聚簇索引</strong>：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</p>
<ul>
<li>优点：更新代价比聚簇索引小。</li>
<li>缺点：依赖有序的数据，可能会二次回表查找。</li>
</ul>
<h4 id="MySQL-应用维度的索引划分？"><a href="#MySQL-应用维度的索引划分？" class="headerlink" title="MySQL 应用维度的索引划分？"></a>MySQL 应用维度的索引划分？</h4><p>按照应用维度划分：</p>
<ul>
<li>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li>
<li>普通索引：仅加速查询。</li>
<li>唯一索引：加速查询 + 列值唯一（可以有 NULL）。</li>
<li>覆盖索引：覆盖索引即需要<strong>查询的字段正好是索引的字段</strong>，那么直接根据该索引，就可以查到数据了，而<strong>无需回表</strong>查询。</li>
<li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并，索引在查询过程中遵循<strong>最左前缀匹配原则</strong>。</li>
<li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li>
</ul>
<p>二级索引(辅助索引)</p>
<p>二级索引的叶子节点存储的数据是主键，通过二级索引，可以定位主键的位置。</p>
<ol>
<li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li>
<li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li>
<li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li>
</ol>
<h4 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h4><p>最左前缀匹配原则指的是，在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 **<code>&gt;</code><strong>、</strong><code>&lt;</code>**）才会停止匹配。对于 <strong><code>&gt;=</code><strong>、</strong><code>&lt;=</code><strong>、</strong><code>BETWEEN</code><strong>、</strong><code>like</code></strong> 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p>
<h4 id="如何避免索引失效？"><a href="#如何避免索引失效？" class="headerlink" title="如何避免索引失效？"></a>如何避免索引失效？</h4><ul>
<li>使用 <code>SELECT *</code> 进行查询;</li>
<li>创建了组合索引，但查询条件未遵守最左匹配原则;</li>
<li>在索引列上进行计算、函数、类型转换等操作;</li>
<li>以 <code>%</code> 开头的 LIKE 查询比如 <code>like &#39;%abc&#39;</code>;</li>
<li>查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</li>
</ul>
<h4 id="索引下推了解吗？"><a href="#索引下推了解吗？" class="headerlink" title="索引下推了解吗？"></a>索引下推了解吗？</h4><p><strong>索引下推（Index Condition Pushdown）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p>
<h3 id="慢索引怎么排查，怎么调优"><a href="#慢索引怎么排查，怎么调优" class="headerlink" title="慢索引怎么排查，怎么调优?"></a>慢索引怎么排查，怎么调优?</h3><p>解决慢索引问题，可以使用 MySQL 的<code>慢查询日志</code>来识别慢查询，然后使用 <code>EXPLAIN</code> 分析查询执行计划，判断索引是否被使用。</p>
<ul>
<li>如果未使用索引，您可以在适当的列上创建索引。</li>
<li>如果正在使用索引但查询仍然很慢，您可以尝试通过<strong>重写查询</strong>或<strong>使用不同的查询策略</strong>来优化查询。要优化索引，可以使用 MySQLTuner 或 Percona Toolkit 等工具来分析您的数据库并提出优化建议。</li>
</ul>
<h3 id="MySQL-的事务"><a href="#MySQL-的事务" class="headerlink" title="MySQL 的事务"></a>MySQL 的事务</h3><h4 id="谈谈-MySQL-的事务吧？"><a href="#谈谈-MySQL-的事务吧？" class="headerlink" title="谈谈 MySQL 的事务吧？"></a>谈谈 MySQL 的事务吧？</h4><p><strong>事务是逻辑上的一组操作，要么全部执行成功,要么全部不执行。</strong></p>
<p>关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQL%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/ACID.png" alt="ACID"></p>
<ol>
<li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQL%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/AID-C.png" alt="AID-&gt;C"></p>
<h4 id="并发事务带来了什么问题？"><a href="#并发事务带来了什么问题？" class="headerlink" title="并发事务带来了什么问题？"></a>并发事务带来了什么问题？</h4><p>并发给数据库带来了：</p>
<ol>
<li><strong>脏读</strong>（<code>Dirty read</code>）:一个事务读取了这个还未提交的数据，但第一个事务突然回滚，读到的数据并没有提交到数据库，那第二个事务读取到的就是脏数据。</li>
<li><strong>丢失修改</strong>（<code>Lost to modify</code>）:两个事务访问同一个数据并且进行修改，这样一个事务内的修改结果就被丢失，因此称为丢失修改。</li>
<li><strong>不可重复读</strong>（<code>Unrepeatable read</code>）:指在一个事务内多次读同一数据,读到的数据不一致(在这两次读的期间有另一个事务对数据进行了修改)。</li>
<li><strong>幻读</strong>（<code>Phantom read</code>）:一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ol>
<h4 id="不可重复读和幻读有什么区别？"><a href="#不可重复读和幻读有什么区别？" class="headerlink" title="不可重复读和幻读有什么区别？"></a>不可重复读和幻读有什么区别？</h4><ul>
<li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的<strong>值被修改</strong>；</li>
<li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li>
</ul>
<p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p>
<p>执行 delete 和 update 操作的时候，可以直接对<code>记录加锁</code>，保证事务安全。而执行 insert 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖<code>间隙锁（Gap Lock）</code>。也就是说执行 insert 操作的时候需要依赖 <code>Next-Key Lock（Record Lock+Gap Lock）</code> 进行加锁来保证不出现幻读。</p>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQL%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/image-20230315100933693.png" alt="image-20230315100933693"></p>
<p>MySQL 的隔离级别基于<code>锁和 MVCC</code> 机制共同实现的。</p>
<p><strong>SERIALIZABLE</strong> 隔离级别是通过<code>锁</code>来实现的，<strong>READ-COMMITTED</strong> 和 <strong>REPEATABLE-READ</strong> 隔离级别是基于 <code>MVCC</code> 实现的。</p>
<p><strong>REPEATABLE-READ</strong> 在当前读情况下需要使用加锁读来保证不会出现幻读。</p>
<h4 id="并发事务的控制方式"><a href="#并发事务的控制方式" class="headerlink" title="并发事务的控制方式"></a>并发事务的控制方式</h4><p>MySQL 中并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>MVCC</strong>。锁可以看作是<strong>悲观</strong>控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是<strong>乐观</strong>控制的模式。</p>
<p><strong>锁</strong> 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过 <strong>读写锁</strong> 来实现并发控制。</p>
<ul>
<li><strong>共享锁（S 锁）</strong> ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>
<li><strong>排他锁（X 锁）</strong> ：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li>
</ul>
<p><strong>MVCC</strong> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p>
<p>MVCC 在 MySQL 中实现所依赖的手段主要是: <strong>隐藏字段、read view(快照读)、undo log</strong>。</p>
<ul>
<li>undo log : undo log 用于记录某行数据的多个版本的数据。</li>
<li>read view(快照读) 和 隐藏字段 : 用来判断当前版本数据的可见性。</li>
</ul>
<p><strong>RC 和 RR 的 MVCC 有什么区别</strong></p>
<p>在事务隔离级别 <code>RC</code> 和 <code>RR</code> （InnoDB 存储引擎的默认事务隔离级别）下，<code>InnoDB</code> 存储引擎使用 <code>MVCC</code>（非锁定一致性读），但它们生成 <code>Read View</code> 的时机却不同</p>
<ul>
<li>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> (m_ids 列表)</li>
<li>在 RR 隔离级别下只在事务开始后 <strong><code>第一次select</code></strong> 数据前生成一个<code>Read View</code>（m_ids 列表)</li>
</ul>
<p><strong>MVCC➕Next-key-Lock 防止幻读</strong></p>
<p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p>
<p>Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是<code>行锁（Record Lock）</code>和<code>间隙锁（Gap Lock）</code>的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。</p>
<p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p>
<p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p>
<p><strong>2、执行 select…for update&#x2F;lock in share mode、insert、update、delete 等当前读</strong></p>
<p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <code>Next-key Lock</code> 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读。</p>
<h3 id="MySQL-的锁"><a href="#MySQL-的锁" class="headerlink" title="MySQL 的锁"></a>MySQL 的锁</h3><h4 id="表级锁和行级锁了解吗？有什么区别？"><a href="#表级锁和行级锁了解吗？有什么区别？" class="headerlink" title="表级锁和行级锁了解吗？有什么区别？"></a>表级锁和行级锁了解吗？有什么区别？</h4><p>锁是一种常见的并发事务的控制方式。</p>
<p>MyISAM 仅仅支持表级锁，锁住整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁，还支持<code>行级锁</code>，默认为行级锁。InnoDB 锁的粒度更小，并发的性能更高。</p>
<p><strong>表级锁和行级锁对比</strong> ：</p>
<ul>
<li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是 <strong>针对索引字段加的锁</strong> ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</li>
</ul>
<h4 id="行锁使用有什么注意事项"><a href="#行锁使用有什么注意事项" class="headerlink" title="行锁使用有什么注意事项"></a>行锁使用有什么注意事项</h4><p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code>条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。</p>
<h4 id="InnoDB-行锁的分类"><a href="#InnoDB-行锁的分类" class="headerlink" title="InnoDB 行锁的分类"></a>InnoDB 行锁的分类</h4><p>InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p>
<ul>
<li><strong>记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。</li>
<li><strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</li>
<li><strong>临键锁（Next-Key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>
</ul>
<p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</strong></p>
<h4 id="共享锁和排他锁了解吗？"><a href="#共享锁和排他锁了解吗？" class="headerlink" title="共享锁和排他锁了解吗？"></a>共享锁和排他锁了解吗？</h4><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p>
<ul>
<li><strong>共享锁（S 锁）</strong> ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>
<li><strong>排他锁（X 锁）</strong> ：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li>
</ul>
<p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">S 锁</th>
<th align="left">X 锁</th>
</tr>
</thead>
<tbody><tr>
<td align="left">S 锁</td>
<td align="left">不冲突</td>
<td align="left">冲突</td>
</tr>
<tr>
<td align="left">X 锁</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
</tr>
</tbody></table>
<h4 id="意向锁了解吗？"><a href="#意向锁了解吗？" class="headerlink" title="意向锁了解吗？"></a>意向锁了解吗？</h4><p><code>意向锁</code>来快速判断是否可以对某个表使用表锁。</p>
<p>意向锁是表级锁，共有两种：</p>
<ul>
<li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li>
<li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li>
</ul>
<p><strong>意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</strong></p>
<p>意向锁之间是互相兼容的。</p>
<table>
<thead>
<tr>
<th></th>
<th>IS 锁</th>
<th>IX 锁</th>
</tr>
</thead>
<tbody><tr>
<td>IS 锁</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IX 锁</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</p>
<table>
<thead>
<tr>
<th></th>
<th>IS 锁</th>
<th>IX 锁</th>
</tr>
</thead>
<tbody><tr>
<td>S 锁</td>
<td>兼容</td>
<td>互斥</td>
</tr>
<tr>
<td>X 锁</td>
<td>互斥</td>
<td>互斥</td>
</tr>
</tbody></table>
<h3 id="MySQL-的日志"><a href="#MySQL-的日志" class="headerlink" title="MySQL 的日志"></a>MySQL 的日志</h3><h4 id="常见的日志有哪些？"><a href="#常见的日志有哪些？" class="headerlink" title="常见的日志有哪些？"></a>常见的日志有哪些？</h4><p>MySQL 的日志一共有：</p>
<ul>
<li>错误日志（error log） ：对 MySQL 的启动、运行、关闭过程进行了记录。 </li>
<li><strong>二进制日志</strong>（binary log，<code>binlog</code>） ：主要记录的是更改数据库数据的 SQL 语句。 </li>
<li>一般查询日志（general query log） ：已建立连接的客户端发送给 MySQL 服务器的所有 SQL 记录，因为 SQL 的量比较大，默认是不开启的，也不建议开启。 </li>
<li>慢查询日志（slow query log） ：执行时间超过 long_query_time秒钟的查询，解决 SQL 慢查询问题的时候会用到。 </li>
<li><strong>事务日志</strong>(<code>redo log</code> 和 <code>undo log</code>) ：redo log 是重做日志，undo log 是回滚日志。</li>
<li>中继日志(relay log) ：relay log 是复制过程中产生的日志，很多方面都跟 binary log 差不多。不过，relay log 针对的是主从复制中的从库。</li>
<li>DDL 日志(metadata log) ：DDL 语句执行的元数据操作。</li>
</ul>
<p><strong>慢查询日志</strong>（<code>slow query log</code>）主要用来优化 SQL 语句，通过慢查询日志可以找出那一条 SQL 执行的时间超过了 10s。之后就可以通过 <code>explain sql</code> 来具体分析这条语句。</p>
<p><strong>二进制日志</strong>（binary log，<code>binlog</code>） ：主要记录的是更改数据库数据的 SQL 语句,他不会记录并没有修改数据库的 SQL 如 select语句。主要是用来进行<code>主从同步</code>和<code>数据恢复</code>。当我们误删数据甚至是整个数据库的情况下，就可以使用 binlog 来帮助我们恢复数据。当然了，大前提是已经启用了 binlog 日志。</p>
<p><strong>重做日志</strong>（<code>redo log</code>） 主要用来保证事务的持久性。</p>
<h4 id="bin-log-有什么用？"><a href="#bin-log-有什么用？" class="headerlink" title="bin log 有什么用？"></a>bin log 有什么用？</h4><p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。<code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，属于<code>MySQL Server</code> 层。</p>
<p>不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志。</p>
<p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQL%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/01-20220305234724956.png" alt="img"></p>
<p><code>binlog</code>会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p>
<p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p>
<ul>
<li>statement ：记录 SQL语句原文 </li>
<li>row ： 记录SQL聚合函数中具体的数据</li>
<li>mixed ： 会判断使用 statement 或者 row。</li>
</ul>
<p><code>binlog</code>的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）。</p>
<p><code>binlog</code>日志<strong>刷盘流程</strong>如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQL%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/04-20220305234747840.png" alt="img"></p>
<ul>
<li><strong>write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li>
<li><strong>fsync，才是将数据持久化到磁盘的操作</strong></li>
</ul>
<p><code>write</code>和<code>fsync</code>的时机，可以由参数<code>sync_binlog</code>控制：</p>
<ul>
<li>默认为 0，每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。</li>
<li>设置为<code>1</code>，表示每次提交事务都会执行<code>fsync</code>，就如同 <strong>redo log 日志刷盘流程</strong> 一样。</li>
<li>设置为<code>N(N&gt;1)</code>，表示每次提交事务都<code>write</code>，但累积<code>N</code>个事务后才<code>fsync</code>。</li>
</ul>
<h4 id="redo-log-有什么用？"><a href="#redo-log-有什么用？" class="headerlink" title="redo log 有什么用？"></a>redo log 有什么用？</h4><p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p>
<p>当 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的持久性与完整性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQL%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/02.png" alt="img"></p>
<p><strong>redo log 存在的位置</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQL%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/03.png" alt="img"></p>
<p><code>redo log</code> 是 InnoDB 引擎特有的，记录的是物理日志，即记录了在某个页上做了什么修改。</p>
<p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p>
<ul>
<li><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</li>
<li><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li>
<li><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li>
</ul>
<h4 id="redo-log-和-bin-log-的区别"><a href="#redo-log-和-bin-log-的区别" class="headerlink" title="redo log 和 bin log 的区别"></a>redo log 和 bin log 的区别</h4><ul>
<li>bin log 主要用于<strong>数据库还原</strong>，属于数据级别的数据恢复，主从复制是 bin log 最常见的一个应用场景。redolog 主要用于保证<strong>事务的持久性</strong>，属于事务级别的数据恢复。 </li>
<li>redo log 属于 <strong>InnoDB 引擎特有的</strong>，bin log 属于所有存储引擎共有的，因为 bin log 是 <strong>MySQL 的 Server 层实现的</strong>。</li>
<li>redo log 属于物理日志，主要记录的是某个页的修改。bin log 属于逻辑日志，主要记录的是数据库执行的所有 DDL 和 DML 语句。 </li>
<li>bin log 通过追加的方式进行写入，大小没有限制。redo log 采用循环写的方式进行写入，大小固定，当写到结尾时，会回到开头循环写日志。</li>
</ul>
<h4 id="MySQL-如何保证事务的持久性？"><a href="#MySQL-如何保证事务的持久性？" class="headerlink" title="MySQL 如何保证事务的持久性？"></a>MySQL 如何保证事务的持久性？</h4><p>redo log 主要做的事情就是记录页的修改，比如某个页面某个偏移量处修改了几个字节的值以及具体被修改的内容是什么。在事务提交时，我们会将 redo log 按照刷盘策略刷到磁盘上去，这样即使 MySQL 宕机了，重启之后也能恢复未能写入磁盘的数据，从而保证事务的持久性。</p>
<h4 id="两阶段提交了解吗？"><a href="#两阶段提交了解吗？" class="headerlink" title="两阶段提交了解吗？"></a>两阶段提交了解吗？</h4><p>redo log 会在操作的时候写入缓存，最后追加到硬盘中。而 bin log 只有在事务提交时才会写入。如果在写入 bin log 发生错误，则根据 bin log 来同步的 从和备就会出现和主机不一样的情况。</p>
<p>为了避免这种情况，将 redo log 分为两个部分，prepare 写入，bin log 写入，redo log 变为 commit。在数据库发生故障时，会检测如果 redo log 的状态不是 commit 就会回滚数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQL%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/06-20220305234907651.png" alt="img"></p>
<h4 id="MySQL-如何保证原子性"><a href="#MySQL-如何保证原子性" class="headerlink" title="MySQL 如何保证原子性"></a>MySQL 如何保证原子性</h4><p>每一个事务对数据的修改都会被记录到 undo log ，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL 可以利用 undo log 将数据恢复到事务开始之前的状态。</p>
<p><strong>回滚日志</strong>（<code>undo log</code>）主要是用来保证事务原子性的。InnoDB存储引擎中 MVCC 的实现用到了 undo log 。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo log读取之前的行版本信息，以此实现非锁定读取。 </p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="MySQL-性能优化常见方法"><a href="#MySQL-性能优化常见方法" class="headerlink" title="MySQL 性能优化常见方法"></a>MySQL 性能优化常见方法</h4><ul>
<li><p>数据库只存储文件地址信息，文件由文件存储服务负责存储。</p>
</li>
<li><p>可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。</p>
</li>
</ul>
<h4 id="MySQL-的读写分离了解吗？"><a href="#MySQL-的读写分离了解吗？" class="headerlink" title="MySQL 的读写分离了解吗？"></a>MySQL 的读写分离了解吗？</h4><p><strong>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。</strong> 能够小幅提升写性能，大幅提升读性能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQL%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/read-and-write-separation.png" alt="读写分离示意图"></p>
<p>我们都会选择一主多从，也就是一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。</p>
<p><strong>主从同步延迟</strong> 如何解决？</p>
<ol>
<li>强制将读请求路由到主库处理。</li>
<li>延迟读取。</li>
</ol>
<p><strong>读写分离的步骤</strong>？</p>
<ol>
<li>部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。</li>
<li>保证主数据库和从数据库之间的数据是实时同步的，这个过程也就是我们常说的<strong>主从复制</strong>。</li>
<li>系统将写请求交给主数据库处理，读请求交给从数据库处理。</li>
</ol>
<p><strong>1.代理方式</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQL%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/read-and-write-separation-proxy.png" alt="代理方式实现读写分离"></p>
<p>我们可以在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。</p>
<p>提供类似功能的中间件有 <strong>MySQL Router</strong>（官方）、<strong>Atlas</strong>（基于 MySQL Proxy）、<strong>Maxscale</strong>、<strong>MyCat</strong>。</p>
<p><strong>2.组件方式</strong></p>
<p>在这种方式中，我们可以通过引入第三方组件来帮助我们读写请求。</p>
<p>这也是我比较推荐的一种方式。这种方式目前在各种互联网公司中用的最多的，相关的实际的案例也非常多。如果你要采用这种方式的话，推荐使用 <code>sharding-jdbc</code> ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。</p>
<p><strong>主从复制原理</strong>是什么？</p>
<p>MySQL binlog(binary log 即二进制日志文件) 主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)。因此，我们根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/MySQL%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/78816271d3ab52424bfd5ad3086c1a0f.png" alt="MySQL主从复制"></p>
<ol>
<li>主库将数据库中数据的变化写入到 binlog</li>
<li>从库连接主库</li>
<li>从库会创建一个 I&#x2F;O 线程向主库请求更新的 binlog</li>
<li>主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I&#x2F;O 线程负责接收</li>
<li>从库的 I&#x2F;O 线程将接收的 binlog 写入到 relay log 中。</li>
<li>从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。</li>
</ol>
<h4 id="分库分表了解吗？"><a href="#分库分表了解吗？" class="headerlink" title="分库分表了解吗？"></a>分库分表了解吗？</h4><p><strong>分库分表 解决 MySQL 的存储压力</strong></p>
<p><strong>分库</strong> 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。</p>
<ul>
<li><strong>垂直分库</strong> 就是把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。</li>
<li><strong>水平分库</strong> 是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。</li>
</ul>
<p><strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p>
<ul>
<li><strong>垂直分表</strong> 是对数据表列的拆分，把一张列比较多的表拆分为多张表。</li>
<li><strong>水平分表</strong> 是对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。</li>
</ul>
<p>遇到下面几种场景可以考虑分库分表：</p>
<ul>
<li>单表的数据达到千万级别以上，数据库读写速度比较缓慢。</li>
<li>数据库中的数据占用的空间越来越大，备份时间越来越长。</li>
<li>应用的并发量太大。</li>
</ul>
<p>常见的分片算法有哪些？</p>
<ul>
<li><strong>哈希分片</strong> ：求指定 key（比如 id） 的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。</li>
<li><strong>范围分片</strong> ：按照特性的范围区间（比如时间区间、ID区间）来分配数据，比如 将 <code>id</code> 为 <code>1~299999</code> 的记录分到第一个库， <code>300000~599999</code> 的分到第二个库。范围分片适合需要经常进行范围查找的场景，不太适合随机读写的场景（数据未被分散，容易出现热点数据的问题）。</li>
<li><strong>地理位置分片</strong> ：很多 NewSQL 数据库都支持地理位置分片算法，也就是根据地理位置（如城市、地域）来分配数据。</li>
<li><strong>融合算法</strong> ：灵活组合多种分片算法，比如将哈希分片和范围分片组合。</li>
</ul>
<h4 id="Count-函数"><a href="#Count-函数" class="headerlink" title="Count()函数"></a>Count()函数</h4><p><strong>性能</strong>：count(*)&#x3D;count(1) &gt; count(主键子段) &gt; count(字段)</p>
<p>函数作用是<strong>统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个</strong>。</p>
<p>count(1) 相比 count(主键字段) 少一个步骤，就是不需要读取记录中的字段值，所以通常会说 count(1) 执行效率会比 count(主键字段) 高一点。如果表里有二级索引时，InnoDB 循环遍历的对象就二级索引了。</p>
<p>**count(<code>\*</code>) 其实等于 count(<code>0</code>)**，也就是说，当你使用 count(<code>*</code>) 时，MySQL 会将 <code>*</code> 参数转化为参数 0 来处理。 </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://www.haungrd.top">Huang RD</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.haungrd.top/2023/03/17/MySQL%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/">http://www.haungrd.top/2023/03/17/MySQL%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.haungrd.top" target="_blank">Huang Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="post-meta__tags" href="/tags/Mysql/">Mysql</a></div><div class="post_share"><div class="social-share" data-image="https://www.huangrd.top/images/agentina/10.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/20/JVM/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/16/Linux%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux 复习提升</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/11/20/MySQL/" title="Mysql"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-20</div><div class="title">Mysql</div></div></a></div><div><a href="/2023/02/11/mysql45%E8%AE%B2%E7%AC%94%E8%AE%B0/" title="Mysql 45讲笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-11</div><div class="title">Mysql 45讲笔记</div></div></a></div><div><a href="/2023/02/06/Mysql%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/" title="MYSQL刷题总结"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-06</div><div class="title">MYSQL刷题总结</div></div></a></div><div><a href="/2023/03/03/Redis%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/" title="Redis 复习提升"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-03</div><div class="title">Redis 复习提升</div></div></a></div><div><a href="/2023/02/15/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="数据库"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-15</div><div class="title">数据库</div></div></a></div><div><a href="/2023/02/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" title="面试题整理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-27</div><div class="title">面试题整理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL-%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87"><span class="toc-text">MySQL 复习提升</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%B4%A2%E5%BC%95"><span class="toc-text">1、索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">索引的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">索引的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95"><span class="toc-text">Mysql 的一些用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BA%8B%E5%8A%A1"><span class="toc-text">2、事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql%E4%B8%AD%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C"><span class="toc-text">Mysql中事务操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">事务存在的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">事务的隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">事务的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">并发事务的控制方式有哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-text">3、锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">锁的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E9%94%81"><span class="toc-text">行锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E9%94%81"><span class="toc-text">表锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E9%94%81%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">两者锁的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM%E8%A1%A8%E9%94%81"><span class="toc-text">MyISAM表锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E8%A1%8C%E9%94%81%E4%B8%8E%E8%A1%A8%E9%94%81"><span class="toc-text">InnoDB行锁与表锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">行锁的类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%97%A5%E5%BF%97"><span class="toc-text">4、日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%EF%BC%88redo-log%EF%BC%89"><span class="toc-text">重做日志（redo log）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%EF%BC%88undo-log%EF%BC%89"><span class="toc-text">回滚日志（undo log）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%EF%BC%88binlog%EF%BC%89"><span class="toc-text">二进制日志（binlog）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97"><span class="toc-text">错误日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97-general-query-log"><span class="toc-text">普通查询日志 (general query log)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-text">慢查询日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E7%A9%B6-redo-log-%E5%92%8C-bin-log"><span class="toc-text">细究 redo log 和 bin log</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log"><span class="toc-text">redo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binlog"><span class="toc-text">binlog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-text">两阶段提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-log"><span class="toc-text">undo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">5、面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E7%9A%84%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="toc-text">MySQL 的基础架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BC%88%E4%B8%80%E6%9D%A1-SQL-%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-text">MySQL 基础架构（一条 SQL 的执行流程）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">MySQL 的存储引擎了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB-%E5%92%8C-MyISAM-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">InnoDB 和 MyISAM 的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">MySQL 的存储引擎架构了解吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E7%B4%A2%E5%BC%95"><span class="toc-text">MySQL 索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4MySQL%E7%B4%A2%E5%BC%95-%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%A5%BD%E5%A4%84%E5%92%8C%E5%9D%8F%E5%A4%84"><span class="toc-text">请你说说MySQL索引,以及它们的好处和坏处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">索引底层的数据结构了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">聚簇索引和非聚簇索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-%E5%BA%94%E7%94%A8%E7%BB%B4%E5%BA%A6%E7%9A%84%E7%B4%A2%E5%BC%95%E5%88%92%E5%88%86%EF%BC%9F"><span class="toc-text">MySQL 应用维度的索引划分？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-text">最左前缀匹配原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-text">如何避免索引失效？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">索引下推了解吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E7%B4%A2%E5%BC%95%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%EF%BC%8C%E6%80%8E%E4%B9%88%E8%B0%83%E4%BC%98"><span class="toc-text">慢索引怎么排查，怎么调优?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E7%9A%84%E4%BA%8B%E5%8A%A1"><span class="toc-text">MySQL 的事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-MySQL-%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%90%A7%EF%BC%9F"><span class="toc-text">谈谈 MySQL 的事务吧？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">并发事务带来了什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">不可重复读和幻读有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">事务隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-text">并发事务的控制方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E7%9A%84%E9%94%81"><span class="toc-text">MySQL 的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81%E5%92%8C%E8%A1%8C%E7%BA%A7%E9%94%81%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">表级锁和行级锁了解吗？有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E4%BD%BF%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">行锁使用有什么注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB-%E8%A1%8C%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">InnoDB 行锁的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">共享锁和排他锁了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">意向锁了解吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-text">MySQL 的日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">常见的日志有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bin-log-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">bin log 有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">redo log 有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log-%E5%92%8C-bin-log-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">redo log 和 bin log 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%9F"><span class="toc-text">MySQL 如何保证事务的持久性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">两阶段提交了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">MySQL 如何保证原子性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-text">MySQL 性能优化常见方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-%E7%9A%84%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">MySQL 的读写分离了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">分库分表了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Count-%E5%87%BD%E6%95%B0"><span class="toc-text">Count()函数</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Huang RD</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>