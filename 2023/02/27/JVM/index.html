<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JVM | Huang Blog</title><meta name="author" content="Huang RD"><meta name="copyright" content="Huang RD"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="JVM1、JVM 的运行机制JVM（Java Virtual Machine）是用于运行 Java 字节码的虚拟机，包括一套字节码指令集、一组程序寄存器、一个虚拟机栈、一个虚拟机堆、一个方法区和一个垃圾回收器。 JVM 运行在操作系统之上，不与硬件设备直接交互。 Java 源文件在通过编译器之后被编译成相应的 ．Class 文件（字节码文件），.Class 文件又被 JVM 中的解释器编译成机器码">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://www.haungrd.top/2023/02/27/JVM/index.html">
<meta property="og:site_name" content="Huang Blog">
<meta property="og:description" content="JVM1、JVM 的运行机制JVM（Java Virtual Machine）是用于运行 Java 字节码的虚拟机，包括一套字节码指令集、一组程序寄存器、一个虚拟机栈、一个虚拟机堆、一个方法区和一个垃圾回收器。 JVM 运行在操作系统之上，不与硬件设备直接交互。 Java 源文件在通过编译器之后被编译成相应的 ．Class 文件（字节码文件），.Class 文件又被 JVM 中的解释器编译成机器码">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.huangrd.top/images/agentina/8.jpg">
<meta property="article:published_time" content="2023-02-27T10:12:57.000Z">
<meta property="article:modified_time" content="2023-02-28T05:16:07.806Z">
<meta property="article:author" content="Huang RD">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="虚拟机">
<meta property="article:tag" content="底层">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.huangrd.top/images/agentina/8.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.haungrd.top/2023/02/27/JVM/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-28 13:16:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://getwallpapers.com/wallpaper/full/a/1/8/1057222-free-download-cool-nature-backgrounds-1920x1200-windows-10.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.huangrd.top/images/agentina/8.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Huang Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-27T10:12:57.000Z" title="发表于 2023-02-27 18:12:57">2023-02-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-28T05:16:07.806Z" title="更新于 2023-02-28 13:16:07">2023-02-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/">JAVA</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="1、JVM-的运行机制"><a href="#1、JVM-的运行机制" class="headerlink" title="1、JVM 的运行机制"></a>1、JVM 的运行机制</h2><p>JVM（Java Virtual Machine）是用于运行 Java 字节码的虚拟机，包括一套字节码指令集、一组程序寄存器、一个虚拟机栈、一个虚拟机堆、一个方法区和一个垃圾回收器。</p>
<p>JVM 运行在操作系统之上，不与硬件设备直接交互。</p>
<p>Java 源文件在通过编译器之后被编译成相应的 ．Class 文件（字节码文件），.Class 文件又被 JVM 中的解释器编译成机器码在不同的操作系统上运行。</p>
<p><strong>Java 跨平台的原因</strong>每种操作系统的解释器都是不同的，但基于解释器实现的虚拟机是相同的。</p>
<p>在一个Java进程开始运行后，虚拟机就开始实例化了，有多个进程启动就会实例化多个虚拟机实例。进程退出或者关闭，则虚拟机实例消亡，在多个虚拟机实例之间不能共享数据。</p>
<p>Java 程序的具体运行过程如下:</p>
<ol>
<li>Java 源文件被编译器编译成字节码文件;</li>
<li>JVM 将字节码文件编译成相应操作系统的机器码;</li>
<li>机器码调用相应操作系统的本地方法库执行相应的方法;</li>
</ol>
<p>Java虚拟机包括一个类加载器子系统（Class Loader SubSystem）、运行时数据区（Runtime Data Area）、执行引擎和本地接口库（Native Interface Library）。</p>
<p>本地接口库通过调用本地方法库（Native Method Library）与操作系统交互。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230227155034178.png" alt="image-20230227155034178"></p>
<p>其中：</p>
<ul>
<li>类加载器子系统用于将编译好的 ．Class 文件加载到 JVM 中；</li>
<li>运行时数据区用于存储在 JVM 运行过程中产生的数据，包括程序计数器、方法区、本地方法区、虚拟机栈和虚拟机堆；</li>
<li>执行引擎包括即时编译器和垃圾回收器，即时编译器用于将 Java 字节码编译成具体的机器码，垃圾回收器用于回收在运行过程中不再使用的对象；</li>
<li>本地接口库用于调用操作系统的本地方法库完成具体的指令操作。</li>
</ul>
<h2 id="2、多线程"><a href="#2、多线程" class="headerlink" title="2、多线程"></a>2、多线程</h2><p>在多核操作系统上，JVM 允许在一个进程内同时并发执行多个线程。</p>
<p>JVM 中的线程与操作系统中的线程是相互对应的，在JVM线程的本地存储、缓冲区分配、同步对象、栈、程序计数器等准备工作都完成时，JVM 会调用操作系统的接口创建一个与之对应的原生线程；在JVM线程运行结束时，原生线程随之被回收。操作系统负责调度所有线程，并为其分配CPU时间片，在原生线程初始化完毕时，就会调用Java线程的run()执行该线程；在线程结束时，会释放原生线程和Java线程所对应的资源。</p>
<p>在JVM后台运行的线程主要有以下几个:</p>
<ul>
<li>虚拟机线程（JVM Thread）：虚拟机线程在JVM到达安全点（SafePoint）时出现。</li>
<li>周期性任务线程：通过定时器调度线程来实现周期性操作的执行。</li>
<li>GC 线程：GC 线程支持 JVM 中不同的垃圾回收活动。</li>
<li>编译器线程：编译器线程在运行时将字节码动态编译成本地平台机器码，是JVM跨平台的具体实现。</li>
<li>信号分发线程：接收发送到 JVM 的信号并调用 JVM 方法。</li>
</ul>
<h2 id="3、JVM-的内存区域"><a href="#3、JVM-的内存区域" class="headerlink" title="3、JVM 的内存区域"></a>3、JVM 的内存区域</h2><p>JVM的内存区域分为<strong>线程私有区域</strong>（程序计数器、虚拟机栈、本地方法区）、<strong>线程共享区域</strong>（堆、方法区）和直接内存。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230227155815581.png" alt="image-20230227155815581"></p>
<p><strong>线程私有区域的生命周期与线程相同，随线程的启动而创建，随线程的结束而销毁。</strong>在JVM内，每个线程都与操作系统的本地线程直接映射，因此这部分内存区域的存在与否和本地线程的启动和销毁对应。</p>
<p><strong>线程共享区域随虚拟机的启动而创建，随虚拟机的关闭而销毁。</strong></p>
<p>直接内存也叫作<strong>堆外内存</strong>，它并不是 JVM 运行时数据区的一部分，但在并发编程中被频繁使用。JDK 的 <code>NIO</code> 模块提供的基于 Channel 与 Buffer 的 I&#x2F;O 操作方式就是基于堆外内存实现的，NIO 模块通过调用 Native 函数库直接在操作系统上分配堆外内存，然后使用 DirectByteBuffer  对象作为这块内存的引用对内存进行操作，Java 进程可以通过堆外内存技术避免在 Java 堆和 Native 堆中来回复制数据带来的资源占用和性能消耗，因此堆外内存在高并发应用场景下被广泛使用（Netty、Flink、HBase、Hadoop 都有用到堆外内存）。</p>
<h3 id="3-1、程序计数器：线程私有，无内存溢出问题"><a href="#3-1、程序计数器：线程私有，无内存溢出问题" class="headerlink" title="3.1、程序计数器：线程私有，无内存溢出问题"></a>3.1、程序计数器：线程私有，无内存溢出问题</h3><p>程序计数器是一块很小的内存空间，用于<strong>存储当前运行的线程所执行的字节码的行号</strong>指示器。每个运行中的线程都有一个独立的程序计数器，在方法正在执行时，该方法的程序计数器记录的是实时虚拟机字节码指令的地址；如果该方法执行的是Native 方法，则程序计数器的值为空（Undefined）。程序计数器属于“线程私有”的内存区域，它是唯一没有 <code>Out Of Memory（内存溢出）</code>的区域。</p>
<h3 id="3-2、虚拟机栈：线程私有，描述-Java-方法的执行过程"><a href="#3-2、虚拟机栈：线程私有，描述-Java-方法的执行过程" class="headerlink" title="3.2、虚拟机栈：线程私有，描述 Java 方法的执行过程"></a>3.2、虚拟机栈：线程私有，描述 Java 方法的执行过程</h3><p>虚拟机栈是描述 Java 方法的执行过程的内存模型，它在当前栈帧（Stack Frame）中存储了局部变量表、操作数栈、动态链接、方法出口等信息。同时，栈帧用来存储部分运行时数据及其数据结构，处理动态链接（Dynamic Linking）方法的返回值和异常分派（Dispatch Exception）。</p>
<p>栈帧用来记录方法的执行过程，在方法被执行时虚拟机会为其创建一个与之对应的栈帧，方法的执行和返回对应栈帧在虚拟机栈中的入栈和出栈。无论方法是正常运行完成还是异常完成（抛出了在方法内未被捕获的异常），都视为方法运行结束。图中展示了线程运行及栈帧变化的过程。线程1 在 CPU1 上运行，线程2 在 CPU2 上运行，在 CPU 资源不够时其他线程将处于等待状态，等待获取 CPU 时间片。而在线程内部，每个方法的执行和返回都对应一个栈帧的入栈和出栈，每个运行中的线程当前只有一个栈帧处于活动状态。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230227161028047.png" alt="image-20230227161028047"></p>
<h3 id="3-3、本地方法区：线程私有"><a href="#3-3、本地方法区：线程私有" class="headerlink" title="3.3、本地方法区：线程私有"></a>3.3、本地方法区：线程私有</h3><p>本地方法区和虚拟机栈的作用类似，区别是虚拟机栈为执行 Java 方法服务，本地方法栈为 Native 方法服务。</p>
<h3 id="3-4、堆：也叫作运行时数据区，线程共享"><a href="#3-4、堆：也叫作运行时数据区，线程共享" class="headerlink" title="3.4、堆：也叫作运行时数据区，线程共享"></a>3.4、堆：也叫作运行时数据区，线程共享</h3><p>在 JVM 运行过程中创建的对象和产生的数据都被存储在堆中，堆是被线程共享的内存区域，也是垃圾收集器进行垃圾回收的最主要的内存区域。由于现代 JVM 采用分代收集算法，因此 Java 堆从 GC（Garbage Collection，垃圾回收）的角度还可以细分为：新生代、老年代和永久代。</p>
<h4 id="3-5、方法区：线程共享"><a href="#3-5、方法区：线程共享" class="headerlink" title="3.5、方法区：线程共享"></a>3.5、方法区：线程共享</h4><p>方法区也被称为永久代，用于存储常量、静态变量、类信息、即时编译器编译后的机器码、运行时常量池等数据</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230227161440001.png" alt="image-20230227161440001"></p>
<p>JVM 把 GC 分代收集扩展至方法区，即使用 Java 堆的永久代来实现方法区，这样 JVM 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存。永久带的内存回收主要针对常量池的回收和类的卸载，因此可回收的对象很少。常量被存储在运行时常量池（Runtime Constant Pool）中，是方法区的一部分。静态变量也属于方法区的一部分。在类信息（Class文件）中不但保存了类的版本、字段、方法、接口等描述信息，还保存了常量信息。在即时编译后，代码的内容将在执行阶段（类加载完成后）被保存在方法区的运行时常量池中。Java虚拟机对Class文件每一部分的格式都有明确的规定，只有符合JVM 规范的 Class 文件才能通过虚拟机的检查，然后被装载、执行。</p>
<h2 id="4、JVM-的运行时内存"><a href="#4、JVM-的运行时内存" class="headerlink" title="4、JVM 的运行时内存"></a>4、JVM 的运行时内存</h2><p>JVM 的运行时内存也叫作 JVM堆，从 GC 的角度可以将JVM堆分为新生代、老年代和永久代。其中新生代默认占1&#x2F;3堆空间，老年代默认占 2&#x2F;3 堆空间，永久代占非常少的堆空间。新生代又分为 Eden区、 ServivorFrom区 和 ServivorTo区，Eden 区默认占 8&#x2F;10 新生代空间，ServivorFrom区 和 ServivorTo区 默认分别占1&#x2F;10新生代空间，</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230227161952144.png" alt="image-20230227161952144"></p>
<h3 id="4-1、新生代：Eden区、ServivorTo区和ServivorFrom区"><a href="#4-1、新生代：Eden区、ServivorTo区和ServivorFrom区" class="headerlink" title="4.1、新生代：Eden区、ServivorTo区和ServivorFrom区"></a>4.1、新生代：Eden区、ServivorTo区和ServivorFrom区</h3><p><strong>JVM 新创建的对象（除了大对象外）会被存放在新生代</strong>，默认占 1&#x2F;3 堆内存空间。由于 JVM 会频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收。新生代又分为 Eden区、ServivorTo区和ServivorFrom区，如下所述:</p>
<ol>
<li>Eden区：Java新创建的对象首先会被存放在Eden区，如果新创建的对象属于大对象，则直接将其分配到老年代。大对象的定义和具体的JVM版本、堆大小和垃圾回收策略有关，一般为 2 KB～128 KB ，可通过XX:PretenureSizeThreshold 设置其大小。在 Eden 区的内存空间不足时会触发 MinorGC，对新生代进行一次垃圾回收。</li>
<li>ServivorTo区：保留上一次 MinorGC 时的幸存者。</li>
<li>ServivorFrom区：将上一次 MinorGC 时的幸存者作为这一次 MinorGC 的被扫描者。</li>
</ol>
<p>新生代的 GC 过程叫作 <code>MinorGC</code>，采用复制算法实现，具体过程如下:</p>
<ol>
<li>把在 Eden 区和 ServivorFrom 区中存活的对象复制到 ServivorTo 区。如果某对象的年龄达到老年代的标准（对象晋升老年代的标准由 XX:MaxTenuringThreshold 设置，默认为15），则将其复制到老年代，同时把这些对象的年龄加1；如果ServivorTo区的内存空间不够，则也直接将其复制到老年代；如果对象属于大对象（大小为 2 KB～128 KB 的对象属于大对象，例如通过 XX:PretenureSizeThreshold&#x3D;2097152 设置大对象为2 MB,1024×1024×2 Byte &#x3D; 2097152 Byte &#x3D; 2 MB），则也直接将其复制到老年代。</li>
<li>清空Eden区和ServivorFrom区中的对象。</li>
<li>将ServivorTo区和ServivorFrom区互换，原来的ServivorTo区成为下一次GC时的ServivorFrom区。</li>
</ol>
<h3 id="4-2、老年代"><a href="#4-2、老年代" class="headerlink" title="4.2、老年代"></a>4.2、老年代</h3><p><strong>老年代主要存放有长生命周期的对象和大对象</strong>。老年代的 GC 过程叫作 <code>MajorGC</code>。在老年代，对象比较稳定，MajorGC 不会被频繁触发。在进行 MajorGC 前，JVM会进行一次 MinorGC，在 MinorGC 过后仍然出现老年代空间不足或无法找到足够大的连续空间分配给新创建的大对象时，会触发 MajorGC 进行垃圾回收，释放 JVM 的内存空间。MajorGC 采用标记清除算法，该算法首先会扫描所有对象并标记存活的对象，然后回收未被标记的对象，并释放内存空间。因为要先扫描老年代的所有对象再回收，所以 MajorGC 的耗时较长。MajorGC 的标记清除算法容易产生内存碎片。在老年代没有内存空间可分配时，会抛出 Out Of Memory 异常。</p>
<h3 id="4-3、永久代"><a href="#4-3、永久代" class="headerlink" title="4.3、永久代"></a>4.3、永久代</h3><p>永久代指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息。Class 在类加载时被放入永久代。永久代和老年代、新生代不同，GC 不会在程序运行期间对永久代的内存进行清理，这也导致了<strong>永久代的内存会随着加载的 Class 文件的增加而增加</strong>，在加载的 Class 文件过多时会抛出 <code>Out Of Memory </code>异常，比如Tomcat引用Jar文件过多导致JVM内存不足而无法启动。</p>
<p>需要注意的是，在Java 8中永久代已经被元数据区（也叫作元空间）取代。元数据区的作用和永久代类似，二者最大的区别在于：元数据区并没有使用虚拟机的内存，而是直接使用操作系统的本地内存。因此，元空间的大小不受JVM内存的限制，只和操作系统的内存有关。在Java 8中，JVM将类的元数据放入本地内存（Native Memory）中，将常量池和类的静态变量放入 Java 堆中，这样 JVM 能够加载多少元数据信息就不再由 JVM 的最大可用内存（MaxPermSize）空间决定，而由操作系统的实际可用内存空间决定。</p>
<h2 id="5、垃圾回收与算法"><a href="#5、垃圾回收与算法" class="headerlink" title="5、垃圾回收与算法"></a>5、垃圾回收与算法</h2><h3 id="5-1、如何确定垃圾"><a href="#5-1、如何确定垃圾" class="headerlink" title="5.1、如何确定垃圾"></a>5.1、如何确定垃圾</h3><p>Java 采用引用计数法和可达性分析来确定对象是否应该被回收，其中，引用计数法容易产生循环引用的问题，可达性分析通过根搜索算法（GC Roots Tracing）来实现。根搜索算法以一系列 GC Roots 的点作为起点向下搜索，在一个对象到任何 GC Roots 都没有引用链相连时，说明其已经死亡。根搜索算法主要针对栈中的引用、方法区中的静态引用和 JNI 中的引用展开分析，如图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230227170019350.png" alt="image-20230227170019350"></p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>在 Java 中如果要操作对象，就必须先获取该对象的引用，因此可以通过引用计数法来判断一个对象是否可以被回收。在为对象添加一个引用时，引用计数加1；在为对象删除一个引用时，引进计数减1；如果一个对象的引用计数为0，则表示此刻该对象没有被引用，可以被回收。引用计数法容易产生循环引用问题。循环引用指两个对象相互引用，导致它们的引用一直存在，而不能被回收，如图所示，Object1 与 Object2 互为引用，如果采用引用计数法，则 Object1 和 Object2 由于互为引用，其引用计数一直为1，因而无法被回收。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230227170219342.png" alt="image-20230227170219342"></p>
<h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>为了解决引用计数法的循环引用问题，Java 还采用了可达性分析来判断对象是否可以被回收。具体做法是首先定义一些 GC Roots 对象，然后以这些 GC Roots 对象作为起点向下搜索，如果在 GC roots 和一个对象之间没有可达路径，则称该对象是不可达的。不可达对象要经过至少两次标记才能判定其是否可以被回收，如果在两次标记后该对象仍然是不可达的，则将被垃圾收集器回收。</p>
<h3 id="5-2、Java-中常用的垃圾回收算法"><a href="#5-2、Java-中常用的垃圾回收算法" class="headerlink" title="5.2、Java 中常用的垃圾回收算法"></a>5.2、Java 中常用的垃圾回收算法</h3><p>Java中常用的垃圾回收算法有标记清除（Mark-Sweep）、复制（Copying）、标记整理（Mark-Compact）和分代收集（Generational Collecting）这4种垃圾回收算法，如图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230227170525095.png" alt="image-20230227170525095"></p>
<h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>标记清除算法是基础的垃圾回收算法，其过程分为标记和清除两个阶段。在标记阶段标记所有需要回收的对象，在清除阶段清除可回收的对象并释放其所占用的内存空间，如图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230227170611557.png" alt="image-20230227170611557"></p>
<p>由于标记清除算法在清理对象所占用的内存空间后并没有重新整理可用的内存空间，因此如果内存中可被回收的小对象居多，则会引起<strong>内存碎片化</strong>的问题，继而引起大对象无法获得连续可用空间的问题。</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>复制算法是为了解决标记清除算法内存碎片化的问题而设计的。复制算法首先将内存划分为两块大小相等的内存区域，即区域1 和 区域2，新生成的对象都被存放在 区域1 中，在 区域1 内的对象存储满后会对 区域1 进行一次标记，并将标记后仍然存活的对象全部复制到 区域2 中，这时 区域1 将不存在任何存活的对象，直接清理整个 区域1 的内存即可，如图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230227170755869.png" alt="image-20230227170755869"></p>
<p>复制算法的<strong>内存清理效率高</strong>且易于实现，但由于同一时刻只有一个内存区域可用，即可用的内存空间被压缩到原来的一半，因此<strong>存在大量的内存浪费</strong>。同时，在系统中有大量长时间存活的对象时，这些对象将在内存区域1和内存区域2之间来回复制而影响系统的运行效率。因此，该算法只在对象为“朝生夕死”状态时运行效率较高。</p>
<h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>标记整理算法结合了标记清除算法和复制算法的优点，其标记阶段和标记清除算法的标记阶段相同，在标记完成后将存活的对象移到内存的另一端，然后清除该端的对象并释放内存，如图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230227170934232.png" alt="image-20230227170934232"></p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>无论是标记清除算法、复制算法还是标记整理算法，都无法对所有类型（长生命周期、短生命周期、大对象、小对象）的对象都进行垃圾回收。因此，针对不同的对象类型，JVM 采用了不同的垃圾回收算法，该算法被称为分代收集算法。</p>
<p>分代收集算法<strong>根据对象的不同类型将内存划分为不同的区域</strong>，JVM 将堆划分为新生代和老年代。新生代主要存放新生成的对象，其特点是对象数量多但是生命周期短，在每次进行垃圾回收时都有大量的对象被回收；老年代主要存放大对象和生命周期长的对象，因此可回收的对象相对较少。因此，JVM 根据不同的区域对象的特点选择了不同的算法。</p>
<p>目前，大部分 JVM 在新生代都采用了复制算法，因为在新生代中每次进行垃圾回收时都有大量的对象被回收，需要复制的对象（存活的对象）较少，不存在大量的对象在内存中被来回复制的问题，因此采用复制算法能安全、高效地回收新生代大量的短生命周期的对象并释放内存。</p>
<p>JVM 将新生代进一步划分为一块较大的 Eden 区和两块较小的 Servivor区，Servivor区 又分为 ServivorFrom区 和ServivorTo区。JVM在运行过程中主要使用 Eden区 和 ServivorFrom区，进行垃圾回收时会将在Eden区和ServivorFrom区 中存活的对象复制到 ServivorTo区，然后清理 Eden区 和 ServivorFrom区 的内存空间，如图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230227171308184.png" alt="image-20230227171308184"></p>
<p>老年代主要存放生命周期较长的对象和大对象，因而每次只有少量非存活的对象被回收，因而在老年代采用标记清除算法。</p>
<p>在 JVM 中还有一个区域，即方法区的永久代，永久代用来存储 Class类、常量、方法描述等。在永久代主要回收废弃的常量和无用的类。</p>
<p>JVM 内存中的对象主要被分配到新生代的 Eden区 和 ServivorFrom区，在少数情况下会被直接分配到老年代。在新生代的 Eden区 和 ServivorFrom区 的内存空间不足时会触发一次 GC，该过程被称为 MinorGC。在 MinorGC 后，在Eden区 和 ServivorFrom区 中存活的对象会被复制到 ServivorTo区，然后 Eden区 和 ServivorFrom区 被清理。如果此时在 ServivorTo区 无法找到连续的内存空间存储某个对象，则将这个对象直接存储到老年代。若 Servivor区 的对象经过一次GC后仍然存活，则其年龄加1。在默认情况下，对象在年龄达到15时，将被移到老年代。</p>
<h2 id="6、Java-中的4种引用类型"><a href="#6、Java-中的4种引用类型" class="headerlink" title="6、Java 中的4种引用类型"></a>6、Java 中的4种引用类型</h2><p>在 Java 中一切皆对象，对象的操作是通过该对象的引用（Reference）实现的，Java 中的引用类型有4种，分别为<code>强引用</code>、<code>软引用</code>、<code>弱引用</code>和<code>虚引用</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230228105942165.png" alt="image-20230228105942165"></p>
<ol>
<li>强引用：在 Java 中最常见的就是强引用。在把一个对象赋给一个引用变量时，这个引用变量就是一个强引用。有强引用的对象一定为可达性状态，所以不会被垃圾回收机制回收。因此，强引用是造成 Java 内存泄漏（Memory Link）的主要原因。</li>
<li>软引用：软引用通过 SoftReference 类实现。如果一个对象只有软引用，则在系统内存空间不足时该对象将被回收。</li>
<li>弱引用：弱引用通过 WeakReference 类实现，如果一个对象只有弱引用，则在垃圾回收过程中一定会被回收。</li>
<li>虚引用：虚引用通过 PhantomReference 类实现，虚引用和引用队列联合使用，主要用于跟踪对象的垃圾回收状态。</li>
</ol>
<h2 id="7、分代收集算法和分区收集算法"><a href="#7、分代收集算法和分区收集算法" class="headerlink" title="7、分代收集算法和分区收集算法"></a>7、分代收集算法和分区收集算法</h2><h3 id="7-1、分代收集算法"><a href="#7-1、分代收集算法" class="headerlink" title="7.1、分代收集算法"></a>7.1、分代收集算法</h3><p>JVM 根据对象存活周期的不同将内存划分为新生代、老年代和永久代，并根据各年代的特点分别采用不同的 GC 算法。</p>
<h4 id="新生代与复制算法"><a href="#新生代与复制算法" class="headerlink" title="新生代与复制算法"></a>新生代与复制算法</h4><p>新生代主要存储短生命周期的对象，因此在垃圾回收的标记阶段会标记大量已死亡的对象及少量存活的对象，因此只需选用复制算法将少量存活的对象复制到内存的另一端并清理原区域的内存即可。</p>
<h4 id="老年代与标记整理算法"><a href="#老年代与标记整理算法" class="headerlink" title="老年代与标记整理算法"></a>老年代与标记整理算法</h4><p>老年代主要存放长生命周期的对象和大对象，可回收的对象一般较少，因此 JVM 采用标记整理算法进行垃圾回收，直接释放死亡状态的对象所占用的内存空间即可。</p>
<h3 id="7-2、分区收集算法分区算法"><a href="#7-2、分区收集算法分区算法" class="headerlink" title="7.2、分区收集算法分区算法"></a>7.2、分区收集算法分区算法</h3><p>将整个堆空间划分为连续的大小不同的小区域，对每个小区域都单独进行内存使用和垃圾回收，这样做的好处是可以根据每个小区域内存的大小灵活使用和释放内存。</p>
<p>分区收集算法可以根据系统可接受的停顿时间，每次都快速回收若干个小区域的内存，以缩短垃圾回收时系统停顿的时间，最后以多次并行累加的方式逐步完成整个内存区域的垃圾回收。如果垃圾回收机制一次回收整个堆内存，则需要更长的系统停顿时间，长时间的系统停顿将影响系统运行的稳定性。</p>
<h2 id="8、垃圾收集器"><a href="#8、垃圾收集器" class="headerlink" title="8、垃圾收集器"></a>8、垃圾收集器</h2><p>Java 堆内存分为新生代和老年代：新生代主要存储短生命周期的对象，适合使用复制算法进行垃圾回收；老年代主要存储长生命周期的对象，适合使用标记整理算法进行垃圾回收。因此，JVM 针对新生代和老年代分别提供了多种不同的垃圾收集器，针对新生代提供的垃圾收集器有 Serial、ParNew、Parallel Scavenge，针对老年代提供的垃圾收集器有 Serial Old、Parallel Old、CMS，还有针对不同区域的 G1 分区收集算法，如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230228110954705.png" alt="image-20230228110954705"></p>
<h3 id="8-1、Serial-垃圾收集器：单线程，复制算法"><a href="#8-1、Serial-垃圾收集器：单线程，复制算法" class="headerlink" title="8.1、Serial 垃圾收集器：单线程，复制算法"></a>8.1、Serial 垃圾收集器：单线程，复制算法</h3><p>Serial 垃圾收集器基于复制算法实现，它是一个单线程收集器，在它正在进行垃圾收集时，必须暂停其他所有工作线程，直到垃圾收集结束。</p>
<p>Serial 垃圾收集器采用了复制算法，简单、高效，对于单 CPU 运行环境来说，没有线程交互开销，可以获得最高的单线程垃圾收集效率，因此 Serial 垃圾收集器是 Java 虚拟机运行在 Client 模式下的新生代的默认垃圾收集器。</p>
<h3 id="8-2、ParNew-垃圾收集器：多线程，复制算法"><a href="#8-2、ParNew-垃圾收集器：多线程，复制算法" class="headerlink" title="8.2、ParNew 垃圾收集器：多线程，复制算法"></a>8.2、ParNew 垃圾收集器：多线程，复制算法</h3><p>ParNew 垃圾收集器是 Serial 垃圾收集器的多线程实现，同样采用了复制算法，它采用多线程模式工作，除此之外和Serial 收集器几乎一样。ParNew 垃圾收集器在垃圾收集过程中会暂停所有其他工作线程，是 Java 虚拟机运行在Server 模式下的新生代的默认垃圾收集器。</p>
<p>ParNew 垃圾收集器默认开启与 CPU 同等数量的线程进行垃圾回收，在 Java 应用启动时可通过                   -XX:ParallelGCThreads 参数调节 ParNew 垃圾收集器的工作线程数。</p>
<h3 id="8-3、Parallel-Scavenge-垃圾收集器：多线程，复制算法"><a href="#8-3、Parallel-Scavenge-垃圾收集器：多线程，复制算法" class="headerlink" title="8.3、Parallel Scavenge 垃圾收集器：多线程，复制算法"></a>8.3、Parallel Scavenge 垃圾收集器：多线程，复制算法</h3><p>Parallel Scavenge 收集器是为提高新生代垃圾收集效率而设计的垃圾收集器，基于多线程复制算法实现，在系统吞吐量上有很大的优化，可以更高效地利用 CPU 尽快完成垃圾回收任务。Parallel Scavenge 通过自适应调节策略提高系统吞吐量，提供了三个参数用于调节、控制垃圾回收的停顿时间及吞吐量，分别是控制最大垃圾收集停顿时间的             -XX:MaxGCPauseMillis 参数，控制吞吐量大小的 -XX:GCTimeRatio 参数和控制自适应调节策略开启与否的UseAdaptiveSizePolicy 参数。</p>
<h3 id="8-4、Serial-Old-垃圾收集器：单线程，标记整理算法"><a href="#8-4、Serial-Old-垃圾收集器：单线程，标记整理算法" class="headerlink" title="8.4、Serial Old 垃圾收集器：单线程，标记整理算法"></a>8.4、Serial Old 垃圾收集器：单线程，标记整理算法</h3><p>Serial Old 垃圾收集器是 Serial 垃圾收集器的老年代实现，同 Serial 一样采用单线程执行，不同的是，Serial Old 针对老年代长生命周期的特点基于标记整理算法实现。Serial Old 垃圾收集器是 JVM 运行在 Client 模式下的老年代的默认垃圾收集器。新生代的 Serial 垃圾收集器和老年代的 Serial Old 垃圾收集器可搭配使用，分别针对 JVM 的新生代和老年代进行垃圾回收，其垃圾收集过程如图所示。在新生代采用 Serial 垃圾收集器基于复制算法进行垃圾回收，未被其回收的对象在老年代被 Serial Old 垃圾收集器基于标记整理算法进行垃圾回收。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230228111926459.png" alt="image-20230228111926459"></p>
<h3 id="8-5、Parallel-Old-垃圾收集器：多线程，标记整理算法"><a href="#8-5、Parallel-Old-垃圾收集器：多线程，标记整理算法" class="headerlink" title="8.5、Parallel Old 垃圾收集器：多线程，标记整理算法"></a>8.5、Parallel Old 垃圾收集器：多线程，标记整理算法</h3><p>Parallel Old 垃圾收集器采用多线程并发进行垃圾回收，它根据老年代长生命周期的特点，基于多线程的标记整理算法实现。Parallel Old 垃圾收集器在设计上优先考虑系统吞吐量，其次考虑停顿时间等因素，如果系统对吞吐量的要求较高，则可以优先考虑新生代的 Parallel Scavenge 垃圾收集器和老年代的 Parallel Old 垃圾收集器的配合使用。</p>
<p>新生代的 Parallel Scavenge 垃圾收集器和老年代的 Parallel Old 垃圾收集器的搭配运行过程如图所示。新生代基于 Parallel Scavenge 垃圾收集器的复制算法进行垃圾回收，老年代基于 Parallel Old 垃圾收集器的标记整理算法进行垃圾回收。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230228113146702.png" alt="image-20230228113146702"></p>
<h3 id="8-6、CMS-垃圾收集器"><a href="#8-6、CMS-垃圾收集器" class="headerlink" title="8.6、CMS 垃圾收集器"></a>8.6、CMS 垃圾收集器</h3><p>CMS（Concurrent Mark Sweep）垃圾收集器是为老年代设计的垃圾收集器，其主要目的是达到最短的垃圾回收停顿时间，基于线程的标记清除算法实现，以便在多线程并发环境下以最短的垃圾收集停顿时间提高系统的稳定性。</p>
<p>CMS 的工作机制相对复杂，垃圾回收过程包含如下4个步骤：</p>
<ol>
<li>初始标记：只标记和 GC Roots 直接关联的对象，速度很快，需要暂停所有工作线程。</li>
<li>并发标记：和用户线程一起工作，执行 GC Roots 跟踪标记过程，不需要暂停工作线程。</li>
<li>重新标记：在并发标记过程中用户线程继续运行，导致在垃圾回收过程中部分对象的状态发生变化，为了确保这部分对象的状态正确性，需要对其重新标记并暂停工作线程。</li>
<li>并发清除：和用户线程一起工作，执行清除 GC Roots 不可达对象的任务，不需要暂停工作线程。</li>
</ol>
<p>CMS 垃圾收集器在和用户线程一起工作时（并发标记和并发清除）不需要暂停用户线程，有效缩短了垃圾回收时系统的停顿时间，同时由于 CMS 垃圾收集器和用户线程一起工作，因此其并行度和效率也有很大提升。CMS 收集器的工作流程如图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230228113333866.png" alt="image-20230228113333866"></p>
<h3 id="8-7、G1-垃圾收集器"><a href="#8-7、G1-垃圾收集器" class="headerlink" title="8.7、G1 垃圾收集器"></a>8.7、G1 垃圾收集器</h3><p>G1（Garbage First）垃圾收集器为了避免全区域垃圾收集引起的系统停顿，将堆内存划分为大小固定的几个独立区域，独立使用这些区域的内存资源并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，在垃圾回收过程中根据系统允许的最长垃圾收集时间，优先回收垃圾最多的区域。G1 垃圾收集器通过内存区域独立划分使用和根据不同优先级回收各区域垃圾的机制，确保了 G1 垃圾收集器在有限时间内获得最高的垃圾收集效率。相对于 CMS 收集器，G1 垃圾收集器两个突出的改进。</p>
<ul>
<li>基于标记整理算法，不产生内存碎片。</li>
<li>可以精确地控制停顿时间，在不牺牲吞吐量的前提下实现短停顿垃圾回收。</li>
</ul>
<h2 id="9、-Java-网络编程模型"><a href="#9、-Java-网络编程模型" class="headerlink" title="9、 Java 网络编程模型"></a>9、 Java 网络编程模型</h2><h3 id="9-1、阻塞I-x2F-O模型"><a href="#9-1、阻塞I-x2F-O模型" class="headerlink" title="9.1、阻塞I&#x2F;O模型"></a>9.1、阻塞I&#x2F;O模型</h3><p>阻塞I&#x2F;O模型是常见的I&#x2F;O模型，在读写数据时客户端会发生阻塞。阻塞I&#x2F;O模型的工作流程为：在用户线程发出I&#x2F;O请求之后，内核会检查数据是否就绪，此时用户线程一直阻塞等待内存数据就绪；在内存数据就绪后，内核将数据复制到用户线程中，并返回I&#x2F;O执行结果到用户线程，此时用户线程将解除阻塞状态并开始处理数据。典型的阻塞I&#x2F;O模型的例子为 data &#x3D; socket.read()，如果内核数据没有就绪，Socket 线程就会一直阻塞在 read() 中等待内核数据就绪。</p>
<h3 id="9-2、非阻塞I-x2F-O模型"><a href="#9-2、非阻塞I-x2F-O模型" class="headerlink" title="9.2、非阻塞I&#x2F;O模型"></a>9.2、非阻塞I&#x2F;O模型</h3><p>非阻塞I&#x2F;O模型指用户线程在发起一个I&#x2F;O操作后，无须阻塞便可以马上得到内核返回的一个结果。如果内核返回的结果为false，则表示内核数据还没准备好，需要稍后再发起I&#x2F;O操作。一旦内核中的数据准备好了，并且再次收到用户线程的请求，内核就会立刻将数据复制到用户线程中并将复制的结果通知用户线程。</p>
<p>在非阻塞I&#x2F;O模型中，用户线程需要不断询问内核数据是否就绪，在内存数据还未就绪时，用户线程可以处理其他任务，在内核数据就绪后可立即获取数据并进行相应的操作。典型的非阻塞I&#x2F;O模型一般如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  data  =  socket.read();</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">true</span>)&#123;<span class="comment">//1：内核数据就绪</span></span><br><span class="line">      <span class="comment">//获取并处理内核数据</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;   <span class="comment">//2：内核数据未就绪，用户线程处理其他任务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3、多路复用I-x2F-O模型"><a href="#9-3、多路复用I-x2F-O模型" class="headerlink" title="9.3、多路复用I&#x2F;O模型"></a>9.3、多路复用I&#x2F;O模型</h3><p>多路复用I&#x2F;O模型是多线程并发编程用得较多的模型，Java NIO 就是基于多路复用I&#x2F;O模型实现的。在多路复用I&#x2F;O模型中会有一个被称为 Selector 的线程不断轮询多个 Socket 的状态，只有在 Socket 有读写事件时，才会通知用户线程进行I&#x2F;O读写操作。</p>
<p>因为在多路复用I&#x2F;O模型中只需一个线程就可以管理多个 Socket（阻塞I&#x2F;O模型和非阻塞1&#x2F;O模型需要为每个 Socket 都建立一个单独的线程处理该 Socket 上的数据），并且在真正有 Socket 读写事件时才会使用操作系统的I&#x2F;O资源，大大节约了系统资源。</p>
<p>Java NIO 在用户的每个线程中都通过 selector.select() 查询当前通道是否有事件到达，如果没有，则用户线程会一直阻塞。而多路复用I&#x2F;O模型通过一个线程管理多个 Socket 通道，在 Socket 有读写事件触发时才会通知用户线程进行I&#x2F;O读写操作。因此，多路复用I&#x2F;O模型在连接数众多且消息体不大的情况下有很大的优势。尤其在物联网领域比如车载设备实时位置、智能家电状态等定时上报状态且字节数较少的情况下优势更加明显，一般一个经过优化后的16核32GB服务器能承载约10万台设备连接。</p>
<p>非阻塞I&#x2F;O模型在每个用户线程中都进行 Socket 状态检查，而在多路复用I&#x2F;O模型中是在系统内核中进行 Socket 状态检查的，这也是多路复用I&#x2F;O模型比非阻塞I&#x2F;O模型效率高的原因。</p>
<p>多路复用I&#x2F;O模型通过在一个 Selector 线程上以轮询方式检测在多个 Socket 上是否有事件到达，并逐个进行事件处理和响应。因此，对于多路复用I&#x2F;O模型来说，在事件响应体（消息体）很大时，Selector 线程就会成为性能瓶颈，导致后续的事件迟迟得不到处理，影响下一轮的事件轮询。在实际应用中，在多路复用方法体内一般不建议做复杂逻辑运算，只做数据的接收和转发，将具体的业务操作转发给后面的业务线程处理。</p>
<h3 id="9-4、信号驱动I-x2F-O模型"><a href="#9-4、信号驱动I-x2F-O模型" class="headerlink" title="9.4、信号驱动I&#x2F;O模型"></a>9.4、信号驱动I&#x2F;O模型</h3><p>在信号驱动I&#x2F;O模型中，在用户线程发起一个I&#x2F;O请求操作时，系统会为该请求对应的 Socket 注册一个信号函数，然后用户线程可以继续执行其他业务逻辑；在内核数据就绪时，系统会发送一个信号到用户线程，用户线程在接收到该信号后，会在信号函数中调用对应的I&#x2F;O读写操作完成实际的I&#x2F;O请求操作。</p>
<h3 id="9-5、异步I-x2F-O模型"><a href="#9-5、异步I-x2F-O模型" class="headerlink" title="9.5、异步I&#x2F;O模型"></a>9.5、异步I&#x2F;O模型</h3><p>在异步I&#x2F;O模型中，用户线程会发起一个 asynchronous read 操作到内核，内核在接收到 synchronous read 请求后会立刻返回一个状态，来说明请求是否成功发起，在此过程中用户线程不会发生任何阻塞。接着，内核会等待数据准备完成并将数据复制到用户线程中，在数据复制完成后内核会发送一个信号到用户线程，通知用户线程 asynchronous 读操作已完成。在异步I&#x2F;O模型中，用户线程不需要关心整个I&#x2F;O操作是如何进行的，只需发起一个请求，在接收到内核返回的成功或失败信号时说明I&#x2F;O操作已经完成，直接使用数据即可。</p>
<p>在异步I&#x2F;O模型中，I&#x2F;O操作的两个阶段（请求的发起、数据的读取）都是在内核中自动完成的，最终发送一个信号告知用户线程I&#x2F;O操作已经完成，用户直接使用内存写好的数据即可，不需要再次调用I&#x2F;O函数进行具体的读写操作，因此在整个过程中用户线程不会发生阻塞。</p>
<p>在信号驱动模型中，用户线程接收到信号便表示数据已经就绪，需要用户线程调用I&#x2F;O函数进行实际的I&#x2F;O读写操作，将数据读取到用户线程；而在异步I&#x2F;O模型中，用户线程接收到信号便表示I&#x2F;O操作已经完成（数据已经被复制到用户线程），用户可以开始使用该数据了。</p>
<p>异步I&#x2F;O需要操作系统的底层支持，在 Java 7中提供了 Asynchronous I&#x2F;O操作。</p>
<h3 id="9-6、Java-I-x2F-O"><a href="#9-6、Java-I-x2F-O" class="headerlink" title="9.6、Java I&#x2F;O"></a>9.6、Java I&#x2F;O</h3><p>在整个 Java.io 包中最重要的是5个类和1个接口。5个类指的是 File、OutputStream、InputStream、Writer、Reader,1个接口指的是Serializable。具体的使用方法请参考JDK API。</p>
<h3 id="9-7、-Java-NIO"><a href="#9-7、-Java-NIO" class="headerlink" title="9.7、 Java NIO"></a>9.7、 Java NIO</h3><p>Java NIO 的实现主要涉及三大核心内容：<code>Selector（选择器）</code>、<code>Channel（通道）</code>和<code>Buffer（缓冲区）</code>。Selector 用于监听多个Channel 的事件，比如连接打开或数据到达，因此，一个线程可以实现对多个数据 Channel 的管理。传统I&#x2F;O基于数据流进行I&#x2F;O读写操作；而Java NIO 基于 Channel 和 Buffer 进行I&#x2F;O读写操作，并且数据总是被从 Channel 读取到 Buffer 中，或者从 Buffer 写入 Channel中。</p>
<p>Java NIO 和 传统I&#x2F;O 的最大区别如下:</p>
<ol>
<li>I&#x2F;O是<code>面向流</code>的，NIO是<code>面向缓冲区</code>的：在面向流的操作中，数据只能在一个流中连续进行读写，数据没有缓冲，因此字节流无法前后移动。而在 NIO 中每次都是将数据从一个 Channel 读取到一个 Buffer 中，再从 Buffer 写入 Channel 中，因此可以方便地在缓冲区中进行数据的前后移动等操作。该功能在应用层主要用于数据的粘包、拆包等操作，在网络不可靠的环境下尤为重要。</li>
<li>传统I&#x2F;O的流操作是<code>阻塞模式</code>的，NIO的流操作是<code>非阻塞模式</code>的。在传统I&#x2F;O下，用户线程在调用 read() 或 write() 进行I&#x2F;O读写操作时，该线程将一直被阻塞，直到数据被读取或数据完全写入。NIO 通过 Selector 监听 Channel 上事件的变化，在 Channel 上有数据发生变化时通知该线程进行读写操作。对于读请求而言，在通道上有可用的数据时，线程将进行 Buffer 的读操作，在没有数据时，线程可以执行其他业务逻辑操作。对于写操作而言，在使用一个线程执行写操作将一些数据写入某通道时，只需将 Channel 上的数据异步写入 Buffer 即可，Buffer 上的数据会被异步写入目标 Channel 上，用户线程不需要等待整个数据完全被写入目标 Channel 就可以继续执行其他业务逻辑。</li>
</ol>
<p>非阻塞I&#x2F;O模型中的 Selector 线程通常将I&#x2F;O的空闲时间用于执行其他通道上的I&#x2F;O操作，所以一个 Selector 线程可以管理多个输入和输出通道，如图所示:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230228130413022.png" alt="image-20230228130413022"></p>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>Channel 和 I&#x2F;O中的 Stream（流） 类似，只不过 Stream 是单向的（例如 InputStream、OutputStream），而 Channel 是双向的，既可以用来进行读操作，也可以用来进行写操作。</p>
<p>NIO 中 Channel的主要实现有：FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel，分别对应文件的I&#x2F;O、UDP、TCP I&#x2F;O、Socket Client和Socker Server操作。</p>
<h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><p>Buffer 实际上是一个容器，其内部通过一个连续的字节数组存储I&#x2F;O上的数据。在 NIO 中，Channel 在文件、网络上对数据的读取或写入都必须经过Buffer。如图所示，客户端在向服务端发送数据时，必须先将数据写入 Buffer 中，然后将 Buffer 中的数据写到服务端对应的 Channel 上。服务端在接收数据时必须通过 Channel 将数据读入 Buffer 中，然后从 Buffer 中读取数据并处理。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230228130631720.png" alt="image-20230228130631720"></p>
<p>在 NIO 中，Buffer 是一个抽象类，对不同的数据类型实现不同的 Buffer 操作。常用的 Buffer 实现类有：ByteBuffer、IntBuffer、CharBuffer、LongBuffer、DoubleBuffer、FloatBuffer、ShortBuffer。</p>
<h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p>Selector 用于检测在多个注册的 Channel 上是否有I&#x2F;O事件发生，并对检测到的I&#x2F;O事件进行相应的响应和处理。因此通过一个 Selector 线程就可以实现对多个 Channel 的管理，不必为每个连接都创建一个线程，避免线程资源的浪费和多线程之间的上下文切换导致的开销。同时，Selector 只有在 Channel 上有读写事件发生时，才会调用I&#x2F;O函数进行读写操作，可极大减少系统开销，提高系统的并发量。</p>
<h4 id="Java-NIO使用"><a href="#Java-NIO使用" class="headerlink" title="Java NIO使用"></a>Java NIO使用</h4><p>要实现 Java NIO，就需要分别实现 Server 和 Client。具体的 Server 实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">MyServer</span>  &#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span>  <span class="variable">size</span>  <span class="operator">=</span>  <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span>  ServerSocketChannel  serverSocketChannel;</span><br><span class="line">    <span class="keyword">private</span>  ByteBuffer  byteBuffer;</span><br><span class="line">    <span class="keyword">private</span>  Selector  selector;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span>  <span class="variable">remoteClientNum</span>  <span class="operator">=</span>  <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">MyServer</span><span class="params">(<span class="type">int</span>  port)</span>  &#123;</span><br><span class="line">      <span class="keyword">try</span>  &#123;</span><br><span class="line">          <span class="comment">//在构造函数中初始化Channel监听</span></span><br><span class="line">          initChannel(port);</span><br><span class="line">      &#125;  <span class="keyword">catch</span>  (IOException  e)  &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          System.exit(-<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Channel的初始化</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title function_">initChannel</span><span class="params">(<span class="type">int</span>  port)</span>  <span class="keyword">throws</span>  IOException  &#123;</span><br><span class="line">      <span class="comment">//打开Channel</span></span><br><span class="line">      serverSocketChannel  =  ServerSocketChannel.open();</span><br><span class="line">      <span class="comment">//设置为非阻塞模式</span></span><br><span class="line">      serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">      <span class="comment">//绑定端口</span></span><br><span class="line">      serverSocketChannel.bind(<span class="keyword">new</span>  <span class="title class_">InetSocketAddress</span>(port));</span><br><span class="line">      System.out.println(<span class="string">&quot;listener  on  port:  &quot;</span>  +  port);</span><br><span class="line">      <span class="comment">//选择器的创建</span></span><br><span class="line">      selector  =  Selector.open();</span><br><span class="line">      <span class="comment">//向选择器注册通道</span></span><br><span class="line">      serverSocketChannel.register(selector,  SelectionKey.OP_ACCEPT);</span><br><span class="line">      <span class="comment">//分配缓冲区的大小</span></span><br><span class="line">      byteBuffer  =  ByteBuffer.allocate(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听器，用于监听Channel上的数据变化</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">void</span>  <span class="title function_">listener</span><span class="params">()</span>  <span class="keyword">throws</span>  Exception  &#123;</span><br><span class="line">      <span class="keyword">while</span>  (<span class="literal">true</span>)  &#123;</span><br><span class="line">          <span class="comment">//返回的int值表示有多少个Channel处于就绪状态</span></span><br><span class="line">          <span class="type">int</span>  <span class="variable">n</span>  <span class="operator">=</span>  selector.select();</span><br><span class="line">          <span class="keyword">if</span>  (n  ==  <span class="number">0</span>)  &#123;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//每个selector对应多个SelectionKey，每个SelectionKey对应一个Channel</span></span><br><span class="line">          Iterator&lt;SelectionKey&gt;  iterator  =</span><br><span class="line">                                    selector.selectedKeys().iterator();</span><br><span class="line">          <span class="keyword">while</span>  (iterator.hasNext())  &#123;</span><br><span class="line">              <span class="type">SelectionKey</span>  <span class="variable">key</span>  <span class="operator">=</span>  iterator.next();</span><br><span class="line">              <span class="comment">//如果SelectionKey处于连接就绪状态，则开始接收客户端的连接</span></span><br><span class="line">              <span class="keyword">if</span>  (key.isAcceptable())  &#123;</span><br><span class="line">                <span class="comment">//获取Channel</span></span><br><span class="line">            <span class="type">ServerSocketChannel</span>  <span class="variable">server</span> <span class="operator">=</span>  (ServerSocketChannel) key.channel();</span><br><span class="line">                <span class="comment">//Channel接收连接</span></span><br><span class="line">                <span class="type">SocketChannel</span>  <span class="variable">channel</span>  <span class="operator">=</span>  server.accept();</span><br><span class="line">                <span class="comment">//Channel注册</span></span><br><span class="line">                registerChannel(selector,  channel,  SelectionKey.OP_READ);</span><br><span class="line">                <span class="comment">//远程客户端的连接数</span></span><br><span class="line">                remoteClientNum++;</span><br><span class="line">                System.out.println(<span class="string">&quot;online  client  num=&quot;</span>+remoteClientNum);</span><br><span class="line">                write(channel, <span class="string">&quot;hello  client&quot;</span>.getBytes());</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//如果通道已经处于读就绪状态</span></span><br><span class="line">              <span class="keyword">if</span>  (key.isReadable())  &#123;</span><br><span class="line">                read(key);</span><br><span class="line">              &#125;</span><br><span class="line">              iterator.remove();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">void</span>  <span class="title function_">read</span><span class="params">(SelectionKey  key)</span>  <span class="keyword">throws</span>  IOException  &#123;</span><br><span class="line">      <span class="type">SocketChannel</span>  <span class="variable">socketChannel</span>  <span class="operator">=</span>  (SocketChannel)  key.channel();</span><br><span class="line">      <span class="type">int</span>  count;</span><br><span class="line">      byteBuffer.clear();</span><br><span class="line">      <span class="comment">//从通道中读数据到缓冲区</span></span><br><span class="line">      <span class="keyword">while</span>  ((count  =  socketChannel.read(byteBuffer))  &gt;  <span class="number">0</span>)  &#123;</span><br><span class="line">          <span class="comment">//byteBuffer写模式变为读模式</span></span><br><span class="line">          byteBuffer.flip();</span><br><span class="line">          <span class="keyword">while</span>  (byteBuffer.hasRemaining())  &#123;</span><br><span class="line">              System.out.print((<span class="type">char</span>)byteBuffer.get());</span><br><span class="line">          &#125;</span><br><span class="line">          byteBuffer.clear();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>  (count  &lt;  <span class="number">0</span>)  &#123;</span><br><span class="line">          socketChannel.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">void</span>  <span class="title function_">write</span><span class="params">(SocketChannel  channel, <span class="type">byte</span>[]  writeData)</span>  <span class="keyword">throws</span> IOException  &#123;</span><br><span class="line">      byteBuffer.clear();</span><br><span class="line">      byteBuffer.put(writeData);</span><br><span class="line">      <span class="comment">//byteBuffer从写模式变成读模式</span></span><br><span class="line">      byteBuffer.flip();</span><br><span class="line">      <span class="comment">//将缓冲区的数据写入通道中</span></span><br><span class="line">      channel.write(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">void</span>  <span class="title function_">registerChannel</span><span class="params">(Selector  selector,  SocketChannel  channel, <span class="type">int</span>  opRead)</span>  <span class="keyword">throws</span>  IOException  &#123;</span><br><span class="line">      <span class="keyword">if</span>  (channel  ==  <span class="literal">null</span>)  &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">      channel.register(selector,  opRead);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[]  args)</span>  &#123;</span><br><span class="line">      <span class="keyword">try</span>  &#123;</span><br><span class="line">          <span class="type">MyServer</span>  <span class="variable">myServer</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">MyServer</span>(<span class="number">9999</span>);</span><br><span class="line">          myServer.listener();</span><br><span class="line">      &#125;  <span class="keyword">catch</span>  (Exception  e)  &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中定义了名为 MyServer 的服务端实现类，在该类中定义了 serverSocketChannel 用于 ServerSocketChannel 的建立和端口的绑定；byteBuffer 用于不同 Channel 之间的数据交互；selector 用于监听服务器各个 Channel 上数据的变化并做出响应。同时，在类构造函数中调用了初始化 ServerSocketChannel 的操作，定义了 listener 方法来监听 Channel 上的数据变化，解析客户端的数据并对客户端的请求做出响应。</p>
<p>具体的 Client 实现代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">MyClient</span>  &#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span>  <span class="variable">size</span>  <span class="operator">=</span>  <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span>  ByteBuffer  byteBuffer;</span><br><span class="line">    <span class="keyword">private</span>  SocketChannel  socketChannel;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title function_">connectServer</span><span class="params">()</span>  <span class="keyword">throws</span>  IOException  &#123;</span><br><span class="line">      socketChannel  =  socketChannel.open();</span><br><span class="line">      socketChannel.connect(<span class="keyword">new</span>  <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>,  <span class="number">9999</span>));</span><br><span class="line">      socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">      byteBuffer  =  ByteBuffer.allocate(size);</span><br><span class="line">      receive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">void</span>  <span class="title function_">receive</span><span class="params">()</span>  <span class="keyword">throws</span>  IOException  &#123;</span><br><span class="line">      <span class="keyword">while</span>  (<span class="literal">true</span>)  &#123;</span><br><span class="line">          byteBuffer.clear();</span><br><span class="line">          <span class="type">int</span>  count;</span><br><span class="line">          <span class="comment">//如果没有数据可读，则read方法一直阻塞，直到读取到新的数据</span></span><br><span class="line">          <span class="keyword">while</span>  ((count  =  socketChannel.read(byteBuffer))  &gt;  <span class="number">0</span>)  &#123;</span><br><span class="line">              byteBuffer.flip();</span><br><span class="line">              <span class="keyword">while</span>  (byteBuffer.hasRemaining())  &#123;</span><br><span class="line">                  System.out.print((<span class="type">char</span>)byteBuffer.get());</span><br><span class="line">              &#125;</span><br><span class="line">              send2Server(<span class="string">&quot;say  hi&quot;</span>.getBytes());</span><br><span class="line">              byteBuffer.clear();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">void</span>  <span class="title function_">send2Server</span><span class="params">(<span class="type">byte</span>[]  bytes)</span>  <span class="keyword">throws</span>  IOException  &#123;</span><br><span class="line">      byteBuffer.clear();</span><br><span class="line">      byteBuffer.put(bytes);</span><br><span class="line">      byteBuffer.flip();</span><br><span class="line">      socketChannel.write(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[]  args)</span>  <span class="keyword">throws</span>  IOException  &#123;</span><br><span class="line">      <span class="keyword">new</span>  <span class="title class_">MyClient</span>().connectServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中定义了 MyClient 类来实现客户端的 Channel 逻辑，其中，connectServer 方法用于和服务端建立连接，receive 方法用于接收服务端发来的数据，send2Server 用于向服务端发送数据。</p>
<h2 id="10、JVM-的类加载机制"><a href="#10、JVM-的类加载机制" class="headerlink" title="10、JVM 的类加载机制"></a>10、JVM 的类加载机制</h2><h3 id="10-1、JVM的类加载阶段"><a href="#10-1、JVM的类加载阶段" class="headerlink" title="10.1、JVM的类加载阶段"></a>10.1、JVM的类加载阶段</h3><p>JVM 的类加载阶段 JVM 的类加载分为5个阶段：加载、验证、准备、解析、初始化。在类初始化完成后就可以使用该类的信息，在一个类不再被需要时可以从 JVM 中卸载，如图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230228113609180.png" alt="image-20230228113609180"></p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>指 JVM 读取 Class 文件，并且根据 Class 文件描述创建 java.lang.Class 对象的过程。类加载过程主要包含将Class 文件读取到运行时区域的方法区内，在堆中创建 java.lang.Class 对象，并封装类在方法区的数据结构的过程，在读取 Class 文件时既可以通过文件的形式读取，也可以通过 jar 包、war 包读取，还可以通过代理自动生成 Class 或其他方式读取。</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>主要用于确保 Class 文件符合当前虚拟机的要求，保障虚拟机自身的安全，只有通过验证的 Class 文件才能被 JVM 加载。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>主要工作是在方法区中为类变量分配内存空间并设置类中变量的初始值。初始值指不同数据类型的默认值，这里需要注意final 类型的变量和非 final 类型的变量在准备阶段的数据初始化过程不同。比如一个成员变量的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，静态变量 value 在准备阶段的初始值是0，将 value 设置为1000的动作是在对象初始化时完成的，因为JVM 在编译阶段会将静态变量的初始化操作定义在构造器中。但是，如果将变量value声明为 final 类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>则 JVM 在编译阶段后会为 final 类型的变量 value 生成其对应的 ConstantValue 属性，虚拟机在准备阶段会根据ConstantValue 属性将 valu e赋值为1000。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>JVM 会将常量池中的符号引用替换为直接引用。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>主要通过执行类构造器的 <client> 方法为类进行初始化。<client> 方法是在编译阶段由编译器自动收集类中静态语句块和变量的赋值操作组成的。JVM 规定，只有在父类的 <client> 方法都执行成功后，子类中的 <client> 方法才可以被执行。在一个类中既没有静态变量赋值操作也没有静态语句块时，编译器不会为该类生成 <client> 方法。</p>
<p>在发生以下几种情况时，JVM不会执行类的初始化流程：</p>
<ul>
<li>常量在编译时会将其常量值存入使用该常量的类的常量池中，该过程不需要调用常量所在的类，因此不会触发该常量类的初始化。</li>
<li>在子类引用父类的静态字段时，不会触发子类的初始化，只会触发父类的初始化。</li>
<li>定义对象数组，不会触发该类的初始化。</li>
<li>在使用类名获取 Class 对象时不会触发类的初始化。</li>
<li>在使用 Class.forName 加载指定的类时，可以通过 initialize 参数设置是否需要对类进行初始化。</li>
<li>在使用 ClassLoader 默认的 oadClass 方法加载类时不会触发该类的初始化。</li>
</ul>
<h3 id="10-2、类加载器"><a href="#10-2、类加载器" class="headerlink" title="10.2、类加载器"></a>10.2、类加载器</h3><p>JVM 提供了 3 种类加载器，分别是<code>启动类加载器</code>、<code>扩展类加载器</code>和<code>应用程序类加载器</code>，如图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230228114326047.png" alt="image-20230228114326047"></p>
<ul>
<li>启动类加载器：负责加载 Java_HOME&#x2F;lib 目录中的类库，或通过 -Xbootclasspath 参数指定路径中被虚拟机认可的类库。</li>
<li>扩展类加载器：负责加载 Java_HOME&#x2F;lib&#x2F;ext 目录中的类库，或通过 java.ext.dirs 系统变量加载指定路径中的类库。</li>
<li>应用程序类加载器：负责加载用户路径（classpath）上的类库。</li>
</ul>
<p>除了上述3种类加载器，我们也可以通过继承java.lang.ClassLoader 实现自定义的类加载器。</p>
<h3 id="10-3、双亲委派机制"><a href="#10-3、双亲委派机制" class="headerlink" title="10.3、双亲委派机制"></a>10.3、双亲委派机制</h3><p>JVM 通过<code>双亲委派机制</code>对类进行加载。双亲委派机制指一个类在收到类加载请求后不会尝试自己加载这个类，而是把该类加载请求向上委派给其父类去完成，其父类在接收到该类加载请求后又会将其委派给自己的父类，以此类推，这样所有的类加载请求都被向上委派到启动类加载器中。若父类加载器在接收到类加载请求后发现自己也无法加载该类（通常原因是该类的Class文件在父类的类加载路径中不存在），则父类会将该信息反馈给子类并向下委派子类加载器加载该类，直到该类被成功加载，若找不到该类，则 JVM 会抛出 ClassNotFoud 异常。</p>
<p>双亲委派类加载机制的类加载流程如下，如图所示:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/JVM/image-20230228114527216.png" alt="image-20230228114527216"></p>
<ol>
<li>将自定义加载器挂载到应用程序类加载器。</li>
<li>应用程序类加载器将类加载请求委托给扩展类加载器。</li>
<li>扩展类加载器将类加载请求委托给启动类加载器。</li>
<li>启动类加载器在加载路径下查找并加载 Class 文件，如果未找到目标 Class 文件，则交由扩展类加载器加载。</li>
<li>扩展类加载器在加载路径下查找并加载 Class 文件，如果未找到目标 Class 文件，则交由应用程序类加载器加载。</li>
<li>应用程序类加载器在加载路径下查找并加载 Class 文件，如果未找到目标 Class 文件，则交由自定义加载器加载。</li>
<li>在自定义加载器下查找并加载用户指定目录下的 Class 文件，如果在自定义加载路径下未找到目标 Class 文件，则抛出ClassNotFoud 异常。</li>
</ol>
<p>双亲委派机制的核心是保障类的<strong>唯一性</strong>和<strong>安全性</strong>。例如在加载 rt.jar 包中的 java.lang.Object 类时，无论是哪个类加载器加载这个类，最终都将类加载请求委托给启动类加载器加载，这样就保证了类加载的唯一性。如果在 JVM 中存在包名和类名相同的两个类，则该类将无法被加载，JVM 也无法完成类加载流程。</p>
<h3 id="10-4、OSGI"><a href="#10-4、OSGI" class="headerlink" title="10.4、OSGI"></a>10.4、OSGI</h3><p>OSGI（Open Service Gateway Initiative）是 Java 动态化模块化系统的一系列规范，旨在为实现 Java 程序的模块化编程提供基础条件。基于 OSGI 的程序可以实现模块级的热插拔功能，在程序升级更新时，可以只针对需要更新的程序进行停用和重新安装，极大提高了系统升级的安全性和便捷性。OSGI 提供了一种面向服务的架构，该架构为组件提供了动态发现其他组件的功能，这样无论是加入组件还是卸载组件，都能被系统的其他组件感知，以便各个组件之间能更好地协调工作。</p>
<p>OSGI 不但定义了模块化开发的规范，还定义了实现这些规范所依赖的服务与架构，市场上也有成熟的框架对其进行实现和应用，但只有部分应用适合采用 OSGI 方式，因为它为了实现动态模块，不再遵循 JVM 类加载双亲委派机制和其他 JVM 规范，在安全性上有所牺牲。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://www.haungrd.top">Huang RD</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.haungrd.top/2023/02/27/JVM/">http://www.haungrd.top/2023/02/27/JVM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.haungrd.top" target="_blank">Huang Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a><a class="post-meta__tags" href="/tags/%E5%BA%95%E5%B1%82/">底层</a></div><div class="post_share"><div class="social-share" data-image="https://www.huangrd.top/images/agentina/8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面试题整理</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">设计模式</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" title="面试题整理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-27</div><div class="title">面试题整理</div></div></a></div><div><a href="/2023/02/17/JUC/" title="JUC"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-17</div><div class="title">JUC</div></div></a></div><div><a href="/2022/11/29/GUI/" title="java GUI基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-29</div><div class="title">java GUI基础</div></div></a></div><div><a href="/2022/11/22/Netty04-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81/" title="Netty 优化与源码"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-22</div><div class="title">Netty 优化与源码</div></div></a></div><div><a href="/2023/02/11/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" title="算法总结"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-11</div><div class="title">算法总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81JVM-%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">1、JVM 的运行机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">2、多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81JVM-%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="toc-text">3、JVM 的内存区域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%EF%BC%8C%E6%97%A0%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98"><span class="toc-text">3.1、程序计数器：线程私有，无内存溢出问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%EF%BC%8C%E6%8F%8F%E8%BF%B0-Java-%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">3.2、虚拟机栈：线程私有，描述 Java 方法的执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89"><span class="toc-text">3.3、本地方法区：线程私有</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E3%80%81%E5%A0%86%EF%BC%9A%E4%B9%9F%E5%8F%AB%E4%BD%9C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB"><span class="toc-text">3.4、堆：也叫作运行时数据区，线程共享</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB"><span class="toc-text">3.5、方法区：线程共享</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81JVM-%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98"><span class="toc-text">4、JVM 的运行时内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E3%80%81%E6%96%B0%E7%94%9F%E4%BB%A3%EF%BC%9AEden%E5%8C%BA%E3%80%81ServivorTo%E5%8C%BA%E5%92%8CServivorFrom%E5%8C%BA"><span class="toc-text">4.1、新生代：Eden区、ServivorTo区和ServivorFrom区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-text">4.2、老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E3%80%81%E6%B0%B8%E4%B9%85%E4%BB%A3"><span class="toc-text">4.3、永久代</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-text">5、垃圾回收与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E3%80%81%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%9E%83%E5%9C%BE"><span class="toc-text">5.1、如何确定垃圾</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-text">可达性分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E3%80%81Java-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-text">5.2、Java 中常用的垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-text">标记清除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-text">复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-text">标记整理算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text">分代收集算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Java-%E4%B8%AD%E7%9A%844%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">6、Java 中的4种引用类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E5%92%8C%E5%88%86%E5%8C%BA%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text">7、分代收集算法和分区收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E3%80%81%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text">7.1、分代收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%8E%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-text">新生代与复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E4%B8%8E%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-text">老年代与标记整理算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%E3%80%81%E5%88%86%E5%8C%BA%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="toc-text">7.2、分区收集算法分区算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">8、垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1%E3%80%81Serial-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-text">8.1、Serial 垃圾收集器：单线程，复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2%E3%80%81ParNew-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-text">8.2、ParNew 垃圾收集器：多线程，复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3%E3%80%81Parallel-Scavenge-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-text">8.3、Parallel Scavenge 垃圾收集器：多线程，复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4%E3%80%81Serial-Old-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8C%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-text">8.4、Serial Old 垃圾收集器：单线程，标记整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5%E3%80%81Parallel-Old-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-text">8.5、Parallel Old 垃圾收集器：多线程，标记整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6%E3%80%81CMS-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">8.6、CMS 垃圾收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7%E3%80%81G1-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">8.7、G1 垃圾收集器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81-Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">9、 Java 网络编程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%E3%80%81%E9%98%BB%E5%A1%9EI-x2F-O%E6%A8%A1%E5%9E%8B"><span class="toc-text">9.1、阻塞I&#x2F;O模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9EI-x2F-O%E6%A8%A1%E5%9E%8B"><span class="toc-text">9.2、非阻塞I&#x2F;O模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3%E3%80%81%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8I-x2F-O%E6%A8%A1%E5%9E%8B"><span class="toc-text">9.3、多路复用I&#x2F;O模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4%E3%80%81%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8I-x2F-O%E6%A8%A1%E5%9E%8B"><span class="toc-text">9.4、信号驱动I&#x2F;O模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5%E3%80%81%E5%BC%82%E6%AD%A5I-x2F-O%E6%A8%A1%E5%9E%8B"><span class="toc-text">9.5、异步I&#x2F;O模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6%E3%80%81Java-I-x2F-O"><span class="toc-text">9.6、Java I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7%E3%80%81-Java-NIO"><span class="toc-text">9.7、 Java NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel"><span class="toc-text">Channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer"><span class="toc-text">Buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector"><span class="toc-text">Selector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-NIO%E4%BD%BF%E7%94%A8"><span class="toc-text">Java NIO使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81JVM-%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-text">10、JVM 的类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1%E3%80%81JVM%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-text">10.1、JVM的类加载阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-text">加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-text">验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-text">准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-text">解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">10.2、类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">10.3、双亲委派机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4%E3%80%81OSGI"><span class="toc-text">10.4、OSGI</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Huang RD</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>