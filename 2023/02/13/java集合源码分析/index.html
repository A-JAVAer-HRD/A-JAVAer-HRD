<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java 集合源码分析 | Huang Blog</title><meta name="author" content="Huang RD"><meta name="copyright" content="Huang RD"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Java 集合源码分析 个人网站 www.huangrd.top  1、ArrayListArrayList 扩容规则 1.1、概述ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。 ArrayLis">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 集合源码分析">
<meta property="og:url" content="http://www.haungrd.top/2023/02/13/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Huang Blog">
<meta property="og:description" content="Java 集合源码分析 个人网站 www.huangrd.top  1、ArrayListArrayList 扩容规则 1.1、概述ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。 ArrayLis">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.huangrd.top/images/agentina/7.jpg">
<meta property="article:published_time" content="2023-02-13T10:12:57.000Z">
<meta property="article:modified_time" content="2023-04-06T07:59:09.222Z">
<meta property="article:author" content="Huang RD">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="源码">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.huangrd.top/images/agentina/7.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.haungrd.top/2023/02/13/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 集合源码分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-06 15:59:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://getwallpapers.com/wallpaper/full/a/1/8/1057222-free-download-cool-nature-backgrounds-1920x1200-windows-10.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">62</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.huangrd.top/images/agentina/7.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Huang Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java 集合源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-13T10:12:57.000Z" title="发表于 2023-02-13 18:12:57">2023-02-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-06T07:59:09.222Z" title="更新于 2023-04-06 15:59:09">2023-04-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java 集合源码分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Java-集合源码分析"><a href="#Java-集合源码分析" class="headerlink" title="Java 集合源码分析"></a>Java 集合源码分析</h1><blockquote>
<p>个人网站</p>
<p><a target="_blank" rel="noopener" href="http://www.huangrd.top/">www.huangrd.top</a></p>
</blockquote>
<h2 id="1、ArrayList"><a href="#1、ArrayList" class="headerlink" title="1、ArrayList"></a>1、ArrayList</h2><p><code>ArrayList 扩容规则</code></p>
<h3 id="1-1、概述"><a href="#1-1、概述" class="headerlink" title="1.1、概述"></a>1.1、概述</h3><p>ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。</p>
<p>ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</p>
<p>ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较List的“快速随机访问”和“通过Iterator迭代器访问”的效率。</p>
<p>ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。</p>
<p>ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。</p>
<p>和Vector不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。</p>
<h3 id="1-2、ArrayList属性"><a href="#1-2、ArrayList属性" class="headerlink" title="1.2、ArrayList属性"></a>1.2、ArrayList属性</h3><p>ArrayList 属性主要就是当前数组长度 size，以及存放数组的对象 elementData 数组，除此之外还有一个经常用到的属性就是从 AbstractList 继承过来的 modCount 属性，代表 ArrayList 集合的修改次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, Serializable &#123;</span><br><span class="line">	<span class="comment">// 序列化id</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line">	<span class="comment">// 默认初始的容量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	<span class="comment">// 一个空对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">	<span class="comment">// 一个空对象，如果使用默认构造函数创建，则默认对象内容默认是该值</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">	<span class="comment">// 当前数据对象存放地方，当前对象不参与序列化</span></span><br><span class="line">	<span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">	<span class="comment">// 当前数组长度</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">	<span class="comment">// 数组最大长度</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> <span class="number">2147483639</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新版已经没有了 MAX_ARRAY_SIZE</p>
<h3 id="1-3、ArrayList构造函数"><a href="#1-3、ArrayList构造函数" class="headerlink" title="1.3、ArrayList构造函数"></a>1.3、ArrayList构造函数</h3><h4 id="无参构造函数"><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h4><p>如果不传入参数，则使用默认无参构建方法创建ArrayList对象，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：此时我们创建的 ArrayList 对象中的 elementData 中的长度是 0，size 是 0,当进行第一次 add 的时候，elementData 将会变成默认的长度：10.</p>
<h4 id="带int类型的构造函数"><a href="#带int类型的构造函数" class="headerlink" title="带int类型的构造函数"></a>带int类型的构造函数</h4><p>如果传入参数，则代表指定ArrayList的初始数组长度，传入参数如果是大于等于0，则使用用户的参数初始化，如果用户传入的参数小于0，则抛出异常，构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="带Collection对象的构造函数"><a href="#带Collection对象的构造函数" class="headerlink" title="带Collection对象的构造函数"></a>带Collection对象的构造函数</h4><ol>
<li>将collection对象转换成数组，然后将数组的地址的赋给elementData。</li>
<li>更新size的值，同时判断size的大小，如果是size等于0，直接将空对象EMPTY_ELEMENTDATA的地址赋给elementData</li>
<li>如果size的值大于0，判断 c 是不是 ArrayList，是的话就把 a 的地址给 elementData，不是的话通过 Arrays.copyOf() 进行深拷贝。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">            elementData = a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4、方法"><a href="#1-4、方法" class="headerlink" title="1.4、方法"></a>1.4、方法</h3><p>add的方法有两个，一个是带一个参数的，一个是带两个参数的。</p>
<h4 id="add-E-e-方法"><a href="#add-E-e-方法" class="headerlink" title="add(E e) 方法"></a>add(E e) 方法</h4><p>add主要的执行逻辑如下：</p>
<ol>
<li>确保数组已使用长度（size）加1之后足够存下 下一个数据</li>
<li>修改次数modCount 标识自增1，如果当前数组已使用长度（size）加1后的大于当前的数组长度，则调用grow方法，增长数组，grow方法会将当前数组的长度变为原来容量的1.5倍。</li>
<li>确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。</li>
<li>返回添加成功布尔值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次扩容时候，会将当前elementData数组的长度变为10</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将修改次数（modCount）自增1，判断是否需要扩充数组长度,判断条件就是用当前所需的数组最小长度与数组的长度对比，如果大于0，则增长数组长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>如果当前的数组已使用空间（size）加1之后 大于数组长度，则增大数组容量，扩大为原来的1.5倍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> arg0)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">arg1</span> <span class="operator">=</span> <span class="built_in">this</span>.elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">arg2</span> <span class="operator">=</span> arg1 + (arg1 &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (arg2 - arg0 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        arg2 = arg0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arg2 - <span class="number">2147483639</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        arg2 = hugeCapacity(arg0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.elementData = Arrays.copyOf(<span class="built_in">this</span>.elementData, arg2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add-int-index-E-element-方法"><a href="#add-int-index-E-element-方法" class="headerlink" title="add(int index, E element)方法"></a>add(int index, E element)方法</h4><p>这个方法其实和上面的add类似，该方法可以按照元素的位置，指定位置插入元素，具体的执行逻辑如下：</p>
<ol>
<li>确保数插入的位置小于等于当前数组长度，并且不小于0，否则抛出异常</li>
<li>确保数组已使用长度（size）加1之后足够存下 下一个数据</li>
<li>修改次数（modCount）标识自增1，如果当前数组已使用长度（size）加1后的大于当前的数组长度，则调用grow方法，增长数组</li>
<li>grow方法会将当前数组的长度变为原来容量的1.5倍。</li>
<li>确保有足够的容量之后，使用System.arraycopy 将需要插入的位置（index）后面的元素统统往后移动一位。</li>
<li>将新的数据内容存放到数组的指定位置（index）上</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"> </span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：使用该方法的话将导致指定位置后面的数组元素全部重新移动，即往后移动一位。</p>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><p>返回指定位置上的元素，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">return</span> ArrayList.<span class="built_in">this</span>.elementData(offset + index);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h4 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h4><p>确保set的位置小于当前数组的长度（size）并且大于0，获取指定位置（index）元素，然后放到oldValue存放，将需要设置的元素放到指定的位置（index）上，然后将原来位置上的元素oldValue返回给用户。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"> </span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="contains方法"><a href="#contains方法" class="headerlink" title="contains方法"></a>contains方法</h4><p>调用indexOf方法，遍历数组中的每一个元素作对比，如果找到对于的元素，则返回true，没有找到则返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h4><p>根据索引remove</p>
<ol>
<li><p>判断索引有没有越界</p>
</li>
<li><p>自增修改次数</p>
</li>
<li><p>将指定位置（index）上的元素保存到oldValue</p>
</li>
<li><p>将指定位置（index）上的元素都往前移动一位</p>
</li>
<li><p>将最后面的一个元素置空，好让垃圾回收器回收</p>
</li>
<li><p>将原来的值oldValue返回</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"> </span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：调用这个方法不会缩减数组的长度，只是将最后一个数组元素置空而已。</p>
<p>根据对象remove</p>
<p>循环遍历所有对象，得到对象所在索引位置，然后调用fastRemove方法，执行remove操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定位到需要remove的元素索引，先将index后面的元素往前面移动一位（调用System.arraycooy实现），然后将最后一个元素置空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="clear方法"><a href="#clear方法" class="headerlink" title="clear方法"></a>clear方法</h4><p>添加操作次数（modCount），将数组内的元素都置空，等待垃圾收集器收集，不减小数组容量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sublist方法"><a href="#sublist方法" class="headerlink" title="sublist方法"></a>sublist方法</h4><p>我们看到代码中是创建了一个ArrayList 类里面的一个内部类SubList对象，传入的值中第一个参数时this参数，其实可以理解为返回当前list的部分视图，真实指向的存放数据内容的地方还是同一个地方，如果修改了sublist返回的内容的话，那么原来的list也会变动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> arg0, <span class="type">int</span> arg1)</span> &#123;</span><br><span class="line">	subListRangeCheck(arg0, arg1, <span class="built_in">this</span>.size);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>.SubList(<span class="built_in">this</span>, <span class="number">0</span>, arg0, arg1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="trimToSize方法"><a href="#trimToSize方法" class="headerlink" title="trimToSize方法"></a>trimToSize方法</h4><ol>
<li>修改次数加1</li>
<li>将elementData中空余的空间（包括null值）去除，例如：数组长度为10，其中只有前三个元素有值，其他为空，那么调用该方法之后，数组的长度变为3.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">            ? EMPTY_ELEMENTDATA</span><br><span class="line">            : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="iterator方法"><a href="#iterator方法" class="headerlink" title="iterator方法"></a>iterator方法</h4><p>interator方法返回的是一个内部类，由于内部类的创建默认含有外部的this指针，所以这个内部类可以调用到外部类的属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般的话，调用完iterator之后，我们会使用iterator做遍历，这里使用next做遍历的时候有个需要注意的地方，就是调用next的时候，可能会引发ConcurrentModificationException，当修改次数，与期望的修改次数（调用iterator方法时候的修改次数）不一致的时候，会发生该异常，详细我们看一下代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>expectedModCount 这个值是在用户调用 ArrayList 的 iterator 方法时候确定的，但是在这之后用户 add，或者remove 了 ArrayList 的元素，那么 modCount 就会改变，那么这个值就会不相等，将会引发ConcurrentModificationException 异常，这个是在多线程使用情况下，比较常见的一个异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="System-arraycopy-方法"><a href="#System-arraycopy-方法" class="headerlink" title="System.arraycopy 方法"></a>System.arraycopy 方法</h4><p>参数	说明<br>src	原数组<br>srcPos	原数组<br>dest	目标数组<br>destPos	目标数组的起始位置<br>length	要复制的数组元素的数目</p>
<h4 id="Arrays-copyOf方法"><a href="#Arrays-copyOf方法" class="headerlink" title="Arrays.copyOf方法"></a>Arrays.copyOf方法</h4><p>original - 要复制的数组<br>newLength - 要返回的副本的长度<br>newType - 要返回的副本的类型</p>
<p>其实Arrays.copyOf底层也是调用System.arraycopy实现的源码如下：</p>
<p>&#x2F;&#x2F;基本数据类型（其他类似byte，short···）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyOf(<span class="type">int</span>[] original, <span class="type">int</span> newLength) &#123;</span><br><span class="line">    <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[newLength];</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结<br>ArrayList总体来说比较简单，不过ArrayList还有以下一些特点：</p>
<ul>
<li>ArrayList自己实现了序列化和反序列化的方法，因为它自己实现了 private void writeObject(java.io.ObjectOutputStream s)和 private void readObject(java.io.ObjectInputStream s) 方法</li>
<li>ArrayList基于数组方式实现，无容量的限制（会扩容）</li>
<li>添加元素时可能要扩容（所以最好预判一下），删除元素时不会减少容量（若希望减少容量，trimToSize()），<strong>删除元素时，将删除掉的位置元素置为null，下次gc就会回收这些元素所占的内存空间。</strong></li>
<li>线程不安全</li>
<li>add(int index, E element)：添加元素到数组中指定位置的时候，需要将该位置及其后边所有的元素都整块向后复制一位</li>
<li>get(int index)：获取指定位置上的元素时，可以通过索引直接获取（O(1)）</li>
<li>remove(Object o)需要遍历数组</li>
<li>remove(int index)不需要遍历数组，只需判断index是否符合条件即可，效率比remove(Object o)高</li>
<li>contains(E)需要遍历数组</li>
<li>使用iterator遍历可能会引发多线程异常</li>
</ul>
<p><strong>扩容规则</strong></p>
<ol>
<li><p>ArrayList() 会使用长度为零的数组</p>
</li>
<li><p>ArrayList(int initialCapacity) 会使用指定容量的数组</p>
</li>
<li><p>public ArrayList(Collection&lt;? extends E&gt; c) 会使用 c 的大小作为数组容量</p>
</li>
<li><p>add(Object o) 首次扩容为 10，再次扩容为上次容量的 1.5 倍</p>
</li>
<li><p>addAll(Collection c) 没有元素时，扩容为 Math.max(10, 实际元素个数)，有元素时为 Math.max(原容量 1.5 倍, 实际元素个数)</p>
</li>
</ol>
<p>其中第 4 点必须知道，其它几点视个人情况而定</p>
<p><strong>提示</strong></p>
<ul>
<li>测试代码见 <code>day01.list.TestArrayList</code> ，这里不再列出</li>
<li>要<strong>注意</strong>的是，示例中用反射方式来更直观地反映 ArrayList 的扩容特征，但从 JDK 9 由于模块化的影响，对反射做了较多限制，需要在运行测试代码时添加 VM 参数 <code>--add-opens java.base/java.util=ALL-UNNAMED</code> 方能运行通过，后面的例子都有相同问题</li>
</ul>
<blockquote>
<p><em><strong>代码说明</strong></em></p>
<ul>
<li>TestArrayList#arrayListGrowRule 演示了 add(Object) 方法的扩容规则，输入参数 n 代表打印多少次扩容后的数组长度</li>
</ul>
</blockquote>
<h2 id="2、Iterator"><a href="#2、Iterator" class="headerlink" title="2、Iterator"></a>2、Iterator</h2><p>迭代器是一种设计模式，迭代器模式提供了一种方法来顺序访问一个聚合对象的各个元素，而不保留对象内部的表示。</p>
<p><strong>要求</strong></p>
<ul>
<li>掌握什么是 Fail-Fast、什么是 Fail-Safe</li>
</ul>
<p>Fail-Fast 与 Fail-Safe</p>
<p>fail-fast 一旦发现遍历的同时其它人来修改，则立刻抛异常</p>
<p>fail-safe 发现遍历的同时其它人来修改，应当能有应对策略，例如牺牲一致性来让整个遍历运行完成</p>
<ul>
<li><p>ArrayList 是 fail-fast 的典型代表，遍历的同时不能修改，尽快失败，通过比较当前的 modCount 和 迭代器的 modCount，不同的话抛出 ConcurrentModificationException。</p>
</li>
<li><p>CopyOnWriteArrayList 是 fail-safe 的典型代表，遍历的同时可以修改，原理是读写分离。CopyOnWriteArrayList  在写入的时候，是通过新建数组，把之前的数组通过 copyOf() 的方式拷贝过来，实现读写分离。</p>
</li>
</ul>
<h2 id="3、LinkedList"><a href="#3、LinkedList" class="headerlink" title="3、LinkedList"></a>3、LinkedList</h2><blockquote>
<p><strong>数据结构、查询更改的效率、内存</strong>来分析</p>
</blockquote>
<p><strong>LinkedList</strong></p>
<ol>
<li>基于双向链表，无需连续内存</li>
<li>随机访问慢（要沿着链表遍历）</li>
<li>头尾插入删除性能高，其他插入速度不一定比 ArrayList 快。</li>
<li>占用内存多</li>
</ol>
<p><strong>ArrayList</strong></p>
<ol>
<li>基于数组，需要连续内存</li>
<li>随机访问快（指根据下标访问）</li>
<li>尾部插入、删除性能可以，其它部分插入、删除都会移动数据，因此性能会低</li>
<li>可以利用 cpu 缓存，局部性原理</li>
</ol>
<h2 id="5、HashMap"><a href="#5、HashMap" class="headerlink" title="5、HashMap"></a>5、HashMap</h2><p><strong>要求</strong></p>
<ul>
<li>掌握 HashMap 的基本数据结构</li>
<li>掌握树化</li>
<li>理解索引计算方法、二次 hash 的意义、容量对索引计算的影响</li>
<li>掌握 put 流程、扩容、扩容因子</li>
<li>理解并发使用 HashMap 可能导致的问题</li>
<li>理解 key 的设计</li>
</ul>
<h3 id="1）基本数据结构"><a href="#1）基本数据结构" class="headerlink" title="1）基本数据结构"></a>1）基本数据结构</h3><ul>
<li>1.7 数组 + 链表</li>
<li>1.8 数组 + （链表 | 红黑树）</li>
</ul>
<blockquote>
<p>更形象的演示，见资料中的 hash-demo.jar，运行需要 jdk14 以上环境，进入 jar 包目录，执行下面命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar --add-exports java.base/jdk.internal.misc=ALL-UNNAMED hash-demo.jar</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2）树化与退化"><a href="#2）树化与退化" class="headerlink" title="2）树化与退化"></a>2）树化与退化</h3><p><strong>树化意义</strong></p>
<ul>
<li>红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略</li>
<li>hash 表的查找，更新的时间复杂度是 O(1)，而红黑树的查找，更新的时间复杂度是 O(log_2⁡n )，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表</li>
<li>hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小</li>
</ul>
<p><strong>树化规则</strong></p>
<ul>
<li>当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 &gt;&#x3D;64，才会进行树化</li>
</ul>
<p><strong>退化规则</strong></p>
<ul>
<li>情况1：在扩容时如果拆分树时，树元素个数 &lt;&#x3D; 6 则会退化链表</li>
<li>情况2：remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表</li>
</ul>
<h3 id="3）索引计算"><a href="#3）索引计算" class="headerlink" title="3）索引计算"></a>3）索引计算</h3><p><strong>索引计算方法</strong></p>
<ul>
<li>首先，计算对象的 hashCode()</li>
<li>再进行调用 HashMap 的 hash() 方法进行二次哈希<ul>
<li>二次 hash() 是为了综合高位数据，让哈希分布更为均匀</li>
</ul>
</li>
<li>最后 &amp; (capacity – 1) 得到索引</li>
</ul>
<p><strong>数组容量为何是 2 的 n 次幂</strong></p>
<ol>
<li>计算索引时效率更高：如果是 2 的 n 次幂可以使用位与运算代替取模</li>
<li>扩容时重新计算索引效率更高： hash &amp; oldCap &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</li>
</ol>
<p><strong>注意</strong></p>
<ul>
<li>二次 hash 是为了配合 <strong>容量是 2 的 n 次幂</strong> 这一设计前提，如果 hash 表的容量不是 2 的 n 次幂，则不必二次 hash</li>
<li><strong>容量是 2 的 n 次幂</strong> 这一设计计算索引效率更好，但 hash 的分散性就不好，需要二次 hash 来作为补偿，没有采用这一设计的典型例子是 Hashtable</li>
</ul>
<h3 id="4）put-与扩容"><a href="#4）put-与扩容" class="headerlink" title="4）put 与扩容"></a>4）put 与扩容</h3><p><strong>put 流程</strong></p>
<ol>
<li>HashMap 是懒惰创建数组的，首次使用才创建数组</li>
<li>计算索引（桶下标）</li>
<li>如果桶下标还没人占用，创建 Node 占位返回</li>
<li>如果桶下标已经有人占用<ol>
<li>已经是 TreeNode 走红黑树的添加或更新逻辑</li>
<li>是普通 Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</li>
</ol>
</li>
<li>返回前检查容量是否超过阈值，一旦超过进行扩容</li>
</ol>
<p><strong>1.7 与 1.8 的区别</strong></p>
<ol>
<li>链表插入节点时，1.7 是头插法，1.8 是尾插法</li>
<li>1.7 是大于等于阈值且没有空位时才扩容，而 1.8 是大于阈值就扩容</li>
<li>1.8 在扩容计算 Node 索引时，会优化</li>
<li>扩容因子可以修改</li>
</ol>
<p><strong>扩容（加载）因子为何默认是 0.75f</strong></p>
<ol>
<li>在空间占用与查询时间之间取得较好的权衡</li>
<li>大于这个值，空间节省了，但链表就会比较长影响性能</li>
<li>小于这个值，冲突减少了，但扩容就会更频繁，空间占用也更多</li>
</ol>
<h3 id="5）并发问题"><a href="#5）并发问题" class="headerlink" title="5）并发问题"></a>5）并发问题</h3><p><strong>扩容死链（1.7 会存在）</strong></p>
<p>1.7 源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>e 和 next 都是局部变量，用来指向当前节点和下一个节点</li>
<li>线程1（绿色）的临时变量 e 和 next 刚引用了这俩节点，还未来得及移动节点，发生了线程切换，由线程2（蓝色）完成扩容和迁移</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210831084325075.png" alt="image-20210831084325075"></p>
<ul>
<li>线程2 扩容完成，由于头插法，链表顺序颠倒。但线程1 的临时变量 e 和 next 还引用了这俩节点，还要再来一遍迁移</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210831084723383.png" alt="image-20210831084723383"></p>
<ul>
<li>第一次循环<ul>
<li>循环接着线程切换前运行，注意此时 e 指向的是节点 a，next 指向的是节点 b</li>
<li>e 头插 a 节点，注意图中画了两份 a 节点，但事实上只有一个（为了不让箭头特别乱画了两份）</li>
<li>当循环结束是 e 会指向 next 也就是 b 节点</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210831084855348.png" alt="image-20210831084855348"></p>
<ul>
<li>第二次循环<ul>
<li>next 指向了节点 a</li>
<li>e 头插节点 b</li>
<li>当循环结束时，e 指向 next 也就是节点 a</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210831085329449.png" alt="image-20210831085329449"></p>
<ul>
<li>第三次循环<ul>
<li>next 指向了 null</li>
<li>e 头插节点 a，<strong>a 的 next 指向了 b</strong>（之前 a.next 一直是 null），b 的 next 指向 a，死链已成</li>
<li>当循环结束时，e 指向 next 也就是 null，因此第四次循环时会正常退出</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20210831085543224.png" alt="image-20210831085543224"></p>
<p><strong>数据错乱（1.7，1.8 都会存在）</strong></p>
<blockquote>
<p><em><strong>补充代码说明</strong></em></p>
<ul>
<li>day01.map.HashMapDistribution 演示 map 中链表长度符合泊松分布</li>
<li>day01.map.DistributionAffectedByCapacity 演示容量及 hashCode 取值对分布的影响<ul>
<li>day01.map.DistributionAffectedByCapacity#hashtableGrowRule 演示了 Hashtable 的扩容规律</li>
<li>day01.sort.Utils#randomArray 如果 hashCode 足够随机，容量是否是 2 的 n 次幂影响不大</li>
<li>day01.sort.Utils#lowSameArray 如果 hashCode 低位一样的多，容量是 2 的 n 次幂会导致分布不均匀</li>
<li>day01.sort.Utils#evenArray 如果 hashCode 偶数的多，容量是 2 的 n 次幂会导致分布不均匀</li>
<li>由此得出对于容量是 2 的 n 次幂的设计来讲，二次 hash 非常重要</li>
</ul>
</li>
<li>day01.map.HashMapVsHashtable 演示了对于同样数量的单词字符串放入 HashMap 和 Hashtable 分布上的区别</li>
</ul>
</blockquote>
<h3 id="6）key-的设计"><a href="#6）key-的设计" class="headerlink" title="6）key 的设计"></a>6）key 的设计</h3><p><strong>key 的设计要求</strong></p>
<ol>
<li>HashMap 的 key 可以为 null，但 Map 的其他实现则不然</li>
<li>作为 key 的对象，必须实现 hashCode 和 equals，并且 key 的内容不能修改（不可变）</li>
<li>key 的 hashCode 应该有良好的散列性</li>
</ol>
<p>如果 key 可变，例如修改了 age 会导致再次查询时查询不到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapMutableKey</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;Student, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        map.put(stu, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"></span><br><span class="line">        System.out.println(map.get(stu));</span><br><span class="line"></span><br><span class="line">        stu.age = <span class="number">19</span>;</span><br><span class="line">        System.out.println(map.get(stu));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">            <span class="keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>String 对象的 hashCode() 设计</strong></p>
<ul>
<li>目标是达到较为均匀的散列效果，每个字符串的 hashCode 足够独特</li>
<li>字符串中的每个字符都可以表现为一个数字，称为 Si，其中 i 的范围是 0 ~ n - 1 </li>
<li>散列公式为： S0∗31^(n-1)+ S1∗31^(n-2)+ … Si ∗ 31^(n-1-i)+ S(n-1)∗31^0</li>
<li>31 代入公式有较好的散列特性，并且 31 * h 可以被优化为 <ul>
<li>即 32 ∗h -h </li>
<li>即 2^5  ∗ h - h</li>
<li>即 h≪5  -h</li>
</ul>
</li>
</ul>
<h2 id="6、Stream-流"><a href="#6、Stream-流" class="headerlink" title="6、Stream 流"></a>6、Stream 流</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>Lambda</code>表达式，基于<code>Lambda</code>所带来的函数式编程，又引入了一个全新的Stream概念，用于解决集合类库相关的问题。</p>
<p>案例：将list集合中姓张的元素过滤到一个新的集合中，然后将过滤出来的姓张的元素中，再过滤出来长度为3的元素，存储到一个新的集合中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStream</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        将list集合中姓张的元素过滤到一个新的集合中</span></span><br><span class="line"><span class="comment">        然后将过滤出来的姓张的元素中，再过滤出来长度为3的元素，存储到一个新的集合中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已知的知识来解决需求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testNormal</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;张老三&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;张小三&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;赵五&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;张六&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;王八&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 1.将list集合中姓张的元素过滤到一个新的集合中</span></span><br><span class="line">        <span class="keyword">for</span>(String name : list1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(name.startsWith(<span class="string">&quot;张&quot;</span>))&#123;</span><br><span class="line">                list2.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : list2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">3</span>)&#123;</span><br><span class="line">                list3.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStream</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;张老三&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;张小三&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;赵五&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;张六&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;王八&quot;</span>);</span><br><span class="line"></span><br><span class="line">        list1.stream().filter(name -&gt; name.startsWith(<span class="string">&quot;张&quot;</span>)).filter(name -&gt; name.length() == <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        testNormal();</span><br><span class="line">        testStream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Stream流的常用方法：</p>
<ul>
<li>终结方法：返回值类型不再是Stream接口本身类型的方法，例如：forEach方法和count方法。</li>
<li>非终结方法&#x2F;延迟方法：返回值类型仍然是Stream接口自身类型的方法，除了终结方法都是延迟方法。例如：filter,limit,skip,map,conat</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20230406150512758.png" alt="image-20230406150512758"></p>
<h2 id="7、面试题"><a href="#7、面试题" class="headerlink" title="7、面试题"></a>7、面试题</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="List-Set-Queue-Map-四者的区别？"><a href="#List-Set-Queue-Map-四者的区别？" class="headerlink" title="List, Set, Queue, Map 四者的区别？"></a>List, Set, Queue, Map 四者的区别？</h4><ul>
<li><code>List</code>: 存储的元素是<strong>有序</strong>的、<strong>可重复</strong>的。</li>
<li><code>Set</code>: 存储的元素是<strong>无序</strong>的、<strong>不可重复</strong>的。</li>
<li><code>Queue</code>: 按特定的排队规则来确定<strong>先后顺序</strong>，存储的元素是有序的、可重复的。</li>
<li><code>Map</code>: 使用键值对（<strong>key-value</strong>）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<h4 id="List-Set-Map-在Java中对应哪些实现类？底层的数据结构是什么？"><a href="#List-Set-Map-在Java中对应哪些实现类？底层的数据结构是什么？" class="headerlink" title="List, Set, Map 在Java中对应哪些实现类？底层的数据结构是什么？"></a>List, Set, Map 在Java中对应哪些实现类？底层的数据结构是什么？</h4><p><strong>List</strong>:</p>
<ul>
<li>ArrayList 数组</li>
<li>LinkedList 双向链表(1.6为循环链表)</li>
<li>Vector 数组</li>
</ul>
<p><strong>Set</strong>:</p>
<ul>
<li>HashSet 基于HashMap</li>
<li>LinkedHashSet 基于 LinkedHashMap</li>
<li>TreeSet 红黑树</li>
</ul>
<p><strong>Queue</strong>:</p>
<ul>
<li>PriorityQueue 数组实现的大&#x2F;小根堆</li>
<li>ArrayQueue 数组</li>
</ul>
<p><strong>Map</strong>:</p>
<ul>
<li>HashMap 数组+链表+红黑树(1.7 数组+链表)</li>
<li>LinkedHashMap 数组 + 链表 + 双向链表 (可以保证顺序性)</li>
<li>Hashtable 数组 + 链表</li>
<li>TreeMap 红黑树</li>
</ul>
<h4 id="有哪些集合是线程不安全的？怎么解决呢？"><a href="#有哪些集合是线程不安全的？怎么解决呢？" class="headerlink" title="有哪些集合是线程不安全的？怎么解决呢？"></a>有哪些集合是线程不安全的？怎么解决呢？</h4><p>Java 中的 ArrayList、HashSet、HashMap 等集合类都是线程不安全的。</p>
<ul>
<li>Arraylist –&gt; Vector 、CopyOnWriteArrayList</li>
<li>HashMap –&gt; HashTable、ConcurrentHashMap</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="Arraylist-和-Vector-的区别"><a href="#Arraylist-和-Vector-的区别" class="headerlink" title="Arraylist 和 Vector 的区别?"></a>Arraylist 和 Vector 的区别?</h4><ul>
<li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li>
<li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用 <code>Object[ ]</code>存储，线程安全的。Vector 是给每个可能出现线程不安全的操作都加了 <code>synchronized</code>。</li>
<li><code>ArrayList</code> 在底层数组不够用时在原来的基础上扩展<code>0.5</code>倍，<code>Vector</code> 是扩展 <code>1</code> 倍。</li>
</ul>
<h4 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h4><ol>
<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>
<li><strong>插入和删除是否受元素位置的影响：</strong><ul>
<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。</li>
<li><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</li>
</ul>
</li>
<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong> <code>ArrayList</code> 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ol>
<h4 id="ArrayList-扩容机制"><a href="#ArrayList-扩容机制" class="headerlink" title="ArrayList 扩容机制"></a>ArrayList 扩容机制</h4><ul>
<li><code>ArrayList</code> 的默认初始化容量是 <code>0</code>，在添加第一个元素时才真正将容量赋值为 <code>10</code>.</li>
<li><code>ArrayList</code> 的扩容主要发生在向 <code>ArrayList</code> 集合中添加元素的时候，通过add ()方法添加单个元素时，会先检查容量，看是否需要扩容。 如果容量不足需要扩容则调用grow ()扩容方法，扩容后的大小等于扩容前大小的1.5倍。</li>
</ul>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h4><ul>
<li><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</li>
<li><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</li>
<li><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</li>
<li><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法。</li>
</ul>
<h4 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h4><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能.</p>
<p><strong>区别</strong>：</p>
<ul>
<li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li>
<li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li>
<li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈</p>
<h4 id="PriorityQueue-的特点"><a href="#PriorityQueue-的特点" class="headerlink" title="PriorityQueue 的特点"></a>PriorityQueue 的特点</h4><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>
<p>这里列举其相关的一些要点：</p>
<ul>
<li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>
<li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>
<li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>
<li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>
</ul>
<p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="HashMap-查询，删除的时间复杂度"><a href="#HashMap-查询，删除的时间复杂度" class="headerlink" title="HashMap 查询，删除的时间复杂度"></a>HashMap 查询，删除的时间复杂度</h4><p><strong>没有冲突</strong>：</p>
<ul>
<li>查询：O(1)</li>
<li>删除：O(1)</li>
</ul>
<p><strong>链表</strong>：</p>
<ul>
<li>查询：O(N)</li>
<li>删除：O(N)</li>
</ul>
<p><strong>红黑树</strong>：</p>
<ul>
<li>查询：O(log N)</li>
<li>删除：O(log N)</li>
</ul>
<h4 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h4><p>1.7 数组 + 链表</p>
<p>1.8 数组 + 链表 + 红黑树，当链表长度大于阈值（默认为 <code>8</code>）（将链表转换成红黑树前会判断，如果当前数组的长度小于 <code>64</code>，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<h4 id="HashMap-的长度为什么是-2-的-n-次幂？"><a href="#HashMap-的长度为什么是-2-的-n-次幂？" class="headerlink" title="HashMap 的长度为什么是 2 的 n 次幂？"></a>HashMap 的长度为什么是 2 的 n 次幂？</h4><p>HashMap 计算 hashCode后，要映射到数组中，需要对数组的长度进行取模。为了加快运算，当数组长度为2的n次幂时，取模可以变为<code>hash%length==hash&amp;(length-1)</code>，加快运算速度。</p>
<h4 id="HashMap-和-LinkedHashMap-和-TreeMap-区别"><a href="#HashMap-和-LinkedHashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 LinkedHashMap 和 TreeMap 区别"></a>HashMap 和 LinkedHashMap 和 TreeMap 区别</h4><blockquote>
<p>LinkedHashMap 可以做到让 key 保持有序</p>
<p>TreeMap 可以根据 key 进行排序</p>
</blockquote>
<p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/treemap_hierarchy.png" alt="TreeMap 继承关系图"></p>
<p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p>
<p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p>
<p>HashMap、LinkedHashMap 和 TreeMap 都是 Java 中的 Map 接口的实现类，它们都可以用于存储键值对。</p>
<ul>
<li>HashMap 是基于哈希表实现的，平均时间复杂度为 O(1)；</li>
<li>LinkedHashMap 是基于双向链表和哈希表实现的，它保留了插入顺序，平均时间复杂度为 O(1)；</li>
<li>TreeMap 是基于红黑树实现的，它按照键的自然顺序或者自定义顺序进行排序，平均时间复杂度为 O(log n)。</li>
</ul>
<h4 id="HashMap-和-Hashtable-的区别？HashMap-和-HashSet-区别？HashMap-和-TreeMap-区别？"><a href="#HashMap-和-Hashtable-的区别？HashMap-和-HashSet-区别？HashMap-和-TreeMap-区别？" class="headerlink" title="HashMap 和 Hashtable 的区别？HashMap 和 HashSet 区别？HashMap 和 TreeMap 区别？"></a>HashMap 和 Hashtable 的区别？HashMap 和 HashSet 区别？HashMap 和 TreeMap 区别？</h4><p>HashMap 和 Hashtable 的区别在于，<code>Hashtable</code> 是<strong>线程安全</strong>的，而 HashMap 则非线程安全。Hashtable 的实现方法里面都添加了 <code>synchronized</code> 关键字来确保线程同步，因此相对而言 HashMap 性能会高一些。我们平时使用时若无特殊需求建议使用 HashMap，在多线程环境下若使用 Hashtable 可以避免出现线程不安全的情况。</p>
<p>HashSet 和 HashMap 的区别在于，HashSet 实现了 Set 接口，仅存储对象；HashMap 实现了 Map 接口，存储的是键值对。<strong>HashSet 底层其实是用 HashMap 实现存储的</strong>，HashSet 封装了一系列 HashMap 的方法。</p>
<p>HashMap 和 TreeMap 的区别在于，HashMap 是基于哈希表实现的，平均时间复杂度为 O(1)；TreeMap 是基于红黑树实现的，它按照键的自然顺序或者自定义顺序进行排序，平均时间复杂度为 O(log n)。</p>
<h4 id="ConcurrentHashMap-和-Hashtable-的区别？"><a href="#ConcurrentHashMap-和-Hashtable-的区别？" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别？"></a>ConcurrentHashMap 和 Hashtable 的区别？</h4><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表&#x2F;红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li>实现线程安全的方式（重要）：<ul>
<li>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li>
<li>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>
<li><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
</li>
</ul>
<h4 id="ConcurrentHashMap-线程安全的具体实现方式-x2F-底层具体实现"><a href="#ConcurrentHashMap-线程安全的具体实现方式-x2F-底层具体实现" class="headerlink" title="ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现"></a>ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</h4><p><strong>JDK1.8</strong> 之前</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java7_concurrenthashmap.png" alt="Java7 ConcurrentHashMap 存储结构"></p>
<p>首先将数据分为一段一段（这个“段”就是 <code>Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p>
<p><code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组，<code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>。 <code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。</p>
<p><code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p>
<p><strong>JDK1.8 之后</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构"></p>
<p>Java 8 几乎完全重写了 <code>ConcurrentHashMap</code>，代码量从原来 Java 7 中的 1000 多行，变成了现在的 6000 多行。</p>
<p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code> 1.8 的结构类似，数组+链表&#x2F;红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</p>
<p>Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</p>
<h4 id="JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？"><a href="#JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？" class="headerlink" title="JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？"></a>JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h4><ul>
<li><strong>线程安全实现方式</strong> ：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</li>
<li><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</li>
<li><strong>并发度</strong> ：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li>
</ul>
<blockquote>
<p>参考资料</p>
<ul>
<li>Java guide Java集合</li>
<li>黑马程序员</li>
<li><a target="_blank" rel="noopener" href="http://www.huangrd.top/">www.huangrd.top</a></li>
<li>CSDN肥兄 <a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_60489526/article/details/119984236">https://blog.csdn.net/m0_60489526/article/details/119984236</a></li>
</ul>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://www.haungrd.top">Huang RD</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.haungrd.top/2023/02/13/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">http://www.haungrd.top/2023/02/13/java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.haungrd.top" target="_blank">Huang Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81/">源码</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://www.huangrd.top/images/agentina/7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/15/%E6%95%B0%E6%8D%AE%E5%BA%93/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据库</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/11/%E8%AE%A1%E7%BD%91%E8%80%83%E8%AF%95/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/12.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计网考试</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/07/JavaSE%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/" title="JavaSE 复习提升"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-07</div><div class="title">JavaSE 复习提升</div></div></a></div><div><a href="/2023/02/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-20</div><div class="title">设计模式</div></div></a></div><div><a href="/2023/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构篇-高级数据结构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-13</div><div class="title">数据结构篇-高级数据结构</div></div></a></div><div><a href="/2023/04/11/%E7%AE%97%E6%B3%95%E7%AF%87-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" title="算法篇-滑动窗口"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">算法篇-滑动窗口</div></div></a></div><div><a href="/2023/04/10/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/" title="算法篇-二分搜索"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-10</div><div class="title">算法篇-二分搜索</div></div></a></div><div><a href="/2023/04/11/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/" title="算法篇-双指针"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">算法篇-双指针</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">Java 集合源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81ArrayList"><span class="toc-text">1、ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">1.1、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E3%80%81ArrayList%E5%B1%9E%E6%80%A7"><span class="toc-text">1.2、ArrayList属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E3%80%81ArrayList%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">1.3、ArrayList构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">无参构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6int%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">带int类型的构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6Collection%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">带Collection对象的构造函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%E3%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">1.4、方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#add-E-e-%E6%96%B9%E6%B3%95"><span class="toc-text">add(E e) 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#add-int-index-E-element-%E6%96%B9%E6%B3%95"><span class="toc-text">add(int index, E element)方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get%E6%96%B9%E6%B3%95"><span class="toc-text">get方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E6%96%B9%E6%B3%95"><span class="toc-text">set方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#contains%E6%96%B9%E6%B3%95"><span class="toc-text">contains方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#remove%E6%96%B9%E6%B3%95"><span class="toc-text">remove方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clear%E6%96%B9%E6%B3%95"><span class="toc-text">clear方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sublist%E6%96%B9%E6%B3%95"><span class="toc-text">sublist方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#trimToSize%E6%96%B9%E6%B3%95"><span class="toc-text">trimToSize方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iterator%E6%96%B9%E6%B3%95"><span class="toc-text">iterator方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#System-arraycopy-%E6%96%B9%E6%B3%95"><span class="toc-text">System.arraycopy 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arrays-copyOf%E6%96%B9%E6%B3%95"><span class="toc-text">Arrays.copyOf方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Iterator"><span class="toc-text">2、Iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81LinkedList"><span class="toc-text">3、LinkedList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81HashMap"><span class="toc-text">5、HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">1）基本数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%89%E6%A0%91%E5%8C%96%E4%B8%8E%E9%80%80%E5%8C%96"><span class="toc-text">2）树化与退化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%89%E7%B4%A2%E5%BC%95%E8%AE%A1%E7%AE%97"><span class="toc-text">3）索引计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%89put-%E4%B8%8E%E6%89%A9%E5%AE%B9"><span class="toc-text">4）put 与扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%89%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-text">5）并发问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%89key-%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">6）key 的设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Stream-%E6%B5%81"><span class="toc-text">6、Stream 流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">7、面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#List-Set-Queue-Map-%E5%9B%9B%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">List, Set, Queue, Map 四者的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List-Set-Map-%E5%9C%A8Java%E4%B8%AD%E5%AF%B9%E5%BA%94%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%9F%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">List, Set, Map 在Java中对应哪些实现类？底层的数据结构是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%91%A2%EF%BC%9F"><span class="toc-text">有哪些集合是线程不安全的？怎么解决呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Arraylist-%E5%92%8C-Vector-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Arraylist 和 Vector 的区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arraylist-%E4%B8%8E-LinkedList-%E5%8C%BA%E5%88%AB"><span class="toc-text">Arraylist 与 LinkedList 区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-text">ArrayList 扩容机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue"><span class="toc-text">Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Queue-%E4%B8%8E-Deque-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Queue 与 Deque 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayDeque-%E4%B8%8E-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">ArrayDeque 与 LinkedList 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PriorityQueue-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">PriorityQueue 的特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-%E6%9F%A5%E8%AF%A2%EF%BC%8C%E5%88%A0%E9%99%A4%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">HashMap 查询，删除的时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">HashMap 的底层实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-2-%E7%9A%84-n-%E6%AC%A1%E5%B9%82%EF%BC%9F"><span class="toc-text">HashMap 的长度为什么是 2 的 n 次幂？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-%E5%92%8C-LinkedHashMap-%E5%92%8C-TreeMap-%E5%8C%BA%E5%88%AB"><span class="toc-text">HashMap 和 LinkedHashMap 和 TreeMap 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9FHashMap-%E5%92%8C-HashSet-%E5%8C%BA%E5%88%AB%EF%BC%9FHashMap-%E5%92%8C-TreeMap-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">HashMap 和 Hashtable 的区别？HashMap 和 HashSet 区别？HashMap 和 TreeMap 区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">ConcurrentHashMap 和 Hashtable 的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-x2F-%E5%BA%95%E5%B1%82%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-1-7-%E5%92%8C-JDK-1-8-%E7%9A%84-ConcurrentHashMap-%E5%AE%9E%E7%8E%B0%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Huang RD</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>