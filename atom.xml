<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuangRD Blog</title>
  
  <subtitle>writing blog for happy&#39;</subtitle>
  <link href="http://huangrd.top/atom.xml" rel="self"/>
  
  <link href="http://huangrd.top/"/>
  <updated>2022-11-01T16:34:09.617Z</updated>
  <id>http://huangrd.top/</id>
  
  <author>
    <name>Huang Rui Dong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nginx</title>
    <link href="http://huangrd.top/pages/uncategorized/nginx.html"/>
    <id>http://huangrd.top/pages/uncategorized/nginx.html</id>
    <published>2022-10-24T09:24:22.957Z</published>
    <updated>2022-11-01T16:34:09.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><p>反向代理服务器</p><h2 id="nginx的安装"><a href="#nginx的安装" class="headerlink" title="nginx的安装"></a>nginx的安装</h2><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>常用版本分为四大阵营</p><ul><li>Nginx开源版</li></ul><p><a href="http://nginx.org/">http://nginx.org/</a></p><ul><li>Nginx plus 商业版</li></ul><p><a href="https://www.nginx.com/">https://www.nginx.com</a></p><ul><li>openresty</li></ul><p><a href="http://openresty.org/cn/">http://openresty.org/cn/</a></p><ul><li>Tengine</li></ul><p><a href="http://tengine.taobao.org/">http://tengine.taobao.org/</a></p><h3 id="nginx相关命令"><a href="#nginx相关命令" class="headerlink" title="nginx相关命令"></a>nginx相关命令</h3><h4 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h4><p>进入安装好的目录 /usr/local/nginx/sbin</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./nginx</span> 启动</span><br><span class="line"><span class="string">./nginx</span> -s stop 快速停止</span><br><span class="line"><span class="string">./nginx</span> -s <span class="keyword">quit</span> 优雅关闭，在退出前完成已经接受的连接请求</span><br><span class="line"><span class="string">./nginx</span> -s <span class="keyword">reload</span> 重新加载配置</span><br></pre></td></tr></table></figure><h4 id="关于防火墙"><a href="#关于防火墙" class="headerlink" title="关于防火墙"></a>关于防火墙</h4><p>关闭防火墙</p><p>systemctl stop firewalld.service</p><p>禁止防火墙开机启动</p><p>systemctl disable firewalld.service</p><p>放行端口</p><p>firewall-cmd –zone=public –add-port=80/tcp –permanent</p><p>重启防火墙</p><p>firewall-cmd –reload</p><h4 id="安装成系统服务"><a href="#安装成系统服务" class="headerlink" title="安装成系统服务"></a>安装成系统服务</h4><p>重新加载系统服务</p><p>systemctl daemon-reload</p><p>启动服务</p><p>systemctl start nginx.service</p><h2 id="nginx的配置与应用场景"><a href="#nginx的配置与应用场景" class="headerlink" title="nginx的配置与应用场景"></a>nginx的配置与应用场景</h2><h3 id="最小配置"><a href="#最小配置" class="headerlink" title="最小配置"></a>最小配置</h3><p><strong>worker_processes</strong></p><p>worker_processes 1; 默认为1，表示开启一个业务进程</p><blockquote><p>一个cpu内核对应1个进程</p></blockquote><p><strong>worker_connections</strong></p><p>worker_connections 1024; 单个业务进程可接受连接数</p><p><strong>include mime.types;</strong></p><p>include mime.types; 引入http mime类型</p><blockquote><p>服务器告诉浏览器解析的类型</p></blockquote><p><strong>default_type application/octet-stream;</strong></p><p>default_type application/octet-stream; 如果mime类型没匹配上，默认使用二进制流的方式传输。</p><p><strong>sendfifile on;</strong></p><p>sendfile on; 使用linux的 sendfile(socket, file, len) 高效网络传输，也就是数据0拷贝。</p><p>未开启sendfifile</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210291608013.png" alt="image-20221029160735341"></p><p>开启后</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210291611950.png" alt="image-20221029160749909"></p><p>减少了一次读文件缓存到应用程序的过程，加快了速度。</p><p><strong>keepalive_timeout 65;</strong></p><p>keepalive_timeout 65;</p><blockquote><p>保持连接的超时时间</p></blockquote><p><strong>server</strong></p><blockquote><p>一个server代表了一个(虚拟)主机vh，</p><p>一个nginx可以有多个主机，</p><p>主机之间互不干扰</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen <span class="number">80</span>; 监听端口号</span><br><span class="line">server_name localhost; 主机名</span><br><span class="line"></span><br><span class="line"><span class="regexp">//u</span>rl:http:<span class="regexp">//</span>atguigu.com<span class="regexp">/xxoo/i</span>ndex.html</span><br><span class="line"><span class="regexp">//u</span>ri:<span class="regexp">/xxoo/i</span>ndex.html</span><br><span class="line">location / &#123; 域名后边跟的子的路径(uri资源定位符)匹配路径</span><br><span class="line">root html; 文件根目录</span><br><span class="line">index index.html index.htm; 默认页名称</span><br><span class="line">&#125;</span><br><span class="line">/<span class="number">50</span>x.html</span><br><span class="line"><span class="regexp">//</span>访问某一个资源出错，会跳转访问到该域名下的/<span class="number">50</span>x.html</span><br><span class="line">error_page <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /<span class="number">50</span>x.html; 报错编码对应页面</span><br><span class="line">location = /<span class="number">50</span>x.html &#123;</span><br><span class="line">root html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚拟主机与域名解析"><a href="#虚拟主机与域名解析" class="headerlink" title="虚拟主机与域名解析"></a>虚拟主机与域名解析</h3><h4 id="浏览器、Nginx和HTTP协议"><a href="#浏览器、Nginx和HTTP协议" class="headerlink" title="浏览器、Nginx和HTTP协议"></a>浏览器、Nginx和HTTP协议</h4><p>https数据加密，第一次传输非对称加密过的秘钥 后续传输数据通过对称加密。http+ssl</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210291625579.png" alt="image-20221029162514498"></p><h4 id="虚拟主机原理"><a href="#虚拟主机原理" class="headerlink" title="虚拟主机原理"></a>虚拟主机原理</h4><p>把一台主机虚拟出多个主机。为了防止cpu的资源浪费。一个服务器对应多个域名。</p><p>请求时，给请求头再加上域名信息，之前只有ip地址，根据不同的域名划分不同的目录，存放不同的资源。</p><h4 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h4><p>原本一台服务器只能对应一个站点，通过虚拟主机技术可以虚拟化成多个站点同时对外提供服务</p><p><strong>servername匹配规则</strong></p><p>我们需要注意的是servername匹配分先后顺序，写在前面的匹配上就不会继续往下匹配了。</p><p><strong>完整匹配</strong></p><p>我们可以在同一servername中匹配多个域名</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_name vod.mmban.com www1.mmban.com<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>通配符匹配</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">server_name</span> <span class="regexp">*.mmban.com</span></span><br></pre></td></tr></table></figure><p><strong>通配符结束匹配</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">server_name</span> <span class="regexp">vod.*</span>;</span><br></pre></td></tr></table></figure><p><strong>正则匹配</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">server_name</span> ~^[<span class="number">0</span>-<span class="number">9</span>]+\.mmban\.com$;</span><br></pre></td></tr></table></figure><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="nginx隧道式模型，网关，代理与反向代理"><a href="#nginx隧道式模型，网关，代理与反向代理" class="headerlink" title="nginx隧道式模型，网关，代理与反向代理"></a>nginx隧道式模型，网关，代理与反向代理</h3><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210311913712.png" alt="image-20221031191159745"></p><p><strong>反向代理：</strong>通过nginx把相应的请求转发给tomcat，再通过nginx把tomcat处理的结果发给用户。nginx帮我们进行用户传递。nginx和应用服务器是一组。</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210311913986.png" alt="image-20221031191226144"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210311914716.png" alt="image-20221031191401664"></p><p><strong>正向代理：</strong>用户直接通过代理服务器访问到外网。代理服务器和用户是一组。</p><blockquote><p>通过代理服务器是谁提供的，来区分正向代理和反向代理。</p></blockquote><p><strong>网关：</strong>把所有的数据分组，转发请求到下一跳。</p><p>代理服务器就是网关。</p><p>代理服务器的代宽就影响整个系统访问资源的速度。类似于路由器速度不快，但是网速快，造成整个系统速度慢，用户体验差。</p><p>nginx这种代理模式就称为<code>隧道式代理</code>。</p><h3 id="nginx反向代理在企业中的应用场景"><a href="#nginx反向代理在企业中的应用场景" class="headerlink" title="nginx反向代理在企业中的应用场景"></a>nginx反向代理在企业中的应用场景</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;nginx&quot;&gt;&lt;a href=&quot;#nginx&quot; class=&quot;headerlink&quot; title=&quot;nginx&quot;&gt;&lt;/a&gt;nginx&lt;/h1&gt;&lt;p&gt;反向代理服务器&lt;/p&gt;
&lt;h2 id=&quot;nginx的安装&quot;&gt;&lt;a href=&quot;#nginx的安装&quot; class=&quot;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法总结</title>
    <link href="http://huangrd.top/pages/uncategorized/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.html"/>
    <id>http://huangrd.top/pages/uncategorized/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.html</id>
    <published>2022-10-17T06:31:05.745Z</published>
    <updated>2022-11-01T16:33:15.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h1><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p>Binary Search</p><p>对于已经有序的数组，使用二分搜索加快搜索速度。</p><p>时间复杂度O(logN)</p><p>二分法的两种写法：</p><ul><li>左闭右闭[left,right]</li><li>左闭右开[left,right)</li></ul><h3 id="左闭右闭"><a href="#左闭右闭" class="headerlink" title="左闭右闭"></a>左闭右闭</h3><p> target 是在一个在左闭右闭的区间里，[left, right] 。</p><p>对于左闭右闭的写法：</p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><img src="https://img-blog.csdnimg.cn/20210311153055723.jpg" alt="704.二分查找" style="zoom:100%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 左闭右闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch1</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;<span class="comment">//区间[left，right]要有意义</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;<span class="comment">//注意点1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) / <span class="number">2</span>);<span class="comment">//防止溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左闭右开"><a href="#左闭右开" class="headerlink" title="左闭右开"></a>左闭右开</h3><p>定义 target 是在一个在左闭右开的区间里，也就是[left, right)。</p><p>对于左闭右开的写法：</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><p><img src="https://img-blog.csdnimg.cn/20210311153123632.jpg" alt="704.二分查找1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 左闭右开</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch2</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;<span class="comment">//区间[left,right)</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;<span class="comment">//左闭</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;<span class="comment">//右开</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LC69-x-的平方根"><a href="#LC69-x-的平方根" class="headerlink" title="LC69 x 的平方根"></a>LC69 x 的平方根</h3><p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。</p><p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去 。</strong></p><p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p><p>利用二分法的思路，在0~x-1中搜索出他的平方根，排除特例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找</span></span><br><span class="line"><span class="comment">     * [left,right)</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">//因为定义的区间为左闭右开，对于x，当x &lt; 2的时候，x才会取0 or x 即 0 1</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> x;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (mid &gt; x / mid) &#123;</span><br><span class="line">            <span class="comment">//mid &gt; x / mid防止溢出</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &lt; x / mid) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LC367-有效的完全平方数"><a href="#LC367-有效的完全平方数" class="headerlink" title="LC367 有效的完全平方数"></a>LC367 有效的完全平方数</h3><p>给定一个 <strong>正整数</strong> <code>num</code> ，编写一个函数，如果 <code>num</code> 是一个完全平方数，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>进阶：不要</strong> 使用任何内置的库函数，如 <code>sqrt</code> 。</p><p>防止越界，用long表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 二分法</span></span><br><span class="line"><span class="comment">* [left,right]左闭右闭</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> num;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) / <span class="number">2</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">square</span> <span class="operator">=</span> (<span class="type">long</span>) mid * mid;</span><br><span class="line">        <span class="keyword">if</span> (square &gt; num) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (square &lt; num) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p><h3 id="移除数组元素"><a href="#移除数组元素" class="headerlink" title="移除数组元素"></a>移除数组元素</h3><p>定义快慢指针</p><ul><li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li><li>慢指针：指向更新 新数组下标的位置</li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrds6r59g30du09mnpd.gif" alt="27.移除元素-双指针法"></p><h3 id="LC11-盛最多水的容器"><a href="#LC11-盛最多水的容器" class="headerlink" title="LC11. 盛最多水的容器"></a>LC11. 盛最多水的容器</h3><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1,8,6,2</span>,<span class="number">5,4,8,3</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">49</span> </span><br><span class="line">解释：图中垂直线代表输入数组 [<span class="number">1,8,6,2</span>,<span class="number">5,4,8,3</span>,<span class="number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="number">49</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p>面积：高*宽 min(height[left], height[right]) * (right - left)</p><ol><li><p>初始化两个指针指向两个边，这个时候宽是最大的。</p></li><li><p>当两个边向内缩小的时候,如果高是增大的话，才有可能会增大，如果高是减小的就不能增大。</p></li><li><p>因此在缩小的时候，让高尽可能变大，即缩小高小的一边。相等的话，任意。（有可能存在山峰的形状）</p></li><li><p>这样保证了在每一次选择时都是选择最大的，在遍历过程中用result记录最大值返回。</p></li></ol><p>只进行了一次遍历。<br>时间复杂度O(N)<br>空间复杂度O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双指针</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (Math.min(height[left], height[right]) * (right - left));</span><br><span class="line">            result = Math.max(sum, result);</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LC141-环形链表"><a href="#LC141-环形链表" class="headerlink" title="LC141. 环形链表"></a>LC141. 环形链表</h3><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p><p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [3,2,0,-4], pos = 1</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1,2], pos = 0</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1], pos = -1</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p><p>判断链表有没有环</p><ol><li>定义快慢指针，快指针每次走两步，慢指针每次走一步。</li><li>如果快指针先到达了null证明没有环。</li><li>如果慢指针追上快指针，则说明有环。</li><li>当快慢指针相遇后，让快指针开始每次走一步，慢指针回到原点，再次让他们相遇就是环的入口节</li><li><ol start="5"><li>数学证明</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双指针</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LC142-环形链表II"><a href="#LC142-环形链表II" class="headerlink" title="LC142. 环形链表II"></a>LC142. 环形链表II</h3><p>给定一个链表的头节点 <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">head</span> = [<span class="number">1</span>], <span class="attr">pos</span> = -<span class="number">1</span></span><br><span class="line">输出：返回 <span class="literal">null</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210181732061.png" alt="image-20221018173023802" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123; <span class="comment">//有环</span></span><br><span class="line">            slow = head;</span><br><span class="line">            <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>在遍历一个数组的过程中：</p><p>在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环完成了一个不断搜索区间的过程。</p><p>那么滑动窗口如何用一个for循环来完成这个操作呢。</p><p>首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。</p><p>如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？此时难免再次陷入 暴力解法的怪圈。</p><p>所以只用一个for循环，那么<strong>这个循环的索引，一定是表示滑动窗口的终止位置。</strong></p><p>那么问题来了， 滑动窗口的起始位置如何移动呢？</p><p>这里还是以<code>长度最小的子数组</code>中的示例来举例，s=7， 数组是 2，3，1，2，4，3，来看一下查找的过程：</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="209.长度最小的子数组"></p><p>最后找到 4，3 是最短距离。</p><p>其实从动画中可以发现<strong>滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</strong></p><p>实现滑动窗口，主要确定如下三点：</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？</li></ul><p><strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。</strong></p><h3 id="LC209-长度最小的子数组"><a href="#LC209-长度最小的子数组" class="headerlink" title="LC209. 长度最小的子数组"></a>LC209. 长度最小的子数组</h3><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p><p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = <span class="comment">[2,3,1,2,4,3]</span></span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 <span class="comment">[4,3]</span> 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">target</span> = <span class="number">4</span>, nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="number">11</span>, nums = [<span class="number">1,1,1,1</span>,<span class="number">1,1,1,1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>进阶：</strong></p><ul><li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li></ul><p>在本题中实现滑动窗口，主要确定如下三点：</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？</li></ul><p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</p><p>解题的关键在于 窗口的起始位置如何移动，如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20210312160441942.png" alt="leetcode_209"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 滑动窗口</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//滑动窗口 for i遍历的是结束的位置 j是起始的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//滑动窗口的大小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123; <span class="comment">//窗口的大小大于要求的值 起始位置向前 缩窗口</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">subLength</span> <span class="operator">=</span> i - j + <span class="number">1</span>;</span><br><span class="line">                res = Math.min(subLength, res);</span><br><span class="line">                sum -= nums[j++];<span class="comment">//就相当于之前的和减去了起始位置的值 起始位置++</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res == Integer.MAX_VALUE) &#123; <span class="comment">//数组中的和不大于target</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LC904-水果成篮"><a href="#LC904-水果成篮" class="headerlink" title="LC904. 水果成篮"></a>LC904. 水果成篮</h3><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p><p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p><ul><li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li><li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li><li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li></ul><p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：fruits </span>=<span class="string"> [1,2,1]</span></span><br><span class="line"><span class="string">输出：3</span></span><br><span class="line"><span class="string">解释：可以采摘全部 3 棵树。</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：fruits = <span class="comment">[0,1,2,2]</span></span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘 <span class="comment">[1,2,2]</span> 这三棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 <span class="comment">[0,1]</span> 这两棵树。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：fruits = <span class="comment">[1,2,3,2,2]</span></span><br><span class="line">输出：4</span><br><span class="line">解释：可以采摘 <span class="comment">[2,3,2,2]</span> 这四棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 <span class="comment">[1,2]</span> 这两棵树。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：fruits = [<span class="number">3,3,3,1</span>,<span class="number">2,1,1,2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：可以采摘 [<span class="number">1,2,1,1</span>,<span class="number">2</span>] 这五棵树。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= fruits.length &lt;= 105</code></li><li><code>0 &lt;= fruits[i] &lt; fruits.length</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 滑动窗口 + hashmap</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//返回的最多收集个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//起始位置</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);<span class="comment">//篮子</span></span><br><span class="line">        <span class="comment">//遍历终止位置i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fruits.length; i++) &#123;</span><br><span class="line">            map.put(fruits[i], map.getOrDefault(fruits[i], <span class="number">0</span>) + <span class="number">1</span>);<span class="comment">//利用map不含重复元素</span></span><br><span class="line">            <span class="keyword">while</span> (map.size() &gt; <span class="number">2</span>) &#123;<span class="comment">//当篮子数大于2时，缩短窗口</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(fruits[j]) - <span class="number">1</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(fruits[j]);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(fruits[j], map.get(fruits[j]) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">subLength</span> <span class="operator">=</span> i - j + <span class="number">1</span>;</span><br><span class="line">            res = Math.max(res, subLength);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宫水三叶（数组带替map）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fs)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fs.length, res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//cnts用来统计每种水果树的数量</span></span><br><span class="line">    <span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">10</span>];</span><br><span class="line">    <span class="comment">//i是窗口的右边，j是左边，tot表示当前篮子里水果的种类（至多有两种水果），也表示窗口中的水果种类数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, tot = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        cnts[fs[i]]++;</span><br><span class="line">        <span class="keyword">if</span> (cnts[fs[i]] == <span class="number">1</span>) tot++;<span class="comment">//第一次出现 篮子的种类++</span></span><br><span class="line">        <span class="comment">//当种类数量大于2时，使窗口左侧收缩，并且除去对应的水果种类在cnts中的数量</span></span><br><span class="line">        <span class="comment">//当为0时则彻底在窗口中除去该种水果</span></span><br><span class="line">        <span class="keyword">while</span> (tot &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            cnts[fs[j]]--;<span class="comment">//缩窗口</span></span><br><span class="line">            <span class="keyword">if</span> (cnts[fs[j]] == <span class="number">0</span>) tot--;<span class="comment">//篮子种类数--</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//即时比较判断窗口中水果树的数量，经过前两步窗口中的东西一定是满足题义的</span></span><br><span class="line">        res = Math.max(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LC76-最小覆盖字串"><a href="#LC76-最小覆盖字串" class="headerlink" title="LC76. 最小覆盖字串"></a>LC76. 最小覆盖字串</h3><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;ADOBECODEBANC&quot;</span>, <span class="built_in">t</span> = <span class="string">&quot;ABC&quot;</span></span><br><span class="line">输出：<span class="string">&quot;BANC&quot;</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;a&quot;</span>, <span class="built_in">t</span> = <span class="string">&quot;a&quot;</span></span><br><span class="line">输出：<span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入<span class="symbol">:</span> s = <span class="string">&quot;a&quot;</span>, <span class="built_in">t</span> = <span class="string">&quot;aa&quot;</span></span><br><span class="line">输出<span class="symbol">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">解释<span class="symbol">:</span> <span class="built_in">t</span> 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><p><strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？</p><p>Related Topics</p><p>哈希表</p><p>字符串</p><p>滑动窗口</p><p><strong>解法思路：</strong></p><ol><li>创建两个map，分别表示需要的字符sonMap及其个数和当前的字符(只统计子串含有的字符)matherMap及其个数。</li><li>利用滑动窗口的思想，遍历右指针。</li><li>右指针遍历过的字符如果有要匹配的字符，加到map中去。统计已经匹配字符的计数器。</li><li>如果已经匹配上了，更新匹配的字串，把左指针开始右移，窗口收缩，更新matherMap的数据。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="comment">//两个map,一个存放需要的字符，一个存放当前的字符</span></span><br><span class="line">    Map&lt;Character, Integer&gt; sonMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Character, Integer&gt; matherMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历匹配的字串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">cur</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">        sonMap.put(cur, sonMap.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//起始</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//终止</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">finishCount</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//计数器</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> s.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">cur</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        <span class="keyword">if</span> (sonMap.containsKey(cur)) &#123; <span class="comment">//字串中需要这个字符</span></span><br><span class="line">            matherMap.put(cur, matherMap.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 两个Integer对象比较时，不能使用 == ，要使用equals，如果使用 == ，在[-128,127]范围内正常，范围外不正常</span></span><br><span class="line">            <span class="keyword">if</span> (sonMap.get(cur).equals(matherMap.get(cur))) &#123; <span class="comment">//一项已经匹配了</span></span><br><span class="line">                finishCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">//计数器满足要求，缩小窗口</span></span><br><span class="line">        <span class="keyword">while</span> (finishCount == sonMap.size()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">leftCur</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            <span class="keyword">if</span> (matherMap.containsKey(leftCur) &amp;&amp; matherMap.get(leftCur) &gt;= sonMap.get(leftCur)) &#123;</span><br><span class="line">                <span class="comment">//记录满足条件的最小字串</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> s.substring(left, right);</span><br><span class="line">                <span class="keyword">if</span> (temp.length() &lt;= minLen) &#123;</span><br><span class="line">                    res = temp;</span><br><span class="line">                    minLen = temp.length();</span><br><span class="line">                &#125;</span><br><span class="line">                matherMap.put(leftCur, matherMap.get(leftCur) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (sonMap.get(leftCur) &gt; matherMap.get(leftCur)) &#123;</span><br><span class="line">                    finishCount--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟（螺旋矩阵）"><a href="#模拟（螺旋矩阵）" class="headerlink" title="模拟（螺旋矩阵）"></a>模拟（螺旋矩阵）</h2><p>循环不变量：在循环过程中保持不变的性质。</p><h3 id="LC54-螺旋矩阵"><a href="#LC54-螺旋矩阵" class="headerlink" title="LC54. 螺旋矩阵"></a>LC54. 螺旋矩阵</h3><p>从外部向内部逐层遍历打印矩阵，最外面一圈打印完，里面仍然是一个矩阵</p><p>统计矩阵的层数，每一层最多会占据两行或者两列，最少会占据一行或者一列元素，只有一层或者一列，也算一层，分层如下图：</p><p><img src="https://pic.leetcode-cn.com/6936cb00971072cf40e96462e782aa47563fa4b24831d72749699c8fd9af7255-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5.JPG" alt="螺旋矩阵.JPG"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261749987.jpeg" alt="螺旋矩阵1.JPG"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> (Math.min(m, n)+<span class="number">1</span>)/<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>左闭右闭</strong></p><p>开始打印第 <code>i</code> 层的矩阵元素</p><p><img src="https://pic.leetcode-cn.com/a2e0022203893856ec9baa3fa3db6b0b1e6e49b4f3955e086f437852ec88a31d-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B52.JPG" alt="螺旋矩阵2.JPG"></p><p>如上图所示，再打印第i层的矩阵时，要经历4个循环：</p><p>第 1 个：从左向右</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int j <span class="operator">=</span> i<span class="comment">; j &lt; n-i; j++) &#123;</span></span><br><span class="line">    list.add(matrix[i][j])<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 2 个：从上往下</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int <span class="keyword">j </span>= i+<span class="number">1</span><span class="comment">; j &lt; m-i; j++) &#123;</span></span><br><span class="line">    list.<span class="keyword">add(matrix[j][(n-1)-i]);</span></span><br><span class="line"><span class="keyword"></span>&#125;</span><br></pre></td></tr></table></figure><p>第 3 个：从右往左，如果这一层只有1行，那么第一个循环已经将该行打印了，这里就不需要打印了，即 <code>（m-1-i ）!= i</code></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for <span class="comment">(int j = (n-1)</span>-<span class="comment">(i+1)</span>; j &gt;= i &amp;&amp; <span class="comment">(m-1-i != i)</span>; j--) &#123;</span><br><span class="line">    list.add<span class="comment">(matrix[(m-1)</span>-i][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第4个：从下往上，如果这一层只有1列，那么第2个循环已经将该列打印了，这里不需要打印，即<code>(n-1-i) != i</code></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for <span class="comment">(int j = (m-1)</span>-<span class="comment">(i+1)</span>; j &gt;= i<span class="number">+1</span> &amp;&amp; <span class="comment">(n-1-i)</span> != i; j--) &#123;</span><br><span class="line">    list.add<span class="comment">(matrix[j][i])</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="comment">//保持左闭右开</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//循环的次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">//统计矩阵从外向内的层数，如果矩阵非空，那么它的层数至少为1层</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> (Math.min(m, n)+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; count) &#123;</span><br><span class="line">        <span class="comment">//上侧 左-&gt;右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n - i; j++) &#123;</span><br><span class="line">            res.add(matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右侧 上-&gt;下</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; m - i; j++) &#123;</span><br><span class="line">            res.add(matrix[j][(n - <span class="number">1</span>) - i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下册 右-&gt;左</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (n - <span class="number">1</span>) - (i + <span class="number">1</span>); j &gt;= i &amp;&amp; (m - <span class="number">1</span> - i != i); j--) &#123;</span><br><span class="line">            res.add(matrix[(m - <span class="number">1</span>) - i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左侧 下-&gt;上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (m - <span class="number">1</span>) - (i + <span class="number">1</span>); j &gt;= i + <span class="number">1</span> &amp;&amp; (n - <span class="number">1</span> - i) != i; j--) &#123;</span><br><span class="line">            res.add(matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LC59-螺旋矩阵II"><a href="#LC59-螺旋矩阵II" class="headerlink" title="LC59. 螺旋矩阵II"></a>LC59. 螺旋矩阵II</h3><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922102236.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//控制循环次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//每一次开始的点(start,start)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//填充的数字</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (loop++ &lt; n / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 模拟上侧从左到右</span></span><br><span class="line">        <span class="keyword">for</span> (j = start; j &lt; n - loop; j++) &#123;</span><br><span class="line">            res[start][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟右侧从上到下</span></span><br><span class="line">        <span class="keyword">for</span> (i = start; i &lt; n - loop; i++) &#123;</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟下侧从右到左</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= loop; j--) &#123;</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟左侧从下到上</span></span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= loop; i--) &#123;</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123; <span class="comment">//中间位置</span></span><br><span class="line">        res[start][start] = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指Offer29-顺时针打印矩阵"><a href="#剑指Offer29-顺时针打印矩阵" class="headerlink" title="剑指Offer29. 顺时针打印矩阵"></a>剑指Offer29. 顺时针打印矩阵</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = <span class="comment">[<span class="comment">[1,2,3]</span>,<span class="comment">[4,5,6]</span>,<span class="comment">[7,8,9]</span>]</span></span><br><span class="line">输出：<span class="comment">[1,2,3,6,9,8,7,4,5]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1,2,3,4</span>],[<span class="number">5,6,7,8</span>],[<span class="number">9,10,11,12</span>]]</span><br><span class="line">输出：[<span class="number">1,2,3,4</span>,<span class="number">8,12,11,10</span>,<span class="number">9,5,6,7</span>]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>0 &lt;= matrix.length &lt;= 100</code></li><li><code>0 &lt;= matrix[i].length &lt;= 100</code></li></ul><p>注意：本题与主站 54 题相同：<a href="https://leetcode-cn.com/problems/spiral-matrix/">https://leetcode-cn.com/problems/spiral-matrix/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] spiralOrder(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//控制循环圈数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> (Math.min(m, n) + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; loop) &#123;</span><br><span class="line">        <span class="comment">//上 从左到右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n - i; j++) &#123;</span><br><span class="line">            res.add(matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右 从上到下</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; m - i; j++) &#123;</span><br><span class="line">            res.add(matrix[j][(n - <span class="number">1</span>) - i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下 从右到左</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span> - i - <span class="number">1</span>; j &gt;= i &amp;&amp; m - <span class="number">1</span> - i != i; j--) &#123;</span><br><span class="line">            res.add(matrix[(m - <span class="number">1</span> - i)][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左 从下到上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m - <span class="number">1</span> - <span class="number">1</span> - i; j &gt;= i + <span class="number">1</span> &amp;&amp; n - <span class="number">1</span> - i != i; j--) &#123;</span><br><span class="line">            res.add(matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构篇"><a href="#数据结构篇" class="headerlink" title="数据结构篇"></a>数据结构篇</h2><h3 id="剑指-Offer05-替换空格"><a href="#剑指-Offer05-替换空格" class="headerlink" title="剑指 Offer05. 替换空格"></a>剑指 Offer05. 替换空格</h3><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><p><strong>示例 1：</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;We are happy.&quot;</span></span><br><span class="line">输出：<span class="string">&quot;We%20are%20happy.&quot;</span></span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span>&lt;= s 的长度 &lt;= <span class="number">10000</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">//StringBuilder 单线程使用，比较快</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,3,2]</span></span><br><span class="line">输出：<span class="comment">[2,3,1]</span></span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span>&lt;= 链表长度 &lt;= <span class="number">10000</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        res[count--] = cur.val;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] reversePrint2(ListNode head) &#123;</span><br><span class="line">    Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack.push(temp);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        res[i] = stack.pop().val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a>剑指 Offer 09. 用两个栈实现队列</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;CQueue&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>]</span><br><span class="line">[[],[<span class="number">3</span>],[],[],[]]</span><br><span class="line">输出：[null,null,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;CQueue&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;appendTail&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>,<span class="string">&quot;deleteHead&quot;</span>]</span><br><span class="line">[[],[],[<span class="number">5</span>],[<span class="number">2</span>],[],[]]</span><br><span class="line">输出：[null,<span class="number">-1</span>,null,null,<span class="number">5</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= values &lt;= 10000</code></li><li>最多会对<code>appendTail、deleteHead</code>进行<code> 10000</code> 次调用</li></ul><p>Related Topics</p><p>栈</p><p>设计</p><p>队列</p><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>A栈用来保持原有数据，B栈用来输出数据时对栈逆序，在B中输出队头之后再放入A栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> stack1.pop();</span><br><span class="line">                stack2.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> stack2.pop();</span><br><span class="line">            <span class="keyword">while</span> (!stack2.isEmpty()) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> stack2.pop();</span><br><span class="line">                stack1.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p><img src="https://pic.leetcode-cn.com/1599286207-HnnMhX-Picture1.png" alt="Picture1.png"></p><p>对思路一进行优化，当B栈输出完对头时不再重新放入A栈，而是保留，因为是顺序加入的，他会保留原有的顺序。</p><p>题目要求实现 加入队尾appendTail() 和 删除队首deleteHead() 两个函数的正常工作。因此，可以设计栈 A 用于加入队尾操作，栈 B 用于将元素倒序，从而实现删除队首元素。</p><p>函数设计：</p><ol><li>加入队尾 appendTail() ： 将数字 val 加入栈 A 即可。</li><li>删除队首deleteHead() ： 有以下三种情况。<ul><li>当栈 B 不为空： B中仍有已完成倒序的元素，因此直接返回 B 的栈顶元素。</li><li>否则，当 A 为空： 即两个栈都为空，无元素，因此返回 -1 。</li><li>否则： 将栈 A 元素全部转移至栈 B 中，实现元素倒序，并返回栈 B 的栈顶元素。</li></ul></li></ol><p><img src="https://pic.leetcode-cn.com/1599286207-iyRyBk-Picture2.png" alt="img"></p><p>复杂度分析：</p><blockquote><p>以下分析仅满足添加 N 个元素并删除 N 个元素，即栈初始和结束状态下都为空的情况。</p></blockquote><ul><li>时间复杂度： appendTail()函数为O(1) ；deleteHead() 函数在 N 次队首元素删除操作中总共需完成 N 个元素的倒序。</li><li>空间复杂度 O(N)O(N) ： 最差情况下，栈 A 和 B 共保存 NN 个元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack2.isEmpty()) &#123; <span class="comment">// 情况一B栈不空</span></span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack1.isEmpty()) &#123; <span class="comment">// 情况二AB都为空</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 情况三A不为空 B为空</span></span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a>剑指 Offer 24. 反转链表</h3><p>给定单链表的头节点 <code>head</code> ，请反转链表，并返回反转后的链表的头节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span></span><br><span class="line">输出：<span class="string">[5,4,3,2,1]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[1,2]</span></span><br><span class="line">输出：<span class="comment">[2,1]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>双指针</p><p><img src="https://pic.leetcode-cn.com/1604779288-jExDGV-Picture3.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代：双指针</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head, pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;<span class="comment">// 暂存后继节点 cur.next</span></span><br><span class="line">        cur.next = pre;<span class="comment">// 修改 next 引用指向</span></span><br><span class="line">        pre = cur;<span class="comment">// pre 暂存 cur</span></span><br><span class="line">        cur = temp; <span class="comment">// cur 访问下一节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代：利用栈</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (newHead != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack.push(newHead);</span><br><span class="line">        newHead = newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head = stack.pop();</span><br><span class="line">    newHead = head;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        newHead.next = stack.pop();</span><br><span class="line">        newHead = newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    newHead.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>考虑使用递归法遍历链表，当越过尾节点后终止递归，在回溯时修改各节点的 next 引用指向。</p><p><strong>recur(cur, pre) 递归函数：</strong></p><ol><li>终止条件：当 cur 为空，则返回尾节点 pre （即反转链表的头节点）；</li><li>递归后继节点，记录返回值（即反转链表的头节点）为 res ；</li><li>修改当前节点 cur 引用指向前驱节点 pre ；</li><li>返回反转链表的头节点 res ；</li></ol><p><strong>reverseList(head) 函数：</strong><br>调用并返回 recur(head, null) 。传入 null 是因为反转链表后， head 节点指向 null ；</p><p>复杂度分析：</p><ul><li>时间复杂度 O(N)O(N) ： 遍历链表使用线性大小时间。</li><li>空间复杂度 O(N)O(N) ： 遍历链表的递归深度达到 NN ，系统使用 O(N)O(N) 大小额外空间。</li></ul><p><img src="https://pic.leetcode-cn.com/1604779700-APVBqI-Picture24.png" alt="img"></p><h3 id="剑指-Offer-30-包含-min-函数的栈"><a href="#剑指-Offer-30-包含-min-函数的栈" class="headerlink" title="剑指 Offer 30. 包含 min 函数的栈"></a>剑指 Offer 30. 包含 min 函数的栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> recur(head,<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">recur</span><span class="params">(ListNode cur, ListNode pre)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123; <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> recur(cur.next, cur);<span class="comment">//递归后续节点</span></span><br><span class="line"></span><br><span class="line">    cur.next = pre;              <span class="comment">// 修改节点引用指向</span></span><br><span class="line">    <span class="keyword">return</span> res;                  <span class="comment">// 返回反转链表的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p><strong>示例:</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack <span class="operator">=</span> new MinStack()<span class="comment">;</span></span><br><span class="line">minStack.push(-<span class="number">2</span>)<span class="comment">;</span></span><br><span class="line">minStack.push(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">minStack.push(-<span class="number">3</span>)<span class="comment">;</span></span><br><span class="line">minStack.min()<span class="comment">;   --&gt; 返回 -3.</span></span><br><span class="line">minStack.pop()<span class="comment">;</span></span><br><span class="line">minStack.top()<span class="comment">;      --&gt; 返回 0.</span></span><br><span class="line">minStack.min()<span class="comment">;   --&gt; 返回 -2.</span></span><br></pre></td></tr></table></figure><p><strong>解题思路:</strong><br>普通栈的 push() 和 pop() 函数的复杂度 O(1) ；而获取栈最小值 min() 函数需要遍历整个栈，复杂度为 O(N) 。</p><p><strong>本题难点：</strong> 将 min() 函数复杂度降为=O(1) 。可借助辅助栈实现：</p><ul><li>数据栈 A ： 栈 A 用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常辑。</li><li>辅助栈 B ： 栈 B 中存储栈 A 中所有 非严格降序 元素的子序列，则栈 A 中的最小元素始终对应栈 B 的栈顶元素.此时， min() 函数只需返回栈 B 的栈顶元素即可。</li></ul><p>因此，只需设法维护好 栈 B 的元素，使其保持是栈 A 的非严格降序元素的子序列，即可实现 min() 函数的 O(1) 复杂度。</p><p><strong>函数设计：</strong><br>push(x) 函数： 重点为保持栈 B 的元素是 <strong>非严格降序</strong> 的；</p><ol><li>执行「元素 x 压入栈 A」 ；</li><li>若「栈 B 为空」或「x \leq≤ 栈 B 的栈顶元素」，则执行「元素 x 压入栈 B」 ；</li></ol><p>pop() 函数： 重点为保持栈 A , B 的 元素一致性 ；</p><ol><li>执行「栈 A 元素出栈」，将出栈元素记为 y ；</li><li>若 「y 等于栈 B 的栈顶元素」，则执行「栈 B 元素出栈」；</li></ol><p>top() 函数： 直接返回栈 A 的栈顶元素，即返回 A.peek() ；</p><p>min() 函数： 直接返回栈 B 的栈顶元素，即返回 B.peek() ；</p><p><strong>采用 “非严格” 降序原因</strong>：<br>在栈 A 具有 重复 最小值元素时，非严格降序可防止栈 B 提前弹出最小值元素，示例如下：</p><p><img src="https://pic.leetcode-cn.com/1600086305-BSfBJu-Picture2.png" alt="Picture2.png"></p><p><strong>复杂度分析：</strong><br>时间复杂度 O(1) ： push(), pop(), top(), min() 四个函数的时间复杂度均为常数级别。<br>空间复杂度 O(N) ： 当共有 N 个待入栈元素时，辅助栈 B 最差情况下存储 N 个元素，使用 O(N) 额外空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1;<span class="comment">//正常的栈序列</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2;<span class="comment">//对于A栈的元素，B栈保证数据从小到大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty() || stack2.peek() &gt;= x) &#123; <span class="comment">// 小于栈顶才入栈</span></span><br><span class="line">            stack2.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> stack1.pop();</span><br><span class="line">        <span class="keyword">if</span> (i.equals(stack2.peek())) &#123;</span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a>剑指 Offer 35. 复杂链表的复制</h3><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[<span class="comment">[7,null]</span>,<span class="comment">[13,0]</span>,<span class="comment">[11,4]</span>,<span class="comment">[10,2]</span>,<span class="comment">[1,0]</span>]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[7,null]</span>,<span class="comment">[13,0]</span>,<span class="comment">[11,4]</span>,<span class="comment">[10,2]</span>,<span class="comment">[1,0]</span>]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[[1,1],[2,1]]</span></span><br><span class="line">输出：<span class="string">[[1,1],[2,1]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" alt="img"></strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[[3,null],[3,0],[3,null]]</span></span><br><span class="line">输出：<span class="string">[[3,null],[3,0],[3,null]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br><span class="line">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure><h4 id="哈希表记录法"><a href="#哈希表记录法" class="headerlink" title="哈希表记录法"></a>哈希表记录法</h4><p>利用哈希表的查询特点，考虑构建 原链表节点 和 新链表对应节点 的键值对映射关系，再遍历构建新链表各节点的 next 和 random 引用指向即可。</p><p><strong>算法流程：</strong></p><ol><li><p>若头节点 head 为空节点，直接返回 null ；</p></li><li><p>初始化： 哈希表 dic ， 节点 cur 指向头节点；</p></li><li><p>复制链表：</p><ol><li>建立新节点，并向 dic 添加键值对 (原 cur 节点, 新 cur 节点） ；</li><li>cur 遍历至原链表下一节点；</li></ol></li><li><p>构建新链表的引用指向：</p><ol><li>构建新节点的 next 和 random 引用指向；</li><li>cur 遍历至原链表下一节点；</li></ol></li><li><p>返回值： 新链表的头节点 map.get(head) ；</p></li></ol><p><strong>复杂度分析：</strong><br>时间复杂度 O(N) ： 两轮遍历链表，使用 O(N) 时间。<br>空间复杂度 O(N) ： 哈希表 dic 使用线性大小的额外空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList1</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123; <span class="comment">//构造节点</span></span><br><span class="line">        map.put(cur, <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val));</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123; <span class="comment">//复制引用 复制新节点的引用</span></span><br><span class="line">        map.get(cur).next = map.get(cur.next);</span><br><span class="line">        map.get(cur).random = map.get(cur.random);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拼接拆分"><a href="#拼接拆分" class="headerlink" title="拼接拆分"></a>拼接拆分</h4><p>考虑构建 原节点 1 -&gt; 新节点 1 -&gt; 原节点 2 -&gt; 新节点 2 -&gt; …… 的拼接链表，如此便可在访问原节点的 random 指向节点的同时找到新对应新节点的 random 指向节点。</p><p><strong>算法流程：</strong></p><ol><li><p>复制各节点，构建拼接链表:</p><ul><li>设原链表为 node1-&gt;node2-&gt;⋯ ，构建的拼接链表如下所示：<br>node1 -&gt;node1{new}-&gt;node2-&gt;node2{new}-&gt;….</li></ul></li><li><p>构建新链表各节点的 random 指向：</p><ul><li>当访问原节点 cur 的随机指向节点 cur.random 时，对应新节点 cur.next 的随机指向节点为cur.random.next。</li></ul></li><li><p>拆分原 / 新链表：</p></li></ol><ul><li>设置 pre / cur 分别指向原 / 新链表头节点，遍历执行 pre.next = pre.next.next 和 cur.next = cur.next.next 将两链表拆分开。</li></ul><ol start="4"><li>返回新链表的头节点 res 即可。</li></ol><p><strong>复杂度分析：</strong><br>时间复杂度 O(N)O(N) ： 三轮遍历链表，使用 O(N)O(N) 时间。<br>空间复杂度 O(1)O(1) ： 节点引用变量使用常数大小的额外空间。</p><p><img src="https://pic.leetcode-cn.com/1604747285-LidbfG-Picture16.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拼接 + 拆分</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList2</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制各节点，构建拼接链表</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val);</span><br><span class="line">        temp.next = cur.next;</span><br><span class="line">        cur.next = temp;</span><br><span class="line">        cur = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建新链表各节点的 random 指向</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.random != <span class="literal">null</span>)</span><br><span class="line">            cur.next.random = cur.random.next;</span><br><span class="line">        cur  = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拆分两链表</span></span><br><span class="line">    cur = head.next;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head, res = head.next;</span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a>剑指 Offer 58 - II. 左旋转字符串</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;abcdefg&quot;</span>, <span class="attr">k</span> = <span class="number">2</span></span><br><span class="line">输出: <span class="string">&quot;cdefgab&quot;</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;lrloseumgh&quot;</span>, <span class="attr">k</span> = <span class="number">6</span></span><br><span class="line">输出: <span class="string">&quot;umghlrlose&quot;</span></span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= k &lt; s.length &lt;= 10000</code></li></ul><p>Related Topics</p><p>数学</p><p>双指针</p><p>字符串</p><h4 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h4><blockquote><p>应用字符串切片函数，可方便实现左旋转字符串。</p></blockquote><p>获取字符串 s[n:] 切片和 s[:n] 切片，使用 “+” 运算符拼接并返回即可。</p><p><strong>复杂度分析：</strong><br>时间复杂度 O(N)： 其中 NN 为字符串 s 的长度，字符串切片函数为线性时间复杂度（参考资料）。<br>空间复杂度 O(N)： 两个字符串切片的总长度为 N。</p><p><img src="https://pic.leetcode-cn.com/1600793170-eyvDTJ-Picture1.png" alt="Picture1.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.substring(n, s.length()) + s.substring(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="列表遍历拼接"><a href="#列表遍历拼接" class="headerlink" title="列表遍历拼接"></a>列表遍历拼接</h4><blockquote><p>若面试规定不允许使用 切片函数 ，则使用此方法。</p></blockquote><p><strong>算法流程：</strong></p><ol><li>新建一个 StringBuilder，记为 res ；</li><li>先向 res 添加 “第 n+1 位至末位的字符” ；</li><li>再向 res 添加 “首位至第 n 位的字符” ；</li><li>将 res 转化为字符串并返回；</li></ol><p><strong>复杂度分析：</strong><br>时间复杂度 O(N)O(N) ： 线性遍历 s 并添加，使用线性时间。<br>空间复杂度 O(N)O(N) ： 新建的辅助 res 使用 O(N)O(N) 大小的额外空间。</p><p><img src="https://pic.leetcode-cn.com/1600793170-ViWBNV-Picture2.png" alt="Picture2.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; s.length(); i++)</span><br><span class="line">            res.append(s.charAt(i));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            res.append(s.charAt(i));</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求余运算加速</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; n + s.length(); i++)</span><br><span class="line">            res.append(s.charAt(i % s.length()));</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串遍历拼接"><a href="#字符串遍历拼接" class="headerlink" title="字符串遍历拼接"></a>字符串遍历拼接</h4><blockquote><p>若规定 Java 只能用 String ，则使用此方法。</p></blockquote><p>此方法与 方法二 思路一致，区别是使用字符串代替列表。</p><p><strong>复杂度分析：</strong><br>时间复杂度 O(N)： 线性遍历 s 并添加，使用线性时间。<br>空间复杂度 O(N) ： 假设循环过程中内存会被及时回收，内存中至少同时存在长度为 N 和 N−1 的两个字符串（新建长度为 N 的 res 需要使用前一个长度 N−1 的 res ），因此至少使用 O(N) 的额外空间。</p><p><img src="https://pic.leetcode-cn.com/1600793170-uasqXO-Picture3.png" alt="Picture3.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; s.length(); i++)</span><br><span class="line">            res += s.charAt(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            res += s.charAt(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求余运算加速</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; n + s.length(); i++)</span><br><span class="line">            res += s.charAt(i % s.length());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a>剑指 Offer 59 - I. 滑动窗口的最大值</h3><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><p><strong>示例:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,<span class="string">-1</span>,<span class="string">-3</span>,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  <span class="string">-1</span>] <span class="string">-3</span>  5  3  6  7       3</span><br><span class="line"> 1 [3  <span class="string">-1</span>  <span class="string">-3</span>] 5  3  6  7       3</span><br><span class="line"> 1  3 [<span class="string">-1</span>  <span class="string">-3</span>  5] 3  6  7       5</span><br><span class="line"> 1  3  <span class="string">-1</span> [<span class="string">-3</span>  5  3] 6  7       5</span><br><span class="line"> 1  3  <span class="string">-1</span>  <span class="string">-3</span> [5  3  6] 7       6</span><br><span class="line"> 1  3  <span class="string">-1</span>  <span class="string">-3</span>  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>你可以假设 <em>k</em> 总是有效的，在输入数组 <strong>不为空</strong> 的情况下，<code>1 ≤ k ≤ nums.length</code>。</p><p>队列</p><p>滑动窗口</p><p>单调队列</p><p>堆（优先队列）</p><hr><p><strong>解题思路：</strong><br>设窗口区间为 [i, j] ，最大值为 x j 。当窗口向前移动一格，则区间变为 [i+1,j+1]，即添加了 nums[j + 1] ，删除了nums[i] 。</p><p>若只向窗口 [i, j]右边添加数字 nums[j + 1]，则新窗口最大值可以 通过一次对比 使用O(1) 时间得到，即：<code>x&#123;j+1&#125; = max(x&#123;j&#125;, nums[j + 1])</code>而由于删除的 nums[i]可能恰好是窗口内唯一的最大值 x j，因此不能通过以上方法计算 x j+1，而必须使用O(j−i) 时间， 遍历整个窗口区间 获取最大值，即：x{j+1} = max(nums(i+1),……. , num(j+1))</p><p>根据以上分析，可得 暴力法 的时间复杂度为 O((n-k+1)k)≈O(nk) 。</p><ul><li>设数组 nums的长度为 nn ，则共有 (n-k+1)个窗口；</li><li>获取每个窗口最大值需线性遍历，时间复杂度为 O(k)。</li></ul><p><img src="https://pic.leetcode-cn.com/1600878237-pBiBdf-Picture1.png" alt="Picture1.png"></p><blockquote><p><strong>本题难点：</strong> 如何在每次窗口滑动后，将 “获取窗口内最大值” 的时间复杂度从 O(k) 降低至 O(1)。</p></blockquote><p>回忆 剑指Offer 30. 包含 min 函数的栈 ，其使用 <strong>单调栈</strong> 实现了随意入栈、出栈情况下的 O(1)时间获取 “栈内最小值” 。本题同理，不同点在于 “出栈操作” 删除的是 “列表尾部元素” ，而 “窗口滑动” 删除的是 “列表首部元素”。</p><p>窗口对应的数据结构为 <strong>双端队列</strong> ，本题使用 <strong>单调队列</strong> 即可解决以上问题。遍历数组时，每轮保证单调队列 deque：</p><ol><li>deque 内 <strong>仅包含窗口内的元素</strong> ⇒ 每轮窗口滑动移除了元素nums[i−1] ，需将 deque内的对应元素一起删除。</li><li>deque 内的元素 <strong>非严格递减</strong> ⇒ 每轮窗口滑动添加了元素 nums[j + 1]，需将 deque内所有 &lt; nums[j + 1]的元素删除。</li></ol><p><strong>算法流程：</strong></p><ol><li>初始化： 双端队列 deque ，结果列表 res ，数组长度 n ；</li><li>滑动窗口： 左边界范围i∈[1−k,n−k] ，右边界范围 j∈[0,n−1] ；<ol><li>若 i &gt; 0 且 队首元素 deque[0] == 被删除元素 nums[i−1] ：则队首元素出队；</li><li>删除 deque 内所有 &lt;nums[j] 的元素，以保持 deque 递减；</li><li>将 nums[j]添加至deque 尾部；</li><li>若已形成窗口（即 i≥0 ）：将窗口最大值（即队首元素 deque[0] ）添加至列表 res ；</li></ol></li><li>返回值： 返回结果列表 resres ；</li></ol><p><img src="https://pic.leetcode-cn.com/1600878237-YoQeRX-Picture4.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/1600878237-cFWnrv-Picture5.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/1600878237-jrguEx-Picture6.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/1600878237-KPnHbt-Picture8.png" alt="img"></p><p><strong>复杂度分析：</strong><br>时间复杂度 O(n) ： 其中 nn 为数组 nums 长度；线性遍历nums 占用O(n) ；每个元素最多仅入队和出队一次，因此单调队列 deque占用 O(2n) 。<br>空间复杂度 O(k)： 双端队列deque 中最多同时存储 k个元素（即窗口大小）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow2(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">1</span> - k; j &lt; nums.length; i++, j++) &#123;</span><br><span class="line">        <span class="comment">// 删除 deque 中对应的 nums[i-1]</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; deque.peekFirst() == nums[i - <span class="number">1</span>])</span><br><span class="line">            deque.removeFirst();</span><br><span class="line">        <span class="comment">// 保持 deque 递减</span></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j])</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        deque.addLast(nums[j]);</span><br><span class="line">        <span class="comment">// 记录窗口最大值</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)</span><br><span class="line">            res[i] = deque.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a>剑指 Offer 59 - II. 队列的最大值</h3><p>请定义一个队列并实现函数 <code>max_value</code> 得到队列里的最大值，要求函数<code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code> 的<strong>均摊</strong>时间复杂度都是O(1)。</p><p>若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 -1</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[<span class="string">&quot;MaxQueue&quot;</span>,<span class="string">&quot;push_back&quot;</span>,<span class="string">&quot;push_back&quot;</span>,<span class="string">&quot;max_value&quot;</span>,<span class="string">&quot;pop_front&quot;</span>,<span class="string">&quot;max_value&quot;</span>]</span><br><span class="line">[[],[<span class="number">1</span>],[<span class="number">2</span>],[],[],[]]</span><br><span class="line">输出: [null,null,null,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[<span class="string">&quot;MaxQueue&quot;</span>,<span class="string">&quot;pop_front&quot;</span>,<span class="string">&quot;max_value&quot;</span>]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,<span class="number">-1</span>,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</code></li><li><code>1 &lt;= value &lt;= 10^5</code></li></ul><p>Related Topics</p><p>设计</p><p>队列</p><p>单调队列</p><hr><p><strong>解题思路：</strong></p><p>考虑利用 数据结构 来实现，即经常使用的 “空间换时间” 。如下图所示，考虑构建一个递减列表来保存队列 所有递减的元素 ，递减链表随着入队和出队操作实时更新，这样队列最大元素就始终对应递减列表的首元素，实现了获取最大值O(1) 时间复杂度。</p><p><img src="https://pic.leetcode-cn.com/1609261470-gMTEAf-Picture2.png" alt="Picture2.png"></p><p>为了实现此递减列表，需要使用 <strong>双向队列</strong> ，假设队列已经有若干元素：</p><ol><li>当执行入队 push_back() 时： 若入队一个比队列某些元素更大的数字 x ，则为了保持此列表递减，需要将双向队列 尾部所有小于 x 的元素 弹出。</li><li>当执行出队 pop_front() 时： 若出队的元素是最大元素，则 双向队列 需要同时 <strong>将首元素出队</strong> ，以保持队列和双向队列的元素一致性。</li></ol><blockquote><p>使用双向队列原因：维护递减列表需要元素队首弹出、队尾插入、队尾弹出操作皆为O(1) 时间复杂度。</p></blockquote><p><strong>函数设计：</strong></p><p>初始化队列 queue ，双向队列 deque ；</p><p><strong>最大值 max_value() ：</strong></p><ul><li>当双向队列 deque 为空，则返回−1 ；</li><li>否则，返回 deque 首元素；</li></ul><p><strong>入队 push_back() ：</strong></p><ul><li>将元素 value 入队 queue ；</li><li>将双向队列中队尾 所有 小于 value 的元素弹出（以保持 deque 非单调递减），并将元素 value 入队 deque ；</li></ul><p><strong>出队 pop_front() ：</strong></p><ul><li>若队列 queue 为空，则直接返回 -1−1 ；</li><li>否则，将 queue 首元素出队；</li><li>若 deque 首元素和 queue 首元素 相等 ，则将 deque 首元素出队（以保持两队列 元素一致 ） ；</li></ul><blockquote><p>设计双向队列为 非单调递减 的原因：若队列 queue 中存在两个 值相同的最大元素 ，此时 queue 和 deque 同时弹出一个最大元素，而 queue 中还有一个此最大元素；即采用单调递减将导致两队列中的元素不一致。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    Deque&lt;Integer&gt; deque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max_value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deque.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> deque.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        queue.add(value);</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; value)</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        deque.offerLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop_front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(queue.peek(), deque.peekFirst()))</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            <span class="keyword">return</span> queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-67-把字符串转换成整数"><a href="#剑指-Offer-67-把字符串转换成整数" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数"></a>剑指 Offer 67. 把字符串转换成整数</h3><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p><strong>说明：</strong></p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: &quot;42&quot;</span></span><br><span class="line"><span class="section">输出: 42</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: &quot;   -42&quot;</span></span><br><span class="line"><span class="section">输出: -42</span></span><br><span class="line"><span class="section">解释: 第一个非空白字符为 &#x27;-&#x27;, 它是一个负号。</span></span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: &quot;4193 with words&quot;</span></span><br><span class="line"><span class="section">输出: 4193</span></span><br><span class="line"><span class="section">解释: 转换截止于数字 &#x27;3&#x27; ，因为它的下一个字符不为数字。</span></span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: &quot;words and 987&quot;</span></span><br><span class="line"><span class="section">输出: 0</span></span><br><span class="line"><span class="section">解释: 第一个非空字符是 &#x27;w&#x27;, 但它不是数字或正、负号。</span></span><br><span class="line">     因此无法执行有效的转换。</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;-<span class="number">91283472332</span>&quot;</span><br><span class="line">输出: -<span class="number">2147483648</span></span><br><span class="line">解释: 数字 &quot;-<span class="number">91283472332</span>&quot; 超过 <span class="number">32</span> 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−<span class="number">231</span>) 。</span><br></pre></td></tr></table></figure><p>Related Topics</p><p>字符串</p><hr><p><strong>解题思路：</strong><br>根据题意，有以下四种字符需要考虑：</p><ol><li><p>首部空格： 删除之即可；</p></li><li><p>符号位： 三种情况，即 ‘’++’’ , ‘’-−’’ , ‘’无符号” ；新建一个变量保存符号位，返回前判断正负即可；</p></li><li><p>非数字字符： 遇到首个非数字的字符时，应立即返回；</p></li><li><p>数字字符：</p><ol><li><p>字符转数字： “此数字的 ASCII 码” 与 “ 00 的 ASCII 码” 相减即可；</p></li><li><p>数字拼接： 若从左向右遍历数字，设当前位字符为 cc ，当前位数字为 xx ，数字结果为 resres ，则数字拼接公式为：</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210291215534.png" alt="image-20221029121552410"></p><p><img src="https://pic.leetcode-cn.com/1600793383-jCgsGU-Picture1.png" alt="Picture1.png"></p></li></ol></li></ol><p><strong>数字越界处理：</strong></p><blockquote><p>题目要求返回的数值范围应在[−2^31 ,2^31 −1] ，因此需要考虑数字越界问题。而由于题目指出 环境只能存储 32 位大小的有符号整数 ，因此判断数字越界时，要始终保持 res 在 int 类型的取值范围内。</p></blockquote><p>在每轮数字拼接前，判断res 在此轮拼接后是否超过 2147483647，若超过则加上符号位直接返回。<br>设数字拼接边界 bndry = 2147483647 // 10 = 214748364，则以下两种情况越界：</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210291218048.png" alt="image-20221029121808981"></p><p><img src="https://pic.leetcode-cn.com/1600793383-JZRYip-Picture2.png" alt="Picture2.png"></p><p><strong>复杂度分析：</strong><br>时间复杂度 O(N) ： 其中 N 为字符串长度，线性遍历字符串占用 O(N) 时间。<br>空间复杂度 O(N) ： 删除首尾空格后需建立新字符串，最差情况下占用 O(N) 额外空间。</p><p>若不使用 <code>trim() / strip()</code> 删除首部空格，而采取遍历跳过空格的方式，则可以将空间复杂度降低至 O(1) ，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strToInt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, <span class="comment">// 返回值</span></span><br><span class="line">        bndry = Integer.MAX_VALUE / <span class="number">10</span>; <span class="comment">// 越界标志</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, <span class="comment">// 遍历</span></span><br><span class="line">        sign = <span class="number">1</span>, <span class="comment">// 正负标志位</span></span><br><span class="line">        length = str.length();</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">// 跳过空格</span></span><br><span class="line">        <span class="keyword">if</span> (++i == length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27;-&#x27;</span>) sign = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27;+&#x27;</span> || str.charAt(i) == <span class="string">&#x27;-&#x27;</span>) i++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(j) &lt; <span class="string">&#x27;0&#x27;</span> || str.charAt(j) &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; bndry || res == bndry &amp;&amp; str.charAt(j) &gt; <span class="string">&#x27;7&#x27;</span>) <span class="comment">// 越界</span></span><br><span class="line">            <span class="keyword">return</span> sign == <span class="number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">        res = res * <span class="number">10</span> + (str.charAt(j) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res * sign;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LC2-两数之和"><a href="#LC2-两数之和" class="headerlink" title="LC2. 两数之和"></a>LC2. 两数之和</h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[2,4,3]</span>, l2 = <span class="comment">[5,6,4]</span></span><br><span class="line">输出：<span class="comment">[7,0,8]</span></span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[0]</span>, l2 = <span class="comment">[0]</span></span><br><span class="line">输出：<span class="comment">[0]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">9,9,9,9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>], l2 = [<span class="number">9,9,9,9</span>]</span><br><span class="line">输出：[<span class="number">8,9,9,9</span>,<span class="number">0,0,0,1</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><p>Related Topics</p><p>递归</p><p>链表</p><p>数学</p><h4 id="构造新链表"><a href="#构造新链表" class="headerlink" title="构造新链表"></a>构造新链表</h4><p>通过计算两个链表的和构造一个新链表。</p><p>时间复杂度O(N)</p><p>空间复杂度O(N)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 构建新链表</span></span><br><span class="line"><span class="comment">     * 时间复杂度O(n)</span></span><br><span class="line"><span class="comment">     * 空间复杂度O(1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers1</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">out</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录进位</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> l1;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur2</span> <span class="operator">=</span> l2;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur1 != <span class="literal">null</span> || cur2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (cur1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            cur.next.val = cur2.val + out;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            cur.next.val = cur1.val + out;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next.val = cur1.val + cur2.val + out;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.next.val &gt; <span class="number">9</span>) &#123; <span class="comment">// 2 位数</span></span><br><span class="line">            cur.next.val = cur.next.val % <span class="number">10</span>;</span><br><span class="line">            out = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (out == <span class="number">1</span>) &#123; <span class="comment">//如果有进位 填上进位</span></span><br><span class="line">        cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在原链表上操作"><a href="#在原链表上操作" class="headerlink" title="在原链表上操作"></a>在原链表上操作</h4><p>如果链表1没有链表2长的话，就把链表2的后续接在链表1上。处理后续有点麻烦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在原链表上改值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> l1;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur2</span> <span class="operator">=</span> l2;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> l1;</span><br><span class="line">    <span class="type">int</span> <span class="variable">out</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur1 != <span class="literal">null</span> &amp;&amp; cur2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur1.next == <span class="literal">null</span>) &#123; <span class="comment">//cur1 小拼接</span></span><br><span class="line">            cur1.next = cur2.next;</span><br><span class="line">            cur2.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1.val = cur1.val + cur2.val + out;</span><br><span class="line">        out = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur1.val &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            cur1.val = cur1.val % <span class="number">10</span>;</span><br><span class="line">            out = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur1;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur1 == <span class="literal">null</span> &amp;&amp; out == <span class="number">1</span>) &#123; <span class="comment">//位数相同 有一个进位</span></span><br><span class="line">        pre.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur1 != <span class="literal">null</span>) &#123; <span class="comment">//如果存在拼接的情况，则可能存在进位未加的情况</span></span><br><span class="line">        cur1.val += out;</span><br><span class="line">        out = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur1.val &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            cur1.val = cur1.val % <span class="number">10</span>;</span><br><span class="line">            out = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur1.next == <span class="literal">null</span> &amp;&amp; out == <span class="number">1</span>) &#123;</span><br><span class="line">            cur1.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">            out = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有限状态自动机（FSM）"><a href="#有限状态自动机（FSM）" class="headerlink" title="有限状态自动机（FSM）"></a>有限状态自动机（FSM）</h2><p> 有限状态机（Finite State Machine, FSM），又称有限状态自动机，简称状态机，是指在有限个状态之间按照一定规律转换的时序电路。</p><p>什么是有限状态自动机<br>是一种具有离散输入/输出系统的数学模型，简称 有限自动机。这一系统具有任意有限数量的内部“状态”。</p><p>状态:一个标识，能区分自动机在不同时刻的状况。有限状态系统具有任意有限数目的内部“状态”</p><p>自动机接受一定的输入，执行一定的动作，产生一定的结果。</p><p>自动机的本质:根据状态、输入和规则决定下一个状态</p><p>状态 +输入(激励)+规则 -&gt; 状态迁移</p><p>可能的状态、运行的规则都是事先确定的。一旦开始运行，就按照实现确定的规则工作，因此叫”自动机”。使用状态迁移描述整个工作过程</p><p>有限自动机示意图:</p><p><img src="https://img-blog.csdnimg.cn/img_convert/10b29ca6d5e0a9923a58c59041235ab0.png" alt="image-20220409152351649"></p><h3 id="应用有限自动机解题步骤"><a href="#应用有限自动机解题步骤" class="headerlink" title="应用有限自动机解题步骤"></a>应用有限自动机解题步骤</h3><p><strong>1、确定输入集</strong></p><p><strong>2、绘制状态迁移图（确定状态，在每一个状态下对输入进行分类，针对每一类输入，确定下一个状态）</strong></p><p><strong>3、确定状态转移函数（在某状态下，接收到某一字符后，自动机要执行的操作，以及迁移到的下一状态）</strong></p><h3 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a>剑指 Offer 20. 表示数值的字符串</h3><p>请实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）。</p><p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p><ol><li>若干空格</li><li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li><li>（可选）一个 <code>&#39;e&#39;</code> 或 <code>&#39;E&#39;</code> ，后面跟着一个 <strong>整数</strong></li><li>若干空格</li></ol><p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>下述格式之一：<ol><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code></li><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code> ，后面再跟着至少一位数字</li><li>一个点 <code>&#39;.&#39;</code> ，后面跟着至少一位数字</li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>至少一位数字</li></ol><p>部分<strong>数值</strong>列举如下：</p><ul><li><code>[&quot;+100&quot;, &quot;5e2&quot;, &quot;-123&quot;, &quot;3.1416&quot;, &quot;-1E-16&quot;, &quot;0123&quot;]</code></li></ul><p>部分<strong>非数值</strong>列举如下：</p><ul><li><code>[&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;]</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;0&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;e&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;.&quot;</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">&quot;    .1  &quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>&#39;+&#39;</code> ，减号 <code>&#39;-&#39;</code> ，空格 <code>&#39; &#39;</code> 或者点 <code>&#39;.&#39;</code> 。</li></ul><p>Related Topics</p><p>字符串</p><hr><p>解题思路：<br>本题使用有限状态自动机。根据字符类型和合法数值的特点，先定义状态，再画出状态转移图，最后编写代码即可。</p><p><strong>字符类型</strong>：</p><p>空格 「 」、数字「 0—9」 、正负号 「 +, -」 、小数点 「 . 」 、幂符号 「 e, E 」 。</p><p><strong>状态定义</strong>：</p><p>按照字符串从左到右的顺序，定义以下 9 种状态。</p><ol start="0"><li>开始的空格</li><li>幂符号前的正负号</li><li>小数点前的数字</li><li>小数点、小数点后的数字</li><li>当小数点前为空格时，小数点、小数点后的数字</li><li>幂符号</li><li>幂符号后的正负号</li><li>幂符号后的数字</li><li>结尾的空格</li></ol><p><strong>结束状态：</strong></p><p>合法的结束状态有 2, 3, 7, 8 。</p><p><img src="https://pic.leetcode-cn.com/1599283151-YmPMis-Picture1.png" alt="Picture1.png"></p><p><strong>算法流程：</strong></p><ol><li><strong>初始化：</strong><ol><li>状态转移表 states ： 设 states[i] ，其中 i 为所处状态， states[i] 使用哈希表存储可转移至的状态。键值对 (key, value) 含义：输入字符 key ，则从状态 i 转移至状态 value 。</li><li>当前状态 p ： 起始状态初始化为 p = 0 。</li></ol></li><li>状态转移循环： 遍历字符串 s 的每个字符 c 。<ol><li>记录字符类型 t ： 分为四种情况。<ul><li>当 c 为正负号时，执行 t = ‘s’ ;</li><li>当 c 为数字时，执行 t = ‘d’ ;</li><li>当 c 为 e 或 E 时，执行 t = ‘e’ ;</li><li>当 c 为 . 或 空格 时，执行 t = c （即用字符本身表示字符类型）;</li><li>否则，执行 t = ‘?’ ，代表为不属于判断范围的非法字符，后续直接返回 falsefalse 。</li></ul></li><li>终止条件： 若字符类型 t 不在哈希表 states[p] 中，说明无法转移至下一状态，因此直接返回 false 。</li><li>状态转移： 状态 p 转移至 states[p] [t] 。</li></ol></li><li>返回值： 跳出循环后，若状态 p \in {2, 3, 7, 8}∈2,3,7,8 ，说明结尾合法，返回 truetrue ，否则返回 false 。</li></ol><p><strong>复杂度分析：</strong><br>时间复杂度 O(N) ： 其中 N 为字符串 s 的长度，判断需遍历字符串，每轮状态转移的使用O(1) 时间。<br>空间复杂度 O(1) ： states 和 p 使用常数大小的额外空间。</p><p><img src="https://pic.leetcode-cn.com/1599283163-NYRJuG-Picture2.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map[] states = &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27; &#x27;</span>, <span class="number">0</span>); put(<span class="string">&#x27;s&#x27;</span>, <span class="number">1</span>); put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>); &#125;&#125;, <span class="comment">// 0.</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>); &#125;&#125;,                           <span class="comment">// 1.</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">3</span>); put(<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;, <span class="comment">// 2.</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>); put(<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;,              <span class="comment">// 3.</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>); &#125;&#125;,                                        <span class="comment">// 4.</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;s&#x27;</span>, <span class="number">6</span>); put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>); &#125;&#125;,                           <span class="comment">// 5.</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>); &#125;&#125;,                                        <span class="comment">// 6.</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;,                           <span class="comment">// 7.</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;                                         <span class="comment">// 8.</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) t = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) t = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;E&#x27;</span>) t = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;.&#x27;</span> || c == <span class="string">&#x27; &#x27;</span>) t = c;</span><br><span class="line">            <span class="keyword">else</span> t = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!states[p].containsKey(t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = (<span class="type">int</span>)states[p].get(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p == <span class="number">2</span> || p == <span class="number">3</span> || p == <span class="number">7</span> || p == <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="动态规划理论"><a href="#动态规划理论" class="headerlink" title="动态规划理论"></a>动态规划理论</h3><p><strong>内容</strong></p><ol><li>动态规划问题特点，动态规划和分治算法的联系与区别；</li><li>借助例题介绍重叠子问题和最优子结构分别是什么，以及动态规划是如何解决它们的；</li><li>动态规划的解题框架总结；</li><li>动态规划的练习例题，从易到难排序；</li></ol><p><strong>动态规划特点</strong></p><p><code>「分治」</code>是算法中的一种基本思想，其通过将原问题分解为子问题，不断递归地将子问题分解为更小的子问题，并通过<code>组合子问题的解</code>来得到原问题的解。</p><p>类似于分治算法，<code>「动态规划」</code>也通过组合子问题的解得到原问题的解。不同的是，适合用动态规划解决的问题具有<code>「重叠子问题」</code>和<code>「最优子结构」</code>两大特性。</p><p><strong>重叠子问题</strong><br>动态规划的子问题是有重叠的，即<code>各个子问题中包含重复的更小子问题</code>。若使用暴力法穷举，求解这些相同子问题会产生大量的重复计算，效率低下。</p><p>动态规划在第一次求解某子问题时，会<code>将子问题的解保存</code>；后续遇到重叠子问题时，则直接通过<code>查表获取</code>解，保证<code>每个独立子问题只被计算一次</code>，从而降低算法的时间复杂度。</p><p><strong>最优子结构</strong><br>如果一个问题的<code>最优解可以由其子问题的最优解组合</code>构成，并且这些子问题可以独立求解，那么称此问题具有最优子结构。</p><p>动态规划从基础问题的解开始，不断迭代<code>组合、选择子问题的最优解</code>，最终得到原问题最优解。</p><h3 id="重叠子问题例题：斐波那契数列"><a href="#重叠子问题例题：斐波那契数列" class="headerlink" title="重叠子问题例题：斐波那契数列"></a>重叠子问题例题：斐波那契数列</h3><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210311145007.png" alt="image-20221031114521821"></p><h4 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h4><p>设斐波那契数列第 nn 个数字为 f(n)f(n) 。根据数列定义，可得 f(n)=f(n−1)+f(n−2) ，且第 0 , 1 个斐波那契数分别为 f(0)=0 , f(1) = 1。</p><p>我们很容易联想到使用分治思想来求取 f(n)，即将求原问题f(n) 分解为求子问题f(n−1) 和f(n−2) ，向下递归直至已知的 f(0) 和 f(1) ，最终组合这些子问题求取原问题 f(n) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求第 n 个斐波那契数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回 f(0)</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回 f(1)</span></span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>); <span class="comment">// 分解为两个子问题求解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic.leetcode-cn.com/1635075778-GADtbi-Picture1.png" alt="Picture1.png"></p><p>如上图所示，为暴力递归求斐波那契数 f(5)形成的二叉树，树中的每个节点代表着执行了一次 fibonacci() 函数，且有：</p><ul><li>执行一次 fibonacci() 函数的时间复杂度为 O(1) ；</li><li>二叉树节点数为指数级 O(2^n)</li></ul><p>因此，暴力递归的总体时间复杂度为 O(2^n)此方法效率低下，随着 n 的增长产生指数级爆炸。</p><h4 id="记忆化递归"><a href="#记忆化递归" class="headerlink" title="记忆化递归"></a>记忆化递归</h4><p>观察发现，暴力递归中的子问题多数都是<strong>重叠子问题</strong>，即：</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210311150060.png" alt="image-20221031115046286"></p><p>这些重叠子问题产生了大量的递归树节点，其<code>不应被重复计算</code>。实际上，可以在递归中第一次求解子问题时，就将它们<code>保存</code>；后续递归中再次遇到相同子问题时，直接访问内存赋值即可。记忆化递归的代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] dp)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;           <span class="comment">// 返回 f(0)</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;           <span class="comment">// 返回 f(1)</span></span><br><span class="line">    <span class="keyword">if</span> (dp[n] != <span class="number">0</span>) <span class="keyword">return</span> dp[n];   <span class="comment">// 若 f(n) 以前已经计算过，则直接返回记录的解</span></span><br><span class="line">    dp[n] = fibonacci(n - <span class="number">1</span>, dp) + fibonacci(n - <span class="number">2</span>, dp); <span class="comment">// 将 f(n) 则记录至 dp</span></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求第 n 个斐波那契数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fibonacciMemorized</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>]; <span class="comment">// 用于保存 f(0) 至 f(n) 问题的解</span></span><br><span class="line">    <span class="keyword">return</span> fibonacci(n, dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示，应用记忆化递归方法后，递归树中绝大部分节点被剪枝。此时，fibonacci() 函数的调用次数从 O(2^n)指数级别降低至 O(n)线性级别，时间复杂度大大降低。</p><p><img src="https://pic.leetcode-cn.com/1635075778-pJXkPc-Picture2.png" alt="Picture2.png"></p><h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h4><p>递归本质上是基于分治思想的从顶至底的解法。借助记忆化递归思想，可应用动态规划从底至顶求取 f(n) ，代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求第 n 个斐波那契数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;          <span class="comment">// 若求 f(0) 则直接返回 0</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];     <span class="comment">// 初始化 dp 列表</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;                     <span class="comment">// 初始化 f(0), f(1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123; <span class="comment">// 状态转移求取 f(2), f(3), ..., f(n) </span></span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];                  <span class="comment">// 返回 f(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示，为动态规划求解 f(5)的迭代流程，其是转移方程 <code>f(n) = f(n - 1) + f(n - 2)</code>的体现。</p><p><img src="https://pic.leetcode-cn.com/1635075778-EeBEoS-Picture3.png" alt="Picture3.png"></p><p>上述动态规划解法借助了一个 dp 数组保存子问题的解，其空间复杂度为O(N) 。而由于f(n) 只与f(n−1) 和 f(n−2) 有关，因此我们可以仅使用两个变量 a , b 交替前进计算即可。此时动态规划的空间复杂度降低至 O(1)，代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求第 n 个斐波那契数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;           <span class="comment">// 若求 f(0) 则直接返回 0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">1</span>;               <span class="comment">// 初始化 f(0), f(1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;  <span class="comment">// 状态转移求取 f(2), f(3), ..., f(n) </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;                       <span class="comment">// 返回 f(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例小结"><a href="#示例小结" class="headerlink" title="示例小结"></a>示例小结</h4><p>记忆化递归和动态规划的本质思想是一致的，是对斐波那契数列定义的不同表现形式：</p><ul><li>记忆化递归 — 从顶至低： 求 f(n)需要 f(n - 1)和 f(n - 2);⋯ ；求 f(2) 需要 f(1) 和 f(0) ；而 f(1) 和 f(0) 已知；</li><li>动态规划 — 从底至顶： 将已知 f(0) 和f(1) 组合得到f(2) ；⋯ ；将 f(n−2) 和 f(n−1) 组合得到 (n) ；</li></ul><p>斐波那契数列问题不包含「最优子结构」，只需计算每个子问题的解，避免重复计算即可，并不需要从子问题组合中选择最优组合。接下来，本文借助「最高蛋糕售价方案」，介绍动态规划的最优子结构概念。</p><h3 id="最优子结构例题：蛋糕售价"><a href="#最优子结构例题：蛋糕售价" class="headerlink" title="最优子结构例题：蛋糕售价"></a>最优子结构例题：蛋糕售价</h3><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210311159196.png" alt="image-20221031115902124"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210311159705.png" alt="image-20221031115959610"></p><h4 id="暴力递归-1"><a href="#暴力递归-1" class="headerlink" title="暴力递归"></a>暴力递归</h4><p>暴力递归解法的代码如下，其时间复杂度为指数级 O(2^n） 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入蛋糕价格列表 priceList ，求重量为 n 蛋糕的最高售价</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxCakePrice</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] priceList)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> priceList[n]; <span class="comment">// 蛋糕重量 &lt;= 1 时直接返回</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">f_n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)      <span class="comment">// 从 n 种组合种选择最高售价的组合作为 f(n)</span></span><br><span class="line">        f_n = Math.max(f_n, maxCakePrice(i, priceList) + priceList[n - i]);</span><br><span class="line">    <span class="keyword">return</span> f_n;                      <span class="comment">// 返回 f(n)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://pic.leetcode-cn.com/1635075778-AljQEJ-Picture4.png" alt="Picture4.png"></p><h4 id="记忆化递归-1"><a href="#记忆化递归-1" class="headerlink" title="记忆化递归"></a>记忆化递归</h4><p>观察发现，递归树中存在大量<strong>重叠子问题</strong>，可通过记忆化处理避免重复计算。记忆化递归的算法的时间复杂度为 O(n^2)，包括：</p><ul><li>f(2) 至f(n) 共 n−1 个待计算子问题，使用O(n) 时间；</li><li>计算某f(i) 需遍历 i−1 种子问题组合，使用 O(n) 时间；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入蛋糕价格列表 priceList ，求重量为 n 蛋糕的最高售价</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxCakePrice</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] priceList, <span class="type">int</span>[] dp)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> priceList[n]; <span class="comment">// 蛋糕重量 &lt;= 1 时直接返回</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">f_n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;    <span class="comment">// 从 n 种组合种选择最高售价的组合作为 f(n)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">f_i</span> <span class="operator">=</span> dp[i] != <span class="number">0</span> ? dp[i] : maxCakePrice(i, priceList, dp);</span><br><span class="line">        f_n = Math.max(f_n, f_i + priceList[n - i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[n] = f_n;                     <span class="comment">// 记录 f(n) 至 dp 数组</span></span><br><span class="line">    <span class="keyword">return</span> f_n;                      <span class="comment">// 返回 f(n)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxCakePriceMemorized</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] priceList)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> maxCakePrice(n, priceList, dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic.leetcode-cn.com/1635075778-tsDBrs-Picture5.png" alt="Picture5.png"></p><h4 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h4><p>相较于记忆化递归的从顶至底方法，易得动态规划的从底至顶方法，代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入蛋糕价格列表 priceList ，求重量为 n 蛋糕的最高售价</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxCakePrice</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] priceList)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> priceList[n];  <span class="comment">// 蛋糕重量 &lt;= 1 时直接返回</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];        <span class="comment">// 初始化 dp 列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;    <span class="comment">// 按顺序计算 f(1), f(2), ..., f(n)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++)   <span class="comment">// 从 j 种组合种选择最高售价的组合作为 f(j)</span></span><br><span class="line">            dp[j] = Math.max(dp[j], dp[i] + priceList[j - i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic.leetcode-cn.com/1635075778-PBtyyB-Picture6.png" alt="Picture6.png"></p><h3 id="动态规划解题框架"><a href="#动态规划解题框架" class="headerlink" title="动态规划解题框架"></a>动态规划解题框架</h3><p>若确定给定问题具有重叠子问题和最优子结构，那么就可以使用动态规划求解。总体上看，求解可分为四步：</p><ol><li>状态定义： 构建问题最优解模型，包括问题最优解的定义、有哪些计算解的自变量；</li><li>初始状态： 确定基础子问题的解（即已知解），原问题和子问题的解都是以基础子问题的解为起始点，在迭代计算中得到的；</li><li>转移方程： 确定原问题的解与子问题的解之间的关系是什么，以及使用何种选择规则从子问题最优解组合中选出原问题最优解；</li><li>返回值： 确定应返回的问题的解是什么，即动态规划在何处停止迭代；</li></ol><p>完成以上步骤后，便容易写出对应的解题代码。</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210311209375.png" alt="image-20221031120901274"></p><h3 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a>剑指 Offer 10- I. 斐波那契数列</h3><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">F</span><span class="params">(<span class="number">0</span>)</span></span> = <span class="number">0</span>,   <span class="built_in">F</span>(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">F</span><span class="params">(N)</span></span> = <span class="built_in">F</span>(N - <span class="number">1</span>) + <span class="built_in">F</span>(N - <span class="number">2</span>), 其中 N &gt; <span class="number">1</span>.</span><br></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul><p>Related Topics</p><p>记忆化搜索</p><p>数学</p><p>动态规划</p><blockquote><p>相比于一般的fib加了取余数的过程</p></blockquote><h4 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记忆化搜索</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];<span class="comment">//记录之前搜索的数据</span></span><br><span class="line">        <span class="keyword">return</span> fibonacci(n, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] dp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[n] != <span class="number">0</span>) <span class="keyword">return</span> dp[n];<span class="comment">//如果之前有记录 直接返回</span></span><br><span class="line">        <span class="keyword">else</span> dp[n] = (fibonacci(n - <span class="number">1</span>, dp) + fibonacci(n - <span class="number">2</span>, dp)) % <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h4><h3 id="剑指-Offer-19-正则表达式匹配"><a href="#剑指-Offer-19-正则表达式匹配" class="headerlink" title="剑指 Offer 19. 正则表达式匹配"></a>剑指 Offer 19. 正则表达式匹配</h3><p>请实现一个函数用来匹配包含<code>&#39;. &#39;</code>和<code>&#39;*&#39;</code>的正则表达式。模式中的字符<code>&#39;.&#39;</code>表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line">s = <span class="string">&quot;aa&quot;</span></span><br><span class="line">p = <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="section">输出: false</span></span><br><span class="line"><span class="section">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">&quot;aa&quot;</span></span><br><span class="line">p = <span class="string">&quot;a*&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 因为 <span class="string">&#x27;*&#x27;</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="string">&#x27;a&#x27;</span>。因此，字符串 <span class="string">&quot;aa&quot;</span> 可被视为 <span class="string">&#x27;a&#x27;</span> 重复了一次。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line">s = <span class="string">&quot;ab&quot;</span></span><br><span class="line">p = <span class="string">&quot;.*&quot;</span></span><br><span class="line"><span class="section">输出: true</span></span><br><span class="line"><span class="section">解释: &quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span></span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">&quot;aab&quot;</span></span><br><span class="line">p = <span class="string">&quot;c*a*b&quot;</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 因为 <span class="string">&#x27;*&#x27;</span> 表示零个或多个，这里 <span class="string">&#x27;c&#x27;</span> 为 <span class="number">0</span> 个, <span class="string">&#x27;a&#x27;</span> 被重复一次。因此可以匹配字符串 <span class="string">&quot;aab&quot;</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入:</span></span><br><span class="line">s = <span class="string">&quot;mississippi&quot;</span></span><br><span class="line">p = <span class="string">&quot;mis*is*p*.&quot;</span></span><br><span class="line"><span class="section">输出: false</span></span><br></pre></td></tr></table></figure><ul><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母以及字符 <code>.</code> 和 <code>*</code>，无连续的 <code>&#39;*&#39;</code>。</li></ul><hr><p><strong>解题思路</strong></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211011104013.png" alt="image-20221101110409896"></p><p><img src="https://pic.leetcode-cn.com/1614516402-HyzAil-Picture1.png" alt="Picture1.png"></p><p>因此，本题的状态共有 m×n 种，应定义状态矩阵 dp ，dp[i] [j]代表 s[:i] 与 p[:j] 是否可以匹配。</p><p>做好状态定义，接下来就是根据 「普通字符」 , 「.」 , 「*」三种字符的功能定义，分析出动态规划的转移方程。</p><p><strong>动态规划解析：</strong></p><ul><li><p><strong>状态定义：</strong> 设动态规划矩阵 dp ， dp[i] [j] 代表字符串 s 的前 i 个字符和 p 的前 j 个字符能否匹配。</p></li><li><p><strong>转移方程：</strong> 需要注意，由于 dp[0] [0] 代表的是空字符的状态， 因此 dp[i] [j] 对应的添加字符是 s[i - 1] 和 p[j - 1] 。</p><ul><li>当 p[j - 1] = ‘*’ 时， dp[i] [j] 在当以下任一情况为 true 时等于 true ：<ul><li>dp[i] [j - 2]： 即将字符组合 p[j - 2] * 看作出现 0 次时，能否匹配；</li><li>dp[i - 1] [j] 且 s[i - 1] = p[j - 2] : 即让字符 p[j - 2] 多出现 1 次时，能否匹配；</li><li>dp[i - 1] [j] 且 p[j - 2] = ‘.’ : 即让字符 ‘.’ 多出现 1 次时，能否匹配；</li></ul></li><li>当 p[j - 1] != ‘*’ 时， dp[i] [j] 在当以下任一情况为 true 时等于 true ：<ul><li>dp[i - 1] [j - 1] 且 s[i - 1] = p[j - 1]： 即让字符 p[j - 1] 多出现一次时，能否匹配；</li><li>dp[i - 1] [j - 1] 且 p[j - 1] = ‘.’： 即将字符 . 看作字符 s[i - 1] 时，能否匹配；</li></ul></li></ul></li><li><p><strong>初始化：</strong> 需要先初始化 dp 矩阵首行，以避免状态转移时索引越界。</p><ul><li>dp[0] [0] = true： 代表两个空字符串能够匹配。<br>dp[0] [j] = dp[0] [j - 2] 且 p[j - 1] = ‘*’： 首行 s 为空字符串，因此当 p 的偶数位为 * 时才能够匹配（即让 p 的奇数位出现 0 次，保持 p 是空字符串）。因此，循环遍历字符串 p ，步长为 2（即只看偶数位）。<br>返回值： dp 矩阵右下角字符，代表字符串 s 和 p 能否匹配。</li></ul></li><li><p><strong>返回值：</strong> <code>dp</code> 矩阵右下角字符，代表字符串 <code>s</code> 和 <code>p</code> 能否匹配。</p></li></ul><p><img src="https://pic.leetcode-cn.com/1614516402-MacqQq-Picture4.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/1614516402-ATFWBt-Picture6.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/1614516402-HHmdNJ-Picture12.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/1614516402-bBdFaG-Picture13.png" alt="img"></p><p><img src="https://pic.leetcode-cn.com/1614516402-ibjjpB-Picture18.png" alt="img"></p><p><strong>复杂度分析：</strong><br>时间复杂度 O(MN)： 其中 M, N分别为 s 和 p 的长度，状态转移需遍历整个 dp 矩阵。<br>空间复杂度 O(MN)： 状态矩阵 dp 使用 O(MN)的额外空间。</p><h2 id="搜索、回溯"><a href="#搜索、回溯" class="headerlink" title="搜索、回溯"></a>搜索、回溯</h2><h3 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a>剑指 Offer 12. 矩阵中的路径</h3><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;E&quot;</span>],[<span class="string">&quot;S&quot;</span>,<span class="string">&quot;F&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;S&quot;</span>],[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>,<span class="string">&quot;E&quot;</span>]], word = <span class="string">&quot;ABCCED&quot;</span></span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>],[<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>]], word = <span class="string">&quot;abcd&quot;</span></span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>解题思路：</strong><br>本问题是典型的矩阵搜索问题，可使用 深度优先搜索（DFS）+ 剪枝 解决。</p><ul><li><strong>深度优先搜索：</strong> 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li><li><strong>剪枝：</strong> 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。</li></ul><p><strong>DFS 解析：</strong></p><ul><li>递归参数： 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。</li><li>终止条件：<ol><li>返回 false： (1) 行或列索引越界 或 (2) 当前矩阵元素与目标字符不同 或 (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ） 。</li><li>返回 true ： k = len(word) - 1 ，即字符串 word 已全部匹配。</li></ol></li><li>递推工作：<ol><li>标记当前矩阵元素： 将 board[i] [j] 修改为 空字符 ‘ ‘，代表此元素已访问过，防止之后搜索时重复访问。</li><li>搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 res 。</li><li>还原当前矩阵元素： 将 board[i] [j] 元素还原至初始值，即 word[k] 。</li></ol></li><li>返回值： 返回布尔量 res ，代表是否搜索到目标字符串。</li></ul><p><strong>复杂度分析：</strong><br>M,N 分别为矩阵行列大小， K 为字符串 word 长度。</p><ul><li>时间复杂度 O(3^KMN)： 最差情况下，需要遍历矩阵中长度为 K 字符串的所有方案，时间复杂度为 O(3^K)；矩阵中共有 MN个起点，时间复杂度为O(MN) 。<ul><li>方案数计算： 设字符串长度为 K ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 3 种选择，因此方案数的复杂度为 O(3^K)</li></ul></li><li>空间复杂度 O(K) ： 搜索过程中的递归深度不超过 K ，因此系统因函数调用累计使用的栈空间占用 O(K) （因为函数返回后，系统调用的栈空间会释放）。最坏情况下 K = MN，递归深度为 MN，此时系统栈使用 O(MN) 的额外空间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, words, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">char</span>[] word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= board.length || i &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || j &lt; <span class="number">0</span> || board[i][j] != word[k]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == word.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> dfs(board, word, i + <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(board, word, i - <span class="number">1</span>, j, k + <span class="number">1</span>) || </span><br><span class="line">                      dfs(board, word, i, j + <span class="number">1</span>, k + <span class="number">1</span>) || dfs(board, word, i , j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        board[i][j] = word[k];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法总结&quot;&gt;&lt;a href=&quot;#算法总结&quot; class=&quot;headerlink&quot; title=&quot;算法总结&quot;&gt;&lt;/a&gt;算法总结&lt;/h1&gt;&lt;h2 id=&quot;二分搜索&quot;&gt;&lt;a href=&quot;#二分搜索&quot; class=&quot;headerlink&quot; title=&quot;二分搜索&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Rabbit MQ</title>
    <link href="http://huangrd.top/pages/uncategorized/RabbitMQ.html"/>
    <id>http://huangrd.top/pages/uncategorized/RabbitMQ.html</id>
    <published>2022-10-17T02:18:12.276Z</published>
    <updated>2022-11-01T16:33:52.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rabbit-MQ"><a href="#Rabbit-MQ" class="headerlink" title="Rabbit MQ"></a>Rabbit MQ</h1><h2 id="MQ基本概念"><a href="#MQ基本概念" class="headerlink" title="MQ基本概念"></a>MQ基本概念</h2><h3 id="MQ概述"><a href="#MQ概述" class="headerlink" title="MQ概述"></a>MQ概述</h3><p>MQ全称 Message Queue（消息队列），是在<code>消息的传输过程中保存消息的容器</code>。多用于<code>分布式系统之间进行通信</code>。</p><p>直接调用：</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171023027.png" alt="image-20221017102354985"></p><p>改进为：</p><p>借助第三方完成通信</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171024464.png" alt="image-20221017102411430"></p><ul><li>MQ，消息队列，存储消息的中间件</li><li>分布式系统通信两种方式：直接远程调用 和 借助第三方 完成间接通信</li><li>发送方称为生产者，接收方称为消费者</li></ul><h3 id="MQ的优劣"><a href="#MQ的优劣" class="headerlink" title="MQ的优劣"></a>MQ的优劣</h3><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171026966.png" alt="image-20221017102603930"></p><h4 id="MQ的优势"><a href="#MQ的优势" class="headerlink" title="MQ的优势"></a>MQ的优势</h4><h5 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h5><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171026208.png" alt="image-20221017102635168"></p><p>对于修改相关连的子系统，需要对整个系统进行修改。系统耦合度高。</p><p><strong>系统的耦合性越高，容错性就越低，可维护性就越低</strong></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171027077.png" alt="image-20221017102753030"></p><p>使用MQ，订单系统的信息直接存入MQ，后续的相关业务系统通过访问MQ来获取信息。</p><p><strong>使用 MQ 使得应用间解耦，提升容错性和可维护性。</strong></p><h5 id="异步提速"><a href="#异步提速" class="headerlink" title="异步提速"></a>异步提速</h5><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171029229.png" alt="image-20221017102929182"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171029493.png" alt="image-20221017102951445"></p><p>利用MQ，用户输入信息后，先存在MQ，直接对用户进行相应，降低延迟。后续业务可以利用多线程完成。</p><h5 id="削峰填谷"><a href="#削峰填谷" class="headerlink" title="削峰填谷"></a>削峰填谷</h5><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171031679.png" alt="image-20221017103158632"></p><p>如果系统可接受的请求数量小于发送的请求数量，系统就会直接崩掉。利用MQ来缓存请求信息，可以保证服务器的稳定，保证其正常运行。</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171033114.png" alt="image-20221017103321069"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171033709.png" alt="image-20221017103337658"></p><ul><li>应用解耦：提高系统容错性和可维护性</li><li>异步提速：提升用户体验和系统吞吐量</li><li>削峰填谷：提高系统稳定性</li></ul><h4 id="MQ的劣势"><a href="#MQ的劣势" class="headerlink" title="MQ的劣势"></a>MQ的劣势</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171035406.png" alt="image-20221017103519369"></p><h5 id="系统可用性降低"><a href="#系统可用性降低" class="headerlink" title="系统可用性降低"></a>系统可用性降低</h5><p>系统引入的外部依赖越多，系统稳定性越差。一旦 MQ 宕机，就会对业务造成影响。如何保证MQ的高可用？</p><h5 id="系统复杂度降低"><a href="#系统复杂度降低" class="headerlink" title="系统复杂度降低"></a>系统复杂度降低</h5><p>MQ 的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过 MQ 进行异步调用。如何保证消息没有被重复消费？怎么处理消息丢失情况？那么保证消息传递的顺序性？</p><h5 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h5><p>A 系统处理完业务，通过 MQ 给B、C、D三个系统发消息数据，如果 B 系统、C 系统处理成功，D 系统处理失败。如何保证消息数据处理的一致性？</p><hr><p>对于MQ的优劣，MQ 需要满足什么条件：</p><p>① 生产者不需要从消费者处获得反馈。引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明</p><p>明下层的动作还没做，上层却当成动作做完了继续往后走，即所谓异步成为了可能。</p><p>② 容许短暂的不一致性。</p><p>③ 确实是用了有效果。即解耦、提速、削峰这些方面的收益，超过加入MQ，管理MQ这些成本</p><h3 id="常见的MQ产品"><a href="#常见的MQ产品" class="headerlink" title="常见的MQ产品"></a>常见的MQ产品</h3><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171039420.png" alt="image-20221017103935360"></p><h3 id="Rabbit-MQ简介"><a href="#Rabbit-MQ简介" class="headerlink" title="Rabbit MQ简介"></a>Rabbit MQ简介</h3><p><strong>AMQP</strong>，即 Advanced Message Queuing Protocol（<code>高级消息队列协议</code>），是一个网络协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。2006年，AMQP 规范发布。类比HTTP。</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171040287.png" alt="image-20221017104038246"></p><p>2007年，Rabbit 技术公司基于 AMQP 标准开发的 RabbitMQ 1.0 发布。RabbitMQ 采用 Erlang 语言开发。</p><p>Erlang 语言由 Ericson 设计，专门为开发<code>高并发和分布式系统</code>的一种语言，在电信领域使用广泛。</p><p>RabbitMQ 基础架构如下图：</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171041216.png" alt="image-20221017104125171"></p><hr><p>RabbitMQ 中的相关概念：</p><ul><li><p>Broker：接收和分发消息的应用，RabbitMQ Server就是 Message Broker</p></li><li><p>Virtual host（虚拟机）：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p></li><li><p>Connection：publisher／consumer 和 broker 之间的 TCP 连接</p></li><li><p>Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection的开销将是巨大的，效率也较低。Channel 是在 <code>connection 内部建立的逻辑连接</code>，如果应用程序支持多线程，通常每个thread创建单独的 channel 进行通讯，AMQP method 包含了channel id 帮助客户端和message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销</strong></p></li><li><p>Exchange(交换机)：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</p></li><li><p>Queue（队列）：消息最终被送到这里等待 consumer 取走</p></li><li><p>Binding（绑定）：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据</p></li></ul><hr><p>RabbitMQ 提供了 6 种<strong>工作模式</strong>：简单模式、work queues、Publish/Subscribe 发布与订阅模式、Routing路由式、Topics 主题模式、RPC 远程调用模式（远程调用，不太算 MQ；暂不作介绍）。</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171046024.png" alt="image-20221017104656973"></p><h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><ul><li><p>JMS 即 Java 消息服务（JavaMessage Service）应用程序接口，是一个 Java 平台中关于面向消息中间件的API</p></li><li><p>JMS 是 JavaEE 规范中的一种，类比JDBC</p></li><li><p>很多消息中间件都实现了JMS规范，例如：ActiveMQ。RabbitMQ 官方没有提供 JMS 的实现包，但是开源社区有</p></li></ul><p><strong>小结</strong></p><ol><li><p>RabbitMQ 是基于 AMQP 协议使用 Erlang 语言开发的一款消息队列产品。</p></li><li><p>RabbitMQ提供了6种工作模式，我们学习5种。这是今天的重点。</p></li><li><p>AMQP 是协议，类比HTTP。</p></li><li><p>JMS 是 API 规范接口，类比 JDBC。</p></li></ol><h2 id="MQ快速入门"><a href="#MQ快速入门" class="headerlink" title="MQ快速入门"></a>MQ快速入门</h2><p>需求：使用简单模式完成消息传递</p><p>步骤：</p><p>① 创建工程（生成者、消费者）</p><p>② 分别添加依赖</p><p>③ 编写生产者发送消息</p><p>④ 编写消费者接收消息</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171050480.png" alt="image-20221017105000425"></p><p>和JDBC操作数据库类似</p><p>生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//1.创建连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    <span class="comment">//2.设置参数</span></span><br><span class="line">    factory.setHost(<span class="string">&quot;192.168.184.100&quot;</span>);<span class="comment">//ip 默认值 localhost</span></span><br><span class="line">    factory.setPort(<span class="number">5672</span>);<span class="comment">//端口 默认值5672</span></span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);<span class="comment">//虚拟机 默认值/</span></span><br><span class="line">    factory.setUsername(<span class="string">&quot;dong&quot;</span>);<span class="comment">//用户名 默认 guest</span></span><br><span class="line">    factory.setPassword(<span class="string">&quot;dong&quot;</span>);<span class="comment">//密码 默认 guest</span></span><br><span class="line">    <span class="comment">//3.创建连接 Connection</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="comment">//4.创建Channel</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.创建队列Queue</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line"><span class="comment">        * 1.queue： 队列名称</span></span><br><span class="line"><span class="comment">        * 2.durable： 是否持久化，当mq重启后，还在</span></span><br><span class="line"><span class="comment">        * 3.exclusive：</span></span><br><span class="line"><span class="comment">        *   是否独占，只有一个消费者能够监听这个队列</span></span><br><span class="line"><span class="comment">        *   当Connection关闭时，是否删除队列</span></span><br><span class="line"><span class="comment">        * 4.autoDelete： 是否自动删除。当没有Consumer时，自动删除掉</span></span><br><span class="line"><span class="comment">        * 5.arguments： 参数</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">    <span class="comment">//如果没有一个叫hello_world的队列，则创建该队列，如果有该队列，则不创建</span></span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;hello_world&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.发送消息</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body)</span></span><br><span class="line"><span class="comment">        * 1.exchange： 交换机的名称。简单模式交换机会使用默认的。</span></span><br><span class="line"><span class="comment">        * 2.routingKey： 路由名称</span></span><br><span class="line"><span class="comment">        * 3.props： 配置信息</span></span><br><span class="line"><span class="comment">        * 4.body： 发送消息数据</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;hello rabbit_mq!!!&quot;</span>;</span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;hello_world&quot;</span>, <span class="literal">null</span>, body.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.释放资源</span></span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//1.创建连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    <span class="comment">//2.设置参数</span></span><br><span class="line">    factory.setHost(<span class="string">&quot;192.168.184.100&quot;</span>);<span class="comment">//ip 默认值 localhost</span></span><br><span class="line">    factory.setPort(<span class="number">5672</span>);<span class="comment">//端口 默认值5672</span></span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);<span class="comment">//虚拟机 默认值/</span></span><br><span class="line">    factory.setUsername(<span class="string">&quot;dong&quot;</span>);<span class="comment">//用户名 默认 guest</span></span><br><span class="line">    factory.setPassword(<span class="string">&quot;dong&quot;</span>);<span class="comment">//密码 默认 guest</span></span><br><span class="line">    <span class="comment">//3.创建连接 Connection</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="comment">//4.创建Channel</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.创建队列Queue</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line"><span class="comment">         * 1.queue： 队列名称</span></span><br><span class="line"><span class="comment">         * 2.durable： 是否持久化，当mq重启后，还在</span></span><br><span class="line"><span class="comment">         * 3.exclusive：</span></span><br><span class="line"><span class="comment">         *   是否独占，只有一个消费者能够监听这个队列</span></span><br><span class="line"><span class="comment">         *   当Connection关闭时，是否删除队列</span></span><br><span class="line"><span class="comment">         * 4.autoDelete： 是否自动删除。当没有Consumer时，自动删除掉</span></span><br><span class="line"><span class="comment">         * 5.arguments： 参数</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">    <span class="comment">//如果没有一个叫hello_world的队列，则创建该队列，如果有该队列，则不创建</span></span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;hello_world&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.接收消息</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * basicConsume(String queue, boolean autoAck, Consumer callback)</span></span><br><span class="line"><span class="comment">        * 1.queue: 队列名称</span></span><br><span class="line"><span class="comment">        * 2.autoAck： 是否自动确认</span></span><br><span class="line"><span class="comment">        * 3.callback： 回调对象</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 回调方法，当收到消息后，会自动执行该方法</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * 1.consumerTag： 标识</span></span><br><span class="line"><span class="comment">            * 2.envelope： 获取一些信息，交换机，路由key...</span></span><br><span class="line"><span class="comment">            * 3.properties: 配置信息</span></span><br><span class="line"><span class="comment">            * 4.body： 数据</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;consumerTag：&quot;</span> + consumerTag);</span><br><span class="line">            System.out.println(<span class="string">&quot;Exchange：&quot;</span> + envelope.getExchange());</span><br><span class="line">            System.out.println(<span class="string">&quot;RoutingKey：&quot;</span> + envelope.getRoutingKey());</span><br><span class="line">            System.out.println(<span class="string">&quot;properties：&quot;</span> + properties);</span><br><span class="line">            System.out.println(<span class="string">&quot;body：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(<span class="string">&quot;hello_world&quot;</span>, <span class="literal">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源？消费者是监听程序，不需要关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MQ的工作模式"><a href="#MQ的工作模式" class="headerlink" title="MQ的工作模式"></a>MQ的工作模式</h2><h3 id="Work-Queue工作队列模式"><a href="#Work-Queue工作队列模式" class="headerlink" title="Work Queue工作队列模式"></a>Work Queue工作队列模式</h3><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171052332.png" alt="image-20221017105234298"></p><ul><li><p> <strong>Work Queues：</strong>与入门程序的简单模式相比，多了一个或一些消费端，多个消费端共同消费同一个队列中的息。</p></li><li><p><strong>应用场景</strong>：对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度</p></li></ul><p>生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//1.创建连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    <span class="comment">//2.设置参数</span></span><br><span class="line">    factory.setHost(<span class="string">&quot;192.168.184.100&quot;</span>);<span class="comment">//ip 默认值 localhost</span></span><br><span class="line">    factory.setPort(<span class="number">5672</span>);<span class="comment">//端口 默认值5672</span></span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);<span class="comment">//虚拟机 默认值/</span></span><br><span class="line">    factory.setUsername(<span class="string">&quot;dong&quot;</span>);<span class="comment">//用户名 默认 guest</span></span><br><span class="line">    factory.setPassword(<span class="string">&quot;dong&quot;</span>);<span class="comment">//密码 默认 guest</span></span><br><span class="line">    <span class="comment">//3.创建连接 Connection</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="comment">//4.创建Channel</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.创建队列Queue</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line"><span class="comment">    * 1.queue： 队列名称</span></span><br><span class="line"><span class="comment">    * 2.durable： 是否持久化，当mq重启后，还在</span></span><br><span class="line"><span class="comment">    * 3.exclusive：</span></span><br><span class="line"><span class="comment">    *   是否独占，只有一个消费者能够监听这个队列</span></span><br><span class="line"><span class="comment">    *   当Connection关闭时，是否删除队列</span></span><br><span class="line"><span class="comment">    * 4.autoDelete： 是否自动删除。当没有Consumer时，自动删除掉</span></span><br><span class="line"><span class="comment">    * 5.arguments： 参数</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="comment">//如果没有一个叫hello_world的队列，则创建该队列，如果有该队列，则不创建</span></span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;work_queues&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.发送消息</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body)</span></span><br><span class="line"><span class="comment">    * 1.exchange： 交换机的名称。简单模式交换机会使用默认的。</span></span><br><span class="line"><span class="comment">    * 2.routingKey： 路由名称</span></span><br><span class="line"><span class="comment">    * 3.props： 配置信息</span></span><br><span class="line"><span class="comment">    * 4.body： 发送消息数据</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> i + <span class="string">&quot;hello rabbit_mq!!!&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;work_queues&quot;</span>, <span class="literal">null</span>, body.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//7.释放资源</span></span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//1.创建连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    <span class="comment">//2.设置参数</span></span><br><span class="line">    factory.setHost(<span class="string">&quot;192.168.184.100&quot;</span>);<span class="comment">//ip 默认值 localhost</span></span><br><span class="line">    factory.setPort(<span class="number">5672</span>);<span class="comment">//端口 默认值5672</span></span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);<span class="comment">//虚拟机 默认值/</span></span><br><span class="line">    factory.setUsername(<span class="string">&quot;dong&quot;</span>);<span class="comment">//用户名 默认 guest</span></span><br><span class="line">    factory.setPassword(<span class="string">&quot;dong&quot;</span>);<span class="comment">//密码 默认 guest</span></span><br><span class="line">    <span class="comment">//3.创建连接 Connection</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="comment">//4.创建Channel</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.创建队列Queue</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line"><span class="comment">     * 1.queue： 队列名称</span></span><br><span class="line"><span class="comment">     * 2.durable： 是否持久化，当mq重启后，还在</span></span><br><span class="line"><span class="comment">     * 3.exclusive：</span></span><br><span class="line"><span class="comment">     *   是否独占，只有一个消费者能够监听这个队列</span></span><br><span class="line"><span class="comment">     *   当Connection关闭时，是否删除队列</span></span><br><span class="line"><span class="comment">     * 4.autoDelete： 是否自动删除。当没有Consumer时，自动删除掉</span></span><br><span class="line"><span class="comment">     * 5.arguments： 参数</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">//如果没有一个叫hello_world的队列，则创建该队列，如果有该队列，则不创建</span></span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;work_queues&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.接收消息</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * basicConsume(String queue, boolean autoAck, Consumer callback)</span></span><br><span class="line"><span class="comment">    * 1.queue: 队列名称</span></span><br><span class="line"><span class="comment">    * 2.autoAck： 是否自动确认</span></span><br><span class="line"><span class="comment">    * 3.callback： 回调对象</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 回调方法，当收到消息后，会自动执行该方法</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 1.consumerTag： 标识</span></span><br><span class="line"><span class="comment">        * 2.envelope： 获取一些信息，交换机，路由key...</span></span><br><span class="line"><span class="comment">        * 3.properties: 配置信息</span></span><br><span class="line"><span class="comment">        * 4.body： 数据</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">/*System.out.println(&quot;consumerTag：&quot; + consumerTag);</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;Exchange：&quot; + envelope.getExchange());</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;RoutingKey：&quot; + envelope.getRoutingKey());</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;properties：&quot; + properties);*/</span></span><br><span class="line">            System.out.println(<span class="string">&quot;body：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(<span class="string">&quot;work_queues&quot;</span>, <span class="literal">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源？消费者是监听程序，不需要关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//1.创建连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    <span class="comment">//2.设置参数</span></span><br><span class="line">    factory.setHost(<span class="string">&quot;192.168.184.100&quot;</span>);<span class="comment">//ip 默认值 localhost</span></span><br><span class="line">    factory.setPort(<span class="number">5672</span>);<span class="comment">//端口 默认值5672</span></span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);<span class="comment">//虚拟机 默认值/</span></span><br><span class="line">    factory.setUsername(<span class="string">&quot;dong&quot;</span>);<span class="comment">//用户名 默认 guest</span></span><br><span class="line">    factory.setPassword(<span class="string">&quot;dong&quot;</span>);<span class="comment">//密码 默认 guest</span></span><br><span class="line">    <span class="comment">//3.创建连接 Connection</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="comment">//4.创建Channel</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.创建队列Queue</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line"><span class="comment">     * 1.queue： 队列名称</span></span><br><span class="line"><span class="comment">     * 2.durable： 是否持久化，当mq重启后，还在</span></span><br><span class="line"><span class="comment">     * 3.exclusive：</span></span><br><span class="line"><span class="comment">     *   是否独占，只有一个消费者能够监听这个队列</span></span><br><span class="line"><span class="comment">     *   当Connection关闭时，是否删除队列</span></span><br><span class="line"><span class="comment">     * 4.autoDelete： 是否自动删除。当没有Consumer时，自动删除掉</span></span><br><span class="line"><span class="comment">     * 5.arguments： 参数</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">//如果没有一个叫hello_world的队列，则创建该队列，如果有该队列，则不创建</span></span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;work_queues&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.接收消息</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * basicConsume(String queue, boolean autoAck, Consumer callback)</span></span><br><span class="line"><span class="comment">    * 1.queue: 队列名称</span></span><br><span class="line"><span class="comment">    * 2.autoAck： 是否自动确认</span></span><br><span class="line"><span class="comment">    * 3.callback： 回调对象</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 回调方法，当收到消息后，会自动执行该方法</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 1.consumerTag： 标识</span></span><br><span class="line"><span class="comment">        * 2.envelope： 获取一些信息，交换机，路由key...</span></span><br><span class="line"><span class="comment">        * 3.properties: 配置信息</span></span><br><span class="line"><span class="comment">        * 4.body： 数据</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">/*System.out.println(&quot;consumerTag：&quot; + consumerTag);</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;Exchange：&quot; + envelope.getExchange());</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;RoutingKey：&quot; + envelope.getRoutingKey());</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;properties：&quot; + properties);*/</span></span><br><span class="line">            System.out.println(<span class="string">&quot;body：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(<span class="string">&quot;work_queues&quot;</span>, <span class="literal">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源？消费者是监听程序，不需要关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><ol><li><p>在一个队列中如果有多个消费者，那么消费者之间对于同一个消息的关系是<strong>竞争</strong>的关系。</p></li><li><p><strong>Work Queues</strong> 对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度。例如：短信服务部署多个，只需要有一个节点成功发送即。</p></li></ol><h3 id="Pub-Sub-订阅模式"><a href="#Pub-Sub-订阅模式" class="headerlink" title="Pub/Sub 订阅模式"></a>Pub/Sub 订阅模式</h3><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171055713.png" alt="image-20221017105524673"></p><p>多了一台交换机</p><p>在订阅模型中，多了一个 Exchange 角色，而且过程略有变化：</p><ul><li><p>P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</p></li><li><p>C：消费者，消息的接收者，会一直等待消息到来</p></li><li><p>Queue：消息队列，接收消息、缓存消息</p></li><li><p>Exchange：交换机（X）。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种型：</p></li></ul><p>➢ Fanout：广播，将消息交给所有绑定到交换机的队列</p><p>➢ Direct：定向，把消息交给符合指定routing key 的队列</p><p>➢ Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</p><p><strong>Exchange</strong>（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与 Exchange 绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><p>生产者:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//1.创建连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    <span class="comment">//2.设置参数</span></span><br><span class="line">    factory.setHost(<span class="string">&quot;192.168.184.100&quot;</span>);<span class="comment">//ip 默认值 localhost</span></span><br><span class="line">    factory.setPort(<span class="number">5672</span>);<span class="comment">//端口 默认值5672</span></span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);<span class="comment">//虚拟机 默认值/</span></span><br><span class="line">    factory.setUsername(<span class="string">&quot;dong&quot;</span>);<span class="comment">//用户名 默认 guest</span></span><br><span class="line">    factory.setPassword(<span class="string">&quot;dong&quot;</span>);<span class="comment">//密码 默认 guest</span></span><br><span class="line">    <span class="comment">//3.创建连接 Connection</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="comment">//4.创建Channel</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.创建交换机</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * exchangeDeclare(String exchange, BuiltinExchangeType type, boolean durable, boolean autoDelete, boolean internal, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line"><span class="comment">    * 1.exchange:交换机名称</span></span><br><span class="line"><span class="comment">    * 2.type：交换机类型</span></span><br><span class="line"><span class="comment">    *   DIRECT(&quot;direct&quot;),定向</span></span><br><span class="line"><span class="comment">        FANOUT(&quot;fanout&quot;),扇形（广播），发送消息到每一个与之绑定的队列</span></span><br><span class="line"><span class="comment">        TOPIC(&quot;topic&quot;),通配符的方式</span></span><br><span class="line"><span class="comment">        HEADERS(&quot;headers&quot;);参数匹配</span></span><br><span class="line"><span class="comment">     3.durable：是否持久化</span></span><br><span class="line"><span class="comment">     4.autoDelete：是否自动删除</span></span><br><span class="line"><span class="comment">     5.internal：内部使用。一般false</span></span><br><span class="line"><span class="comment">     6.arguments:参数</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;test_fanout&quot;</span>;</span><br><span class="line">    channel.exchangeDeclare(exchangeName, BuiltinExchangeType.FANOUT, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//6.创建队列</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queue1Name</span> <span class="operator">=</span> <span class="string">&quot;test_fanout_queue1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">queue2Name</span> <span class="operator">=</span> <span class="string">&quot;test_fanout_queue2&quot;</span>;</span><br><span class="line">    channel.queueDeclare(queue1Name, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    channel.queueDeclare(queue2Name, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//7.绑定队列和交换机</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * queueBind(String queue, String exchange, String routingKey)</span></span><br><span class="line"><span class="comment">    * 1.queue：队列名称</span></span><br><span class="line"><span class="comment">    * 2.exchange：交换机名称</span></span><br><span class="line"><span class="comment">    * 3.routingKey：路由键，绑定规则     如果交换机的类型为fanout,routingKey设置为&quot;&quot;</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    channel.queueBind(queue1Name, exchangeName, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    channel.queueBind(queue2Name, exchangeName, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//8.发送消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;日志信息：张三调用了finaAll方法...日志级别：info...&quot;</span>;</span><br><span class="line">    channel.basicPublish(exchangeName, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, body.getBytes());</span><br><span class="line">    <span class="comment">//9.释放资源</span></span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//1.创建连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    <span class="comment">//2.设置参数</span></span><br><span class="line">    factory.setHost(<span class="string">&quot;192.168.184.100&quot;</span>);<span class="comment">//ip 默认值 localhost</span></span><br><span class="line">    factory.setPort(<span class="number">5672</span>);<span class="comment">//端口 默认值5672</span></span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);<span class="comment">//虚拟机 默认值/</span></span><br><span class="line">    factory.setUsername(<span class="string">&quot;dong&quot;</span>);<span class="comment">//用户名 默认 guest</span></span><br><span class="line">    factory.setPassword(<span class="string">&quot;dong&quot;</span>);<span class="comment">//密码 默认 guest</span></span><br><span class="line">    <span class="comment">//3.创建连接 Connection</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="comment">//4.创建Channel</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.创建队列Queue</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line"><span class="comment">     * 1.queue： 队列名称</span></span><br><span class="line"><span class="comment">     * 2.durable： 是否持久化，当mq重启后，还在</span></span><br><span class="line"><span class="comment">     * 3.exclusive：</span></span><br><span class="line"><span class="comment">     *   是否独占，只有一个消费者能够监听这个队列</span></span><br><span class="line"><span class="comment">     *   当Connection关闭时，是否删除队列</span></span><br><span class="line"><span class="comment">     * 4.autoDelete： 是否自动删除。当没有Consumer时，自动删除掉</span></span><br><span class="line"><span class="comment">     * 5.arguments： 参数</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">//如果没有一个叫hello_world的队列，则创建该队列，如果有该队列，则不创建</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queue1Name</span> <span class="operator">=</span> <span class="string">&quot;test_fanout_queue1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">queue2Name</span> <span class="operator">=</span> <span class="string">&quot;test_fanout_queue2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.接收消息</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * basicConsume(String queue, boolean autoAck, Consumer callback)</span></span><br><span class="line"><span class="comment">    * 1.queue: 队列名称</span></span><br><span class="line"><span class="comment">    * 2.autoAck： 是否自动确认</span></span><br><span class="line"><span class="comment">    * 3.callback： 回调对象</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 回调方法，当收到消息后，会自动执行该方法</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 1.consumerTag： 标识</span></span><br><span class="line"><span class="comment">        * 2.envelope： 获取一些信息，交换机，路由key...</span></span><br><span class="line"><span class="comment">        * 3.properties: 配置信息</span></span><br><span class="line"><span class="comment">        * 4.body： 数据</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">/*System.out.println(&quot;consumerTag：&quot; + consumerTag);</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;Exchange：&quot; + envelope.getExchange());</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;RoutingKey：&quot; + envelope.getRoutingKey());</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;properties：&quot; + properties);*/</span></span><br><span class="line">            System.out.println(<span class="string">&quot;body:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            System.out.println(<span class="string">&quot;将日志信息打印到控制台....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(queue1Name, <span class="literal">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源？消费者是监听程序，不需要关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//1.创建连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    <span class="comment">//2.设置参数</span></span><br><span class="line">    factory.setHost(<span class="string">&quot;192.168.184.100&quot;</span>);<span class="comment">//ip 默认值 localhost</span></span><br><span class="line">    factory.setPort(<span class="number">5672</span>);<span class="comment">//端口 默认值5672</span></span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);<span class="comment">//虚拟机 默认值/</span></span><br><span class="line">    factory.setUsername(<span class="string">&quot;dong&quot;</span>);<span class="comment">//用户名 默认 guest</span></span><br><span class="line">    factory.setPassword(<span class="string">&quot;dong&quot;</span>);<span class="comment">//密码 默认 guest</span></span><br><span class="line">    <span class="comment">//3.创建连接 Connection</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="comment">//4.创建Channel</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.创建队列Queue</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line"><span class="comment">     * 1.queue： 队列名称</span></span><br><span class="line"><span class="comment">     * 2.durable： 是否持久化，当mq重启后，还在</span></span><br><span class="line"><span class="comment">     * 3.exclusive：</span></span><br><span class="line"><span class="comment">     *   是否独占，只有一个消费者能够监听这个队列</span></span><br><span class="line"><span class="comment">     *   当Connection关闭时，是否删除队列</span></span><br><span class="line"><span class="comment">     * 4.autoDelete： 是否自动删除。当没有Consumer时，自动删除掉</span></span><br><span class="line"><span class="comment">     * 5.arguments： 参数</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">//如果没有一个叫hello_world的队列，则创建该队列，如果有该队列，则不创建</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queue1Name</span> <span class="operator">=</span> <span class="string">&quot;test_fanout_queue1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">queue2Name</span> <span class="operator">=</span> <span class="string">&quot;test_fanout_queue2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.接收消息</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * basicConsume(String queue, boolean autoAck, Consumer callback)</span></span><br><span class="line"><span class="comment">    * 1.queue: 队列名称</span></span><br><span class="line"><span class="comment">    * 2.autoAck： 是否自动确认</span></span><br><span class="line"><span class="comment">    * 3.callback： 回调对象</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 回调方法，当收到消息后，会自动执行该方法</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 1.consumerTag： 标识</span></span><br><span class="line"><span class="comment">        * 2.envelope： 获取一些信息，交换机，路由key...</span></span><br><span class="line"><span class="comment">        * 3.properties: 配置信息</span></span><br><span class="line"><span class="comment">        * 4.body： 数据</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">/*System.out.println(&quot;consumerTag：&quot; + consumerTag);</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;Exchange：&quot; + envelope.getExchange());</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;RoutingKey：&quot; + envelope.getRoutingKey());</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;properties：&quot; + properties);*/</span></span><br><span class="line">            System.out.println(<span class="string">&quot;body:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            System.out.println(<span class="string">&quot;将日志信息保存数据库....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(queue2Name, <span class="literal">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源？消费者是监听程序，不需要关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>小结</strong></p><ol><li><p>交换机需要与队列进行绑定，绑定之后；一个消息可以被多个消费者都收到。</p></li><li><p>发布订阅模式与工作队列模式的区别：</p><ul><li><p>工作队列模式不用定义交换机，而发布/订阅模式需要定义交换机</p></li><li><p>发布/订阅模式的生产方是面向交换机发送消息，工作队列模式的生产方是面向队列发送消息(底层使用默认交换机)</p></li><li><p>发布/订阅模式需要设置队列和交换机的绑定，工作队列模式不需要设置，实际上工作队列模式会将队列绑定到默认的交换机</p></li></ul></li></ol><h3 id="Routing路由模式"><a href="#Routing路由模式" class="headerlink" title="Routing路由模式"></a>Routing路由模式</h3><ul><li><p>队列与交换机的绑定，不能是任意绑定了，而是要指定一个 RoutingKey（路由key）</p></li><li><p>消息的发送方在向 Exchange 发送消息时，也必须指定消息的 RoutingKey</p></li><li><p>Exchange 不再把消息交给每一个绑定的队列，而是根据消息的 Routing Key 进行判断，<code>只有队列的Routingkey 与消息的 Routing key 完全一致</code>，才会接收到消息</p></li></ul><p>图解：<img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171101955.png" alt="image-20221017110151906"></p><ul><li><p>P：生产者，向 Exchange 发送消息，发送消息时，会指定一个routing key</p></li><li><p>X：Exchange（交换机），接收生产者的消息，然后把消息递交给与 routing key 完全匹配的队列</p></li><li><p>C1：消费者，其所在队列指定了需要 routing key 为 error 的消息</p></li><li><p>C2：消费者，其所在队列指定了需要 routing key 为 info、error、warning 的消息</p></li></ul><p>生产者:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//1.创建连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    <span class="comment">//2.设置参数</span></span><br><span class="line">    factory.setHost(<span class="string">&quot;192.168.184.100&quot;</span>);<span class="comment">//ip 默认值 localhost</span></span><br><span class="line">    factory.setPort(<span class="number">5672</span>);<span class="comment">//端口 默认值5672</span></span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);<span class="comment">//虚拟机 默认值/</span></span><br><span class="line">    factory.setUsername(<span class="string">&quot;dong&quot;</span>);<span class="comment">//用户名 默认 guest</span></span><br><span class="line">    factory.setPassword(<span class="string">&quot;dong&quot;</span>);<span class="comment">//密码 默认 guest</span></span><br><span class="line">    <span class="comment">//3.创建连接 Connection</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="comment">//4.创建Channel</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.创建交换机</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * exchangeDeclare(String exchange, BuiltinExchangeType type, boolean durable, boolean autoDelete, boolean internal, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line"><span class="comment">    * 1.exchange:交换机名称</span></span><br><span class="line"><span class="comment">    * 2.type：交换机类型</span></span><br><span class="line"><span class="comment">    *   DIRECT(&quot;direct&quot;),定向</span></span><br><span class="line"><span class="comment">        FANOUT(&quot;fanout&quot;),扇形（广播），发送消息到每一个与之绑定的队列</span></span><br><span class="line"><span class="comment">        TOPIC(&quot;topic&quot;),通配符的方式</span></span><br><span class="line"><span class="comment">        HEADERS(&quot;headers&quot;);参数匹配</span></span><br><span class="line"><span class="comment">     3.durable：是否持久化</span></span><br><span class="line"><span class="comment">     4.autoDelete：是否自动删除</span></span><br><span class="line"><span class="comment">     5.internal：内部使用。一般false</span></span><br><span class="line"><span class="comment">     6.arguments:参数</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;test_direct&quot;</span>;</span><br><span class="line">    channel.exchangeDeclare(exchangeName, BuiltinExchangeType.DIRECT, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//6.创建队列</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queue1Name</span> <span class="operator">=</span> <span class="string">&quot;test_direct_queue1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">queue2Name</span> <span class="operator">=</span> <span class="string">&quot;test_direct_queue2&quot;</span>;</span><br><span class="line">    channel.queueDeclare(queue1Name, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    channel.queueDeclare(queue2Name, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//7.绑定队列和交换机</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * queueBind(String queue, String exchange, String routingKey)</span></span><br><span class="line"><span class="comment">    * 1.queue：队列名称</span></span><br><span class="line"><span class="comment">    * 2.exchange：交换机名称</span></span><br><span class="line"><span class="comment">    * 3.routingKey：路由键，绑定规则     如果交换机的类型为fanout,routingKey设置为&quot;&quot;</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="comment">//队列1的绑定error</span></span><br><span class="line">    channel.queueBind(queue1Name, exchangeName, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    <span class="comment">//队列2的绑定info error warning</span></span><br><span class="line">    channel.queueBind(queue2Name, exchangeName, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">    channel.queueBind(queue2Name, exchangeName, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    channel.queueBind(queue2Name, exchangeName, <span class="string">&quot;warning&quot;</span>);</span><br><span class="line">    <span class="comment">//8.发送消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;日志信息：张三调用了delete方法...出错了...日志级别：error...&quot;</span>;</span><br><span class="line">    channel.basicPublish(exchangeName, <span class="string">&quot;error&quot;</span>, <span class="literal">null</span>, body.getBytes());</span><br><span class="line">    <span class="comment">//9.释放资源</span></span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//1.创建连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    <span class="comment">//2.设置参数</span></span><br><span class="line">    factory.setHost(<span class="string">&quot;192.168.184.100&quot;</span>);<span class="comment">//ip 默认值 localhost</span></span><br><span class="line">    factory.setPort(<span class="number">5672</span>);<span class="comment">//端口 默认值5672</span></span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);<span class="comment">//虚拟机 默认值/</span></span><br><span class="line">    factory.setUsername(<span class="string">&quot;dong&quot;</span>);<span class="comment">//用户名 默认 guest</span></span><br><span class="line">    factory.setPassword(<span class="string">&quot;dong&quot;</span>);<span class="comment">//密码 默认 guest</span></span><br><span class="line">    <span class="comment">//3.创建连接 Connection</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="comment">//4.创建Channel</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.创建队列Queue</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line"><span class="comment">     * 1.queue： 队列名称</span></span><br><span class="line"><span class="comment">     * 2.durable： 是否持久化，当mq重启后，还在</span></span><br><span class="line"><span class="comment">     * 3.exclusive：</span></span><br><span class="line"><span class="comment">     *   是否独占，只有一个消费者能够监听这个队列</span></span><br><span class="line"><span class="comment">     *   当Connection关闭时，是否删除队列</span></span><br><span class="line"><span class="comment">     * 4.autoDelete： 是否自动删除。当没有Consumer时，自动删除掉</span></span><br><span class="line"><span class="comment">     * 5.arguments： 参数</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">//如果没有一个叫hello_world的队列，则创建该队列，如果有该队列，则不创建</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queue1Name</span> <span class="operator">=</span> <span class="string">&quot;test_direct_queue1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">queue2Name</span> <span class="operator">=</span> <span class="string">&quot;test_direct_queue2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.接收消息</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * basicConsume(String queue, boolean autoAck, Consumer callback)</span></span><br><span class="line"><span class="comment">    * 1.queue: 队列名称</span></span><br><span class="line"><span class="comment">    * 2.autoAck： 是否自动确认</span></span><br><span class="line"><span class="comment">    * 3.callback： 回调对象</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 回调方法，当收到消息后，会自动执行该方法</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 1.consumerTag： 标识</span></span><br><span class="line"><span class="comment">        * 2.envelope： 获取一些信息，交换机，路由key...</span></span><br><span class="line"><span class="comment">        * 3.properties: 配置信息</span></span><br><span class="line"><span class="comment">        * 4.body： 数据</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">/*System.out.println(&quot;consumerTag：&quot; + consumerTag);</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;Exchange：&quot; + envelope.getExchange());</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;RoutingKey：&quot; + envelope.getRoutingKey());</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;properties：&quot; + properties);*/</span></span><br><span class="line">            System.out.println(<span class="string">&quot;body:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            System.out.println(<span class="string">&quot;将日志信息存储在数据库....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(queue1Name, <span class="literal">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源？消费者是监听程序，不需要关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//1.创建连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    <span class="comment">//2.设置参数</span></span><br><span class="line">    factory.setHost(<span class="string">&quot;192.168.184.100&quot;</span>);<span class="comment">//ip 默认值 localhost</span></span><br><span class="line">    factory.setPort(<span class="number">5672</span>);<span class="comment">//端口 默认值5672</span></span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);<span class="comment">//虚拟机 默认值/</span></span><br><span class="line">    factory.setUsername(<span class="string">&quot;dong&quot;</span>);<span class="comment">//用户名 默认 guest</span></span><br><span class="line">    factory.setPassword(<span class="string">&quot;dong&quot;</span>);<span class="comment">//密码 默认 guest</span></span><br><span class="line">    <span class="comment">//3.创建连接 Connection</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="comment">//4.创建Channel</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.创建队列Queue</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line"><span class="comment">     * 1.queue： 队列名称</span></span><br><span class="line"><span class="comment">     * 2.durable： 是否持久化，当mq重启后，还在</span></span><br><span class="line"><span class="comment">     * 3.exclusive：</span></span><br><span class="line"><span class="comment">     *   是否独占，只有一个消费者能够监听这个队列</span></span><br><span class="line"><span class="comment">     *   当Connection关闭时，是否删除队列</span></span><br><span class="line"><span class="comment">     * 4.autoDelete： 是否自动删除。当没有Consumer时，自动删除掉</span></span><br><span class="line"><span class="comment">     * 5.arguments： 参数</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">//如果没有一个叫hello_world的队列，则创建该队列，如果有该队列，则不创建</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queue1Name</span> <span class="operator">=</span> <span class="string">&quot;test_direct_queue1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">queue2Name</span> <span class="operator">=</span> <span class="string">&quot;test_direct_queue2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.接收消息</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * basicConsume(String queue, boolean autoAck, Consumer callback)</span></span><br><span class="line"><span class="comment">    * 1.queue: 队列名称</span></span><br><span class="line"><span class="comment">    * 2.autoAck： 是否自动确认</span></span><br><span class="line"><span class="comment">    * 3.callback： 回调对象</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 回调方法，当收到消息后，会自动执行该方法</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 1.consumerTag： 标识</span></span><br><span class="line"><span class="comment">        * 2.envelope： 获取一些信息，交换机，路由key...</span></span><br><span class="line"><span class="comment">        * 3.properties: 配置信息</span></span><br><span class="line"><span class="comment">        * 4.body： 数据</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">/*System.out.println(&quot;consumerTag：&quot; + consumerTag);</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;Exchange：&quot; + envelope.getExchange());</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;RoutingKey：&quot; + envelope.getRoutingKey());</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;properties：&quot; + properties);*/</span></span><br><span class="line">            System.out.println(<span class="string">&quot;body:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            System.out.println(<span class="string">&quot;将日志信息打印到控制台....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(queue2Name, <span class="literal">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源？消费者是监听程序，不需要关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Routing</strong> 模式要求队列在绑定交换机时要指定 <strong>routing key</strong>，消息会转发到符合 routing key 的队列。</p><h3 id="Topics通配符模式"><a href="#Topics通配符模式" class="headerlink" title="Topics通配符模式"></a>Topics通配符模式</h3><ul><li><p>Topic 类型与 Direct 相比，都是可以根据 RoutingKey 把消息路由到不同的队列。只不过 Topic 类型Exchange 可以让队列在绑定 Routing key 的时候使用<strong>通配符</strong>！</p></li><li><p>Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert </p></li><li><p>通配符规则：# 匹配一个或多个词，* 匹配不多不少恰好1个词，例如：item.# 能够匹配 item.insert.abc 或者 item.insert，item.* 只能匹配 item.insert</p></li></ul><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171106259.png" alt="image-20221017110625191"></p><ul><li><p>红色 Queue：绑定的是 usa.# ，因此凡是以 usa. 开头的 routing key 都会被匹配到</p></li><li><p>黄色 Queue：绑定的是 #.news ，因此凡是以 .news 结尾的 routing key 都会被匹配</p></li></ul><p>生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//1.创建连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    <span class="comment">//2.设置参数</span></span><br><span class="line">    factory.setHost(<span class="string">&quot;192.168.184.100&quot;</span>);<span class="comment">//ip 默认值 localhost</span></span><br><span class="line">    factory.setPort(<span class="number">5672</span>);<span class="comment">//端口 默认值5672</span></span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);<span class="comment">//虚拟机 默认值/</span></span><br><span class="line">    factory.setUsername(<span class="string">&quot;dong&quot;</span>);<span class="comment">//用户名 默认 guest</span></span><br><span class="line">    factory.setPassword(<span class="string">&quot;dong&quot;</span>);<span class="comment">//密码 默认 guest</span></span><br><span class="line">    <span class="comment">//3.创建连接 Connection</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="comment">//4.创建Channel</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.创建交换机</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * exchangeDeclare(String exchange, BuiltinExchangeType type, boolean durable, boolean autoDelete, boolean internal, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line"><span class="comment">    * 1.exchange:交换机名称</span></span><br><span class="line"><span class="comment">    * 2.type：交换机类型</span></span><br><span class="line"><span class="comment">    *   DIRECT(&quot;direct&quot;),定向</span></span><br><span class="line"><span class="comment">        FANOUT(&quot;fanout&quot;),扇形（广播），发送消息到每一个与之绑定的队列</span></span><br><span class="line"><span class="comment">        TOPIC(&quot;topic&quot;),通配符的方式</span></span><br><span class="line"><span class="comment">        HEADERS(&quot;headers&quot;);参数匹配</span></span><br><span class="line"><span class="comment">     3.durable：是否持久化</span></span><br><span class="line"><span class="comment">     4.autoDelete：是否自动删除</span></span><br><span class="line"><span class="comment">     5.internal：内部使用。一般false</span></span><br><span class="line"><span class="comment">     6.arguments:参数</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;test_topic&quot;</span>;</span><br><span class="line">    channel.exchangeDeclare(exchangeName, BuiltinExchangeType.TOPIC, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//6.创建队列</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queue1Name</span> <span class="operator">=</span> <span class="string">&quot;test_topic_queue1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">queue2Name</span> <span class="operator">=</span> <span class="string">&quot;test_topic_queue2&quot;</span>;</span><br><span class="line">    channel.queueDeclare(queue1Name, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    channel.queueDeclare(queue2Name, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//7.绑定队列和交换机</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * queueBind(String queue, String exchange, String routingKey)</span></span><br><span class="line"><span class="comment">    * 1.queue：队列名称</span></span><br><span class="line"><span class="comment">    * 2.exchange：交换机名称</span></span><br><span class="line"><span class="comment">    * 3.routingKey：路由键，绑定规则     如果交换机的类型为fanout,routingKey设置为&quot;&quot;</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="comment">//routing key 系统的名称 日志的级别</span></span><br><span class="line">    <span class="comment">//需求：所有error级别的日志存在数据库，所有order系统的日志存在数据库</span></span><br><span class="line">    channel.queueBind(queue1Name, exchangeName, <span class="string">&quot;#.error&quot;</span>);</span><br><span class="line">    channel.queueBind(queue1Name, exchangeName, <span class="string">&quot;order.*&quot;</span>);</span><br><span class="line">    channel.queueBind(queue2Name, exchangeName, <span class="string">&quot;*.*&quot;</span>);</span><br><span class="line">    <span class="comment">//8.发送消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;日志信息：张三调用了finaAll方法...日志级别：info...&quot;</span>;</span><br><span class="line">    channel.basicPublish(exchangeName, <span class="string">&quot;.error&quot;</span>, <span class="literal">null</span>, body.getBytes());</span><br><span class="line">    <span class="comment">//9.释放资源</span></span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//1.创建连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    <span class="comment">//2.设置参数</span></span><br><span class="line">    factory.setHost(<span class="string">&quot;192.168.184.100&quot;</span>);<span class="comment">//ip 默认值 localhost</span></span><br><span class="line">    factory.setPort(<span class="number">5672</span>);<span class="comment">//端口 默认值5672</span></span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);<span class="comment">//虚拟机 默认值/</span></span><br><span class="line">    factory.setUsername(<span class="string">&quot;dong&quot;</span>);<span class="comment">//用户名 默认 guest</span></span><br><span class="line">    factory.setPassword(<span class="string">&quot;dong&quot;</span>);<span class="comment">//密码 默认 guest</span></span><br><span class="line">    <span class="comment">//3.创建连接 Connection</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="comment">//4.创建Channel</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.创建队列Queue</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line"><span class="comment">     * 1.queue： 队列名称</span></span><br><span class="line"><span class="comment">     * 2.durable： 是否持久化，当mq重启后，还在</span></span><br><span class="line"><span class="comment">     * 3.exclusive：</span></span><br><span class="line"><span class="comment">     *   是否独占，只有一个消费者能够监听这个队列</span></span><br><span class="line"><span class="comment">     *   当Connection关闭时，是否删除队列</span></span><br><span class="line"><span class="comment">     * 4.autoDelete： 是否自动删除。当没有Consumer时，自动删除掉</span></span><br><span class="line"><span class="comment">     * 5.arguments： 参数</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">//如果没有一个叫hello_world的队列，则创建该队列，如果有该队列，则不创建</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queue1Name</span> <span class="operator">=</span> <span class="string">&quot;test_topic_queue1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">queue2Name</span> <span class="operator">=</span> <span class="string">&quot;test_topic_queue2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.接收消息</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * basicConsume(String queue, boolean autoAck, Consumer callback)</span></span><br><span class="line"><span class="comment">    * 1.queue: 队列名称</span></span><br><span class="line"><span class="comment">    * 2.autoAck： 是否自动确认</span></span><br><span class="line"><span class="comment">    * 3.callback： 回调对象</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 回调方法，当收到消息后，会自动执行该方法</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 1.consumerTag： 标识</span></span><br><span class="line"><span class="comment">        * 2.envelope： 获取一些信息，交换机，路由key...</span></span><br><span class="line"><span class="comment">        * 3.properties: 配置信息</span></span><br><span class="line"><span class="comment">        * 4.body： 数据</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">/*System.out.println(&quot;consumerTag：&quot; + consumerTag);</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;Exchange：&quot; + envelope.getExchange());</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;RoutingKey：&quot; + envelope.getRoutingKey());</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;properties：&quot; + properties);*/</span></span><br><span class="line">            System.out.println(<span class="string">&quot;body:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            System.out.println(<span class="string">&quot;将日志信息存入数据库....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(queue1Name, <span class="literal">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源？消费者是监听程序，不需要关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//1.创建连接工厂</span></span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    <span class="comment">//2.设置参数</span></span><br><span class="line">    factory.setHost(<span class="string">&quot;192.168.184.100&quot;</span>);<span class="comment">//ip 默认值 localhost</span></span><br><span class="line">    factory.setPort(<span class="number">5672</span>);<span class="comment">//端口 默认值5672</span></span><br><span class="line">    factory.setVirtualHost(<span class="string">&quot;/itcast&quot;</span>);<span class="comment">//虚拟机 默认值/</span></span><br><span class="line">    factory.setUsername(<span class="string">&quot;dong&quot;</span>);<span class="comment">//用户名 默认 guest</span></span><br><span class="line">    factory.setPassword(<span class="string">&quot;dong&quot;</span>);<span class="comment">//密码 默认 guest</span></span><br><span class="line">    <span class="comment">//3.创建连接 Connection</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="comment">//4.创建Channel</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.创建队列Queue</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line"><span class="comment">     * 1.queue： 队列名称</span></span><br><span class="line"><span class="comment">     * 2.durable： 是否持久化，当mq重启后，还在</span></span><br><span class="line"><span class="comment">     * 3.exclusive：</span></span><br><span class="line"><span class="comment">     *   是否独占，只有一个消费者能够监听这个队列</span></span><br><span class="line"><span class="comment">     *   当Connection关闭时，是否删除队列</span></span><br><span class="line"><span class="comment">     * 4.autoDelete： 是否自动删除。当没有Consumer时，自动删除掉</span></span><br><span class="line"><span class="comment">     * 5.arguments： 参数</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">//如果没有一个叫hello_world的队列，则创建该队列，如果有该队列，则不创建</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queue1Name</span> <span class="operator">=</span> <span class="string">&quot;test_topic_queue1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">queue2Name</span> <span class="operator">=</span> <span class="string">&quot;test_topic_queue2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.接收消息</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * basicConsume(String queue, boolean autoAck, Consumer callback)</span></span><br><span class="line"><span class="comment">    * 1.queue: 队列名称</span></span><br><span class="line"><span class="comment">    * 2.autoAck： 是否自动确认</span></span><br><span class="line"><span class="comment">    * 3.callback： 回调对象</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 回调方法，当收到消息后，会自动执行该方法</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 1.consumerTag： 标识</span></span><br><span class="line"><span class="comment">        * 2.envelope： 获取一些信息，交换机，路由key...</span></span><br><span class="line"><span class="comment">        * 3.properties: 配置信息</span></span><br><span class="line"><span class="comment">        * 4.body： 数据</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">/*System.out.println(&quot;consumerTag：&quot; + consumerTag);</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;Exchange：&quot; + envelope.getExchange());</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;RoutingKey：&quot; + envelope.getRoutingKey());</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;properties：&quot; + properties);*/</span></span><br><span class="line">            System.out.println(<span class="string">&quot;body:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            System.out.println(<span class="string">&quot;将日志信息打印控制台....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.basicConsume(queue2Name, <span class="literal">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源？消费者是监听程序，不需要关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><p>Topic 主题模式可以实现 Pub/Sub 发布与订阅模式和 Routing 路由模式的功能，只是 Topic 在配置routing key 的时候可以使用通配符，显得更加灵活。</p><h3 id="工作模式总结"><a href="#工作模式总结" class="headerlink" title="工作模式总结"></a>工作模式总结</h3><ol><li>简单模式 HelloWorld</li></ol><p>一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）。</p><ol start="2"><li>工作队列模式 Work Queue</li></ol><p>一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）。</p><ol start="3"><li>发布订阅模式 Publish/subscribe</li></ol><p>需要设置类型为 fanout 的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列。</p><ol start="4"><li>路由模式 Routing</li></ol><p>需要设置类型为 direct 的交换机，交换机和队列进行绑定，并且指定 routing key，当发送消息到交换机</p><p>后，交换机会根据 routing key 将消息发送到对应的队列。</p><ol start="5"><li>通配符模式 Topic</li></ol><p>需要设置类型为 topic 的交换机，交换机和队列进行绑定，并且指定通配符方式的 routing key，当发送</p><p>消息到交换机后，交换机会根据 routing key 将消息发送到对应的队列。</p><h2 id="Spring-Boot整合Rabbit-MQ"><a href="#Spring-Boot整合Rabbit-MQ" class="headerlink" title="Spring Boot整合Rabbit MQ"></a>Spring Boot整合Rabbit MQ</h2><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171110248.png" alt="image-20221017111012195"></p><h3 id="创建Boot工程"><a href="#创建Boot工程" class="headerlink" title="创建Boot工程"></a>创建Boot工程</h3><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>需要的依赖是springboot整合rabbitmq, spring-boot-starter-amqp是springboot整合rabbitmq的包。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置Rabbit-MQ的基本信息"><a href="#配置Rabbit-MQ的基本信息" class="headerlink" title="配置Rabbit MQ的基本信息"></a>配置Rabbit MQ的基本信息</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.184</span><span class="number">.100</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">dong</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">dong</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/itcast</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br></pre></td></tr></table></figure><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>生产者编写代码发送信息。</p><p>生产者编写Rabbit MQ的配置信息。配置交换机、队列以及队列和交换机的绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;boot_topic_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;boot_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;bootExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">bootExchange</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;bootQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">bootQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.队列交换机绑定关系 Binding</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 1.知道那个队列</span></span><br><span class="line"><span class="comment">    * 2.知道那个交换机</span></span><br><span class="line"><span class="comment">    * 3.routing key</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueueExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;bootQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;bootExchange&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;boot.#&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者利用<code>RabbitTemplate</code>来发送信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.注入RabbitTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSend</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_NAME, <span class="string">&quot;boot.haha&quot;</span>, <span class="string">&quot;boot mq hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者编写消息监听器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;boot_queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ListenerQueue</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(message);</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><ul><li><p>使用 Spring 整合 RabbitMQ 将组件全部使用配置方式实现，简化编码</p></li><li><p>Spring 提供 RabbitTemplate 简化发送消息 API</p></li><li><p>使用监听机制简化消费者编码</p></li></ul><h2 id="Rabbit-MQ高级特性"><a href="#Rabbit-MQ高级特性" class="headerlink" title="Rabbit MQ高级特性"></a>Rabbit MQ高级特性</h2><h3 id="消息的可靠投递"><a href="#消息的可靠投递" class="headerlink" title="消息的可靠投递"></a>消息的可靠投递</h3><p>在使用 RabbitMQ 的时候，作为消息发送方希望杜绝任何消息丢失或者投递失败场景。RabbitMQ 为我们提供了两种方式用来控制消息的投递可靠性模式。</p><ul><li><p>confirm 确认模式</p></li><li><p>return 退回模式</p></li></ul><p>rabbitmq 整个消息投递的路径为：</p><p>producer—&gt;rabbitmq broker—&gt;exchange—&gt;queue—&gt;consumer</p><ul><li><p>消息从 producer 到 exchange 则会返回一个 confirmCallback(confirm 确认模式) 。</p></li><li><p>消息从 exchange–&gt;queue 投递失败则会返回一个 returnCallback(return 退回模式) 。</p></li></ul><p>我们将利用这两个 callback 控制消息的可靠性投递</p><p>编写配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_exchange_confirm&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_queue_confirm&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">confirmExchange</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ExchangeBuilder.directExchange(EXCHANGE_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.队列交换机绑定关系 Binding</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 1.知道那个队列</span></span><br><span class="line"><span class="comment">    * 2.知道那个交换机</span></span><br><span class="line"><span class="comment">    * 3.routing key</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueueExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;confirm&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置RabbitMQ的基本信息 ip端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.184</span><span class="number">.100</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">dong</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">dong</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/itcast</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="comment"># 确认模式开启</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br><span class="line">    <span class="comment"># 回退模式开启</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="confirm确认模式"><a href="#confirm确认模式" class="headerlink" title="confirm确认模式"></a>confirm确认模式</h4><p>确认模式：</p><ul><li>步骤：<ul><li><ol><li>确认模式开启：publisher-confirm-type: correlated</li></ol></li><li><ol start="2"><li>在rabbitTemplate定义confirmCallBack回调函数</li></ol></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确认模式：</span></span><br><span class="line"><span class="comment">     *  步骤：</span></span><br><span class="line"><span class="comment">     *      1. 确认模式开启：publisher-confirm-type: correlated</span></span><br><span class="line"><span class="comment">     *      2. 在rabbitTemplate定义confirmCallBack回调函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConfirm</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 定义回调</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback()&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> correlationData 相关的配置信息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> ack exchange交换机 是否成功收到了消息。true 成功， false 失败</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> cause 失败原因</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;confirm running...&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">                    <span class="comment">//接收成功</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;accepting success:&quot;</span> + cause);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//接收失败</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;accepting fail:&quot;</span> + cause);</span><br><span class="line">                    <span class="comment">//做一些处理，让消息再次发送</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;test_exchange_confirm&quot;</span>, <span class="string">&quot;confirm&quot;</span>, <span class="string">&quot;message confirm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="return退回模式"><a href="#return退回模式" class="headerlink" title="return退回模式"></a>return退回模式</h4><p>回退模式： 当消息发送给 Exchange 后，Exchange 路由到 Queue 失败后才会执行 ReturnCallBack</p><ul><li>步骤：<ol><li>开启回退模式 publisher-returns: true</li><li>设置ReturnCallBack</li><li>设置Exchange处理消息的模式：<ol><li> 如果消息没有路由到Queue,则丢弃消息（默认）</li><li>如果消息没有路由到Queue,返回给消息发送方ReturnCallBack</li></ol></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回退模式： 当消息发送给 Exchange 后，Exchange 路由到 Queue 失败后才会执行 ReturnCallBack</span></span><br><span class="line"><span class="comment">     *  步骤：</span></span><br><span class="line"><span class="comment">     *      1. 开启回退模式 publisher-returns: true</span></span><br><span class="line"><span class="comment">     *      2. 设置ReturnCallBack</span></span><br><span class="line"><span class="comment">     *      3. 设置Exchange处理消息的模式：</span></span><br><span class="line"><span class="comment">     *         3.1 如果消息没有路由到Queue,则丢弃消息（默认）</span></span><br><span class="line"><span class="comment">     *         3.2 如果消息没有路由到Queue,返回给消息发送方ReturnCallBack</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testReturn</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置交换机处理失败消息的模式</span></span><br><span class="line">    rabbitTemplate.setMandatory(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 设置ReturnCallBack</span></span><br><span class="line">    rabbitTemplate.setReturnCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnCallback()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> message 消息对象</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> replyCode 错误码</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> replyText 错误信息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> exchange 交换机</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> routingKey 路由器</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(Message message, <span class="type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;return running...&quot;</span>);</span><br><span class="line">            System.out.println(message);</span><br><span class="line">            System.out.println(replyCode);</span><br><span class="line">            System.out.println(replyText);</span><br><span class="line">            System.out.println(exchange);</span><br><span class="line">            System.out.println(routingKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;test_exchange_confirm&quot;</span>, <span class="string">&quot;confirm2&quot;</span>, <span class="string">&quot;message confirm&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息的可靠投递小结"><a href="#消息的可靠投递小结" class="headerlink" title="消息的可靠投递小结"></a>消息的可靠投递小结</h4><p>➢ 配置application.yml的publisher-confirm-type: correlated 开启确认模式。</p><p>➢ 使用rabbitTemplate.setConfirmCallback设置回调函数。当消息发送到exchange后回调confirm方法。在方法中判断ack，如果为true，则发送成功，如果为false，则发送失败，需要处理。</p><p>➢ 配置application.yml的publisher-returns: true开启 退回模式。</p><p>➢ 使用rabbitTemplate.setReturnCallback设置退回函数，当消息从exchange路由到queue失败后，如果设置了rabbitTemplate.setMandatory(true)参数，则会将消息退回给producer。并执行回调函数returnedMessage。</p><p>➢ 在RabbitMQ中也提供了事务机制，但是性能较差，此处不做讲解。</p><p>使用channel下列方法，完成事务控制：</p><p>txSelect(), 用于将当前channel设置成transaction模式</p><p>txCommit()，用于提交事务</p><p>txRollback(),用于回滚事务</p><h3 id="Consumer-Ack"><a href="#Consumer-Ack" class="headerlink" title="Consumer Ack"></a>Consumer Ack</h3><p>ack指Acknowledge，确认。 表示消费端收到消息后的确认方式。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类比<span class="keyword">confirm</span></span><br><span class="line"><span class="keyword">confirm</span>是consumer到broker</span><br><span class="line">ack是broker到consumer</span><br></pre></td></tr></table></figure><p>有三种确认方式：</p><ul><li><p>自动确认：acknowledge=”none”</p></li><li><p>手动确认：acknowledge=”manual”</p></li><li><p>根据异常情况确认：acknowledge=”auto”（这种方式使用麻烦，不作讲解）</p></li></ul><p>其中自动确认是指，当消息一旦被Consumer接收到，则自动确认收到，并将相应 message 从 RabbitMQ 的消息缓存中移除。但是在实际业务处理中，很可能消息接收到，业务处理出现异常，那么该消息就会丢失。</p><p>如果设置了手动确认方式，则需要在业务处理成功后，调用channel.basicAck()，手动签收。</p><p>如果出现异常，则调用channel.basicNack()方法，让其自动重新发送消息。</p><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * Consumer ACK机制：</span></span><br><span class="line"><span class="comment"> *   1. 设置手动签收 acknowledge-mode: manual</span></span><br><span class="line"><span class="comment"> *   2. 让监听器实现 ChannelAwareMessageListener</span></span><br><span class="line"><span class="comment"> *   3. 如果消息成功处理，则调用channel的basicAck()签收</span></span><br><span class="line"><span class="comment"> *   4. 如果消息处理失败，则调用channel的basicNck()拒绝签收，broker重新发给consumer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AckListener</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;test_queue_confirm&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 接受转换消息</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 处理业务逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;handle business logic&quot;</span>);</span><br><span class="line">            <span class="comment">//int i = 3 / 0;</span></span><br><span class="line">            <span class="comment">//3. 手动签收</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">true</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//4. 拒绝签收</span></span><br><span class="line">            <span class="comment">/***</span></span><br><span class="line"><span class="comment">             * 第三个参数requeue：重回队列。如果设置为true,则重回queue，broker会重新发送该消息给消费端</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicNack(deliveryTag, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//channel.basicReject(deliveryTag, true);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置RabbitMQ的基本信息 ip端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.184</span><span class="number">.100</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">dong</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">dong</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/itcast</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">direct:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure><h4 id="Consumer-Ack-小结"><a href="#Consumer-Ack-小结" class="headerlink" title="Consumer Ack 小结"></a>Consumer Ack 小结</h4><p>➢ 在appliacation.yml标签中设置acknowledge-mode属性，设置ack方式 none：自动确认，manual：手动确认</p><p>➢ 如果在消费端没有出现异常，则调用channel.basicAck(deliveryTag,false);方法确认签收消息</p><p>➢ 如果出现异常，则在catch中调用 basicNack或 basicReject，拒绝消息，让MQ重新发送消息。</p><h3 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h3><p>请求瞬间增多，每秒5000个请求</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210180831992.png" alt="image-20221018083146873"></p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * Consumer 限流机制：</span></span><br><span class="line"><span class="comment"> * 1. 确保ack机制为手动确认。</span></span><br><span class="line"><span class="comment"> * 2. 配置属性</span></span><br><span class="line"><span class="comment"> *  perfetch = 1，表示消费端每次从mq拉取一天消息来消费，直到手动确认消费完毕后，才会继续拉取下一条消息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QosListener</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;test_queue_confirm&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//1. 获取消息</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 处理业务逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 签收</span></span><br><span class="line">        <span class="comment">//channel.basicAck(message.getMessageProperties().getDeliveryTag(), true);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置RabbitMQ的基本信息 ip端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.184</span><span class="number">.100</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">dong</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">dong</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/itcast</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="消费端限流小结"><a href="#消费端限流小结" class="headerlink" title="消费端限流小结"></a>消费端限流小结</h4><p>➢ 在alllication.yml 中配置 prefetch属性设置消费端一次拉取多少消息</p><p>➢ 消费端的确认模式一定为手动确认。acknowledge=”manual”</p><h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>➢ TTL 全称 Time To Live（存活时间/过期时间）。</p><p>➢ 当消息到达存活时间后，还没有被消费，会被自动清除。</p><p>➢ RabbitMQ可以对消息设置过期时间，也可以对整个队列（Queue）设置过期时间。</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210181832870.png" alt="image-20221018183210610"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfigTTL</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_exchange_ttl&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;test_queue_ttl&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">ttlExchange</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">// 设置queue的过期时间</span></span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">ttlQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME).ttl(<span class="number">10000</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.队列交换机绑定关系 Binding</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 1.知道那个队列</span></span><br><span class="line"><span class="comment">    * 2.知道那个交换机</span></span><br><span class="line"><span class="comment">    * 3.routing key</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueueExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;ttlQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;ttlExchange&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;ttl.*&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><ol><li><p>队列的统一过期时间</p></li><li><p>消息单独过期</p></li></ol><ul><li>如果设置了消息的过期时间，也设置了队列的过期时间，以时间短的为准。</li><li>队列过期后，会将队列所有信息全部移除。</li><li>消息过期后，只有消息在队列顶端，才会判断其是否过期了（移除掉）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TTL:过期时间</span></span><br><span class="line"><span class="comment"> * 1. 队列的统一过期时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 消息单独过期</span></span><br><span class="line"><span class="comment"> * 如果设置了消息的过期时间，也设置了队列的过期时间，以时间短的为准。</span></span><br><span class="line"><span class="comment"> * 队列过期后，会将队列所有信息全部移除。</span></span><br><span class="line"><span class="comment"> * 消息过期后，只有消息在队列顶端，才会判断其是否过期了（移除掉）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTtl</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*// 队列的统一过期时间</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; 10; i++) &#123;</span></span><br><span class="line"><span class="comment">        //发送消息</span></span><br><span class="line"><span class="comment">        rabbitTemplate.convertAndSend(&quot;test_exchange_ttl&quot;, &quot;ttl.haha&quot;, &quot;message ttl....&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息单独过期</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息的后处理对象，设置一些信息的参数信息</span></span><br><span class="line">    <span class="type">MessagePostProcessor</span> <span class="variable">messagePostProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">            <span class="comment">//1. 设置message的信息</span></span><br><span class="line">            message.getMessageProperties().setExpiration(<span class="string">&quot;5000&quot;</span>);<span class="comment">//消息过期时间</span></span><br><span class="line">            <span class="comment">//2. 返回该消息</span></span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//rabbitTemplate.convertAndSend(&quot;test_exchange_ttl&quot;, &quot;ttl.haha&quot;, &quot;message ttl....&quot;, messagePostProcessor);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="comment">//消息单独过期</span></span><br><span class="line">            rabbitTemplate.convertAndSend(<span class="string">&quot;test_exchange_ttl&quot;</span>, <span class="string">&quot;ttl.haha&quot;</span>, <span class="string">&quot;message ttl....&quot;</span>, messagePostProcessor);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不过期的消息</span></span><br><span class="line">            rabbitTemplate.convertAndSend(<span class="string">&quot;test_exchange_ttl&quot;</span>, <span class="string">&quot;ttl.haha&quot;</span>, <span class="string">&quot;message ttl....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TTL-小结"><a href="#TTL-小结" class="headerlink" title="TTL 小结"></a>TTL 小结</h4><p>➢ 设置队列过期时间使用参数：x-message-ttl，单位：ms(毫秒)，会对整个队列消息统一过期。</p><p>➢ 设置消息过期时间使用参数：expiration。单位：ms(毫秒)，当该消息在队列头部时（消费时），会单独判断这一消息是否过期。</p><p>➢ 如果两者都进行了设置，以时间短的为准。</p><h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a><strong>死信队列</strong></h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>死信队列，英文缩写：DLX 。Dead Letter Exchange（死信交换机），当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是DLX。</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210181917671.png" alt="image-20221018191726586"></p><h4 id="消息成为死信的三种情况"><a href="#消息成为死信的三种情况" class="headerlink" title="消息成为死信的三种情况"></a>消息成为死信的三种情况</h4><ol><li><p>队列消息长度到达限制；</p></li><li><p>消费者拒接消费消息，basicNack/basicReject,并且不把消息重新放入原目标队列,requeue=false；</p></li><li><p>原队列存在消息过期设置，消息到达超时时间未被消费；</p></li></ol><h4 id="队列绑定死信交换机"><a href="#队列绑定死信交换机" class="headerlink" title="队列绑定死信交换机"></a>队列绑定死信交换机</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210181920148.png" alt="image-20221018192015082"></p><p>给队列设置参数： x-dead-letter-exchange 和 x-dead-letter-routing-key</p><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><p>配置类配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死信交换机和死信队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue_dlx&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange_dlx&quot;</span>;</span><br><span class="line">    <span class="comment">//正常交换机和正常队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NORMAL_NAME</span> <span class="operator">=</span> <span class="string">&quot;the_queue_dlx&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NORMAL_NAME</span> <span class="operator">=</span> <span class="string">&quot;the_exchange_dlx&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;normalExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">normalExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_NORMAL_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;dlxExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">dlxExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_DLX_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;normalQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">//x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, EXCHANGE_DLX_NAME);</span><br><span class="line">        <span class="comment">//x-dead-letter-routing-key  这里声明当前队列的死信路由key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;dlx.hehe&quot;</span>);</span><br><span class="line">        <span class="comment">//过期时间</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">//最大长度</span></span><br><span class="line">        args.put(<span class="string">&quot;x-max-length&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NORMAL_NAME).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死信队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;dlxQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">dlxQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_DLX_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.正常队列交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueueExchangeNormal</span><span class="params">(<span class="meta">@Qualifier(&quot;normalQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;normalExchange&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;the.dlx.*&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.死信队列交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueueExchangeDlx</span><span class="params">(<span class="meta">@Qualifier(&quot;dlxQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;dlxExchange&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;dlx.*&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.正常队列绑定死信交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueueExchangeDlxNormal</span><span class="params">(<span class="meta">@Qualifier(&quot;dlxQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;normalExchange&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;dlx.hehe&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 发送测试死信消息：</span></span><br><span class="line"><span class="comment">     * 1.过期时间</span></span><br><span class="line"><span class="comment">     * 2.长度限制</span></span><br><span class="line"><span class="comment">     * 3.消息拒收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDlx</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 测试过期时间，死信消息</span></span><br><span class="line"><span class="comment">//        rabbitTemplate.convertAndSend(&quot;the_exchange_dlx&quot;, &quot;the.dlx.haha&quot;, &quot;message dlx??....&quot;);</span></span><br><span class="line">        <span class="comment">//2. 测试长度限制，消息死信</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; 20; i++) &#123;</span></span><br><span class="line"><span class="comment">//            rabbitTemplate.convertAndSend(&quot;the_exchange_dlx&quot;, &quot;the.dlx.haha&quot;, &quot;message dlx??....&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//3. 测试消息绝收</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;the_exchange_dlx&quot;</span>, <span class="string">&quot;the.dlx.haha&quot;</span>, <span class="string">&quot;message dlx??....&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DlxListener</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span> &#123;</span><br><span class="line">    <span class="comment">//定义监听器，监听正常队列</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;the_queue_dlx&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 接受转换消息</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 处理业务逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;handle business logic&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//3. 手动签收</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">true</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/***</span></span><br><span class="line"><span class="comment">             * 第三个参数requeue：重回队列。如果设置为true,则重回queue，broker会重新发送该消息给消费端</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.out.println(<span class="string">&quot;出现异常，拒绝接受&quot;</span>);</span><br><span class="line">            <span class="comment">//4. 拒绝签收，不重回队列，requeue=false</span></span><br><span class="line">            channel.basicNack(deliveryTag, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//channel.basicReject(deliveryTag, true);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="死信队列小结"><a href="#死信队列小结" class="headerlink" title="死信队列小结"></a>死信队列小结</h4><ol><li>死信交换机和死信队列和普通的没有区别</li><li>当消息成为死信后，如果该队列绑定了死信交换机，则消息会被死信交换机重新路由到死信队列</li><li>消息成为死信的三种情况：<ol><li>队列消息长度到达限制；</li><li>消费者拒接消费消息，并且不重回队列；</li><li>原队列存在消息过期设置，消息到达超时时间未被消费；</li></ol></li></ol><h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a><strong>延迟队列</strong></h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>延迟队列，即消息进入队列后不会立即被消费，只有到达指定时间后，才会被消费。</p><p>需求：</p><ol><li><p>下单后，30分钟未支付，取消订单，回滚库存。</p></li><li><p>新用户注册成功7天后，发送短信问候。</p></li></ol><p>实现方式：</p><ol><li><p>定时器（不好，不优雅，开销大）</p></li><li><p>延迟队列</p></li></ol><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210191032656.png" alt="image-20221019103248546"></p><p>很可惜，在RabbitMQ中并未提供延迟队列功能。</p><p>但是可以使用：TTL+死信队列 组合实现延迟队列的效果。</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210191036225.png" alt="image-20221019103614158"></p><h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h4><p>配置类：</p><ul><li>配值死信队列、死信交换机</li><li>配置正常队列、正常交换机</li><li>正常队列绑定正常交换机</li><li>死信队列绑定死信交换机</li><li>正常队列绑定死信交换机</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 延迟队列：</span></span><br><span class="line"><span class="comment">     * 1. 定义正常交换机order_exchange和队列order_queue</span></span><br><span class="line"><span class="comment">     * 2. 定义死信交换机exchange_order_dlx和队列queue_order_dlx</span></span><br><span class="line"><span class="comment">     * 3. 绑定，设置正常队列过期时间为30min</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//死信交换机和死信队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_ORDER_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;queue_order_dlx&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_ORDER_DLX_NAME</span> <span class="operator">=</span> <span class="string">&quot;exchange_order_dlx&quot;</span>;</span><br><span class="line"><span class="comment">//正常交换机和正常队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_ORDER_NAME</span> <span class="operator">=</span> <span class="string">&quot;order_queue&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_ORDER_NAME</span> <span class="operator">=</span> <span class="string">&quot;order_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常交换机</span></span><br><span class="line"><span class="meta">@Bean(&quot;orderExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Exchange <span class="title function_">orderExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_ORDER_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//死信交换机</span></span><br><span class="line"><span class="meta">@Bean(&quot;exchangeOrderDlx&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Exchange <span class="title function_">exchangeOrderDlx</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_ORDER_DLX_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常队列</span></span><br><span class="line"><span class="meta">@Bean(&quot;orderQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">orderQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">//x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span></span><br><span class="line">    args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, EXCHANGE_ORDER_DLX_NAME);</span><br><span class="line">    <span class="comment">//x-dead-letter-routing-key  这里声明当前队列的死信路由key</span></span><br><span class="line">    args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;dlx.order.cancel&quot;</span>);</span><br><span class="line">    <span class="comment">//过期时间</span></span><br><span class="line">    args.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(QUEUE_ORDER_NAME).withArguments(args).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//死信队列</span></span><br><span class="line"><span class="meta">@Bean(&quot;queueOrderDlx&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">queueOrderDlx</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(QUEUE_ORDER_DLX_NAME).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常队列交换机绑定</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bindingQueueExchangePOrderNormal</span><span class="params">(<span class="meta">@Qualifier(&quot;orderQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;orderExchange&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;order.*&quot;</span>).noargs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//死信队列交换机绑定</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bindingQueueExchangeOrderDlx</span><span class="params">(<span class="meta">@Qualifier(&quot;queueOrderDlx&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;exchangeOrderDlx&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;dlx.order.*&quot;</span>).noargs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常队列绑定死信交换机</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bindingQueueExchangeOrderDlxNormal</span><span class="params">(<span class="meta">@Qualifier(&quot;orderQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;exchangeOrderDlx&quot;)</span> Exchange exchange)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;&quot;</span>).noargs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者测试发送消息：向正常交换机发送消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延迟队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelay</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//1. 发送订单消息。将来是在订单系统中，下单完成，发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;order_exchange&quot;</span>, <span class="string">&quot;order.msg&quot;</span>, <span class="string">&quot;订单：id=1;name=huang&quot;</span>);</span><br><span class="line">    <span class="comment">//2. 打印倒计时</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        System.out.println(i + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者：监听死信队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderListener</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span> &#123;</span><br><span class="line">    <span class="comment">//延时队列：定义监听器，监听死信队列</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;queue_order_dlx&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 接受转换消息</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 处理业务逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;handle business logic&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;根据订单id查询其状态...&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;判断订单是否支付成功...&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;取消订单，回滚库存...&quot;</span>);</span><br><span class="line">            <span class="comment">//3. 手动签收</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">true</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/***</span></span><br><span class="line"><span class="comment">             * 第三个参数requeue：重回队列。如果设置为true,则重回queue，broker会重新发送该消息给消费端</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            System.out.println(<span class="string">&quot;出现异常，拒绝接受&quot;</span>);</span><br><span class="line">            <span class="comment">//4. 拒绝签收，不重回队列，requeue=false</span></span><br><span class="line">            channel.basicNack(deliveryTag, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//channel.basicReject(deliveryTag, true);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：10秒后监听死信队列的监听器响应。</p><h4 id="延迟队列小结"><a href="#延迟队列小结" class="headerlink" title="延迟队列小结"></a>延迟队列小结</h4><ol><li><p>延迟队列 指消息进入队列后，可以被延迟一定时间，再进行消费。</p></li><li><p>RabbitMQ没有提供延迟队列功能，但是可以使用 ： TTL + DLX 来实现延迟队列效果。</p></li></ol><h3 id="日志与监控"><a href="#日志与监控" class="headerlink" title="日志与监控"></a>日志与监控</h3><h4 id="RabbitMQ日志"><a href="#RabbitMQ日志" class="headerlink" title="RabbitMQ日志"></a>RabbitMQ日志</h4><p>RabbitMQ默认日志存放路径： /var/log/rabbitmq/<a href="mailto:&#x72;&#97;&#x62;&#x62;&#105;&#116;&#x40;&#x78;&#120;&#x78;&#46;&#108;&#111;&#x67;">&#x72;&#97;&#x62;&#x62;&#105;&#116;&#x40;&#x78;&#120;&#x78;&#46;&#108;&#111;&#x67;</a></p><p>日志包含了RabbitMQ的版本号、Erlang的版本号、RabbitMQ服务节点名称、cookie的hash值、RabbitMQ配置文件地址、内存限制、磁盘限制、默认账户guest的创建以及权限配置等等。</p><h4 id="web管控台监控"><a href="#web管控台监控" class="headerlink" title="web管控台监控"></a>web管控台监控</h4><h4 id="rabbitmqctl管理和监控"><a href="#rabbitmqctl管理和监控" class="headerlink" title="rabbitmqctl管理和监控"></a>rabbitmqctl管理和监控</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">查看队列</span><br><span class="line"><span class="meta"># rabbitmqctl list_queues</span></span><br><span class="line">查看exchanges</span><br><span class="line"><span class="meta"># rabbitmqctl list_exchanges</span></span><br><span class="line">查看用户</span><br><span class="line"><span class="meta"># rabbitmqctl list_users</span></span><br><span class="line">查看连接</span><br><span class="line"><span class="meta"># rabbitmqctl list_connections</span></span><br><span class="line">查看消费者信息</span><br><span class="line"><span class="meta"># rabbitmqctl list_consumers</span></span><br><span class="line">查看环境变量</span><br><span class="line"><span class="meta"># rabbitmqctl environment</span></span><br><span class="line">查看未被确认的队列</span><br><span class="line"><span class="meta"># rabbitmqctl list_queues name messages_unacknowledged</span></span><br><span class="line">查看单个队列的内存使用</span><br><span class="line"><span class="meta"># rabbitmqctl list_queues name memory</span></span><br><span class="line">查看准备就绪的队列</span><br><span class="line"><span class="meta"># rabbitmqctl list_queues name messages_ready</span></span><br></pre></td></tr></table></figure><h3 id="消息追踪"><a href="#消息追踪" class="headerlink" title="消息追踪"></a>消息追踪</h3><p>在使用任何消息中间件的过程中，难免会出现某条消息异常丢失的情况。对于RabbitMQ而言，可能是因为生产者或消费者与RabbitMQ断开了连接，而它们与RabbitMQ又采用了不同的确认机制；也有可能是因为交换器与队列之间不同的转发策略；甚至是交换器并没有与任何队列进行绑定，生产者又不感知或者没有采取相应的措施；另外RabbitMQ本身的集群策略也可能导致消息的丢失。这个时候就需要有一个较好的机制跟踪记录消息的投递过程，以此协助开发和运维人员进行问题的定位。</p><p>在RabbitMQ中可以使用Firehose和rabbitmq_tracing插件功能来实现消息追踪。</p><h4 id="消息追踪-Firehose"><a href="#消息追踪-Firehose" class="headerlink" title="消息追踪-Firehose"></a>消息追踪-Firehose</h4><p>firehose的机制是将生产者投递给rabbitmq的消息，rabbitmq投递给消费者的消息按照指定的格式发送到默认的exchange上。这个默认的exchange的名称为amq.rabbitmq.trace，它是一个topic类型的exchange。发送到这个exchange上的消息的routing key为 publish.exchangename 和deliver.queuename。其中exchangename和queuename为实际exchange和queue的名称，分别对应生产者投递到exchange的消息，和消费者从queue上获取的消息。</p><p>注意：打开 trace 会影响消息写入功能，适当打开后请关闭。</p><p>rabbitmqctl trace_on：开启Firehose命令</p><p>rabbitmqctl trace_off：关闭Firehose命令</p><p>指定虚拟机开启：rabbitmqctl trace_on -p /itcast</p><h4 id="消息追踪-rabbitmq-tracing"><a href="#消息追踪-rabbitmq-tracing" class="headerlink" title="消息追踪-rabbitmq_tracing"></a>消息追踪-rabbitmq_tracing</h4><p>rabbitmq_tracing和Firehose在实现上如出一辙，只不过rabbitmq_tracing的方式比Firehose多了一层GUI的包装，更容易使用和管理。</p><p>启用插件：rabbitmq-plugins enable rabbitmq_tracing</p><p>关闭插件：rabbitmq-plugins disable rabbitmq_tracing</p><h2 id="Rabbit-MQ应用问题"><a href="#Rabbit-MQ应用问题" class="headerlink" title="Rabbit MQ应用问题"></a>Rabbit MQ应用问题</h2><h3 id="消息可靠性保障"><a href="#消息可靠性保障" class="headerlink" title="消息可靠性保障"></a><strong>消息可靠性保障</strong></h3><p>需求：</p><p>100%确保消息发送成功</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210191246843.png" alt="image-20221019124645756"></p><h3 id="消息幂等性保障"><a href="#消息幂等性保障" class="headerlink" title="消息幂等性保障"></a><strong>消息幂等性保障</strong></h3><p>幂等性指一次和多次请求某一个资源，对于资源本身应该具有同样的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。</p><p>在MQ中指，消费多条相同的消息，得到与消费该消息一次相同的结果</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210191256721.png" alt="image-20221019125631634"></p><h2 id="Rabbit-MQ集群搭建"><a href="#Rabbit-MQ集群搭建" class="headerlink" title="Rabbit MQ集群搭建"></a>Rabbit MQ集群搭建</h2><h2 id="Spring-Boot配置Rabbit-MQ"><a href="#Spring-Boot配置Rabbit-MQ" class="headerlink" title="Spring Boot配置Rabbit MQ"></a>Spring Boot配置Rabbit MQ</h2><ol><li>可以在配置文件中配置属性（全局）</li><li>在@RabbitListener配置contanierFactory属性</li></ol><p>inux系统：centos7<br>1.启动前，查看mq状态</p><p>systemctl status rabbitmq-server<br>2.启动</p><p>systemctl start rabbitmq-server<br>3.停止</p><p>systemctl stop rabbitmq-server<br>4.重启</p><p>restart<br>5.打开浏览器管理页面：默认端口号15672</p><p>systemctl status firewalld<br>//关闭防火墙<br>systemctl disable firewalld<br>systemctl stop firewalld<br>6.登陆<br>用户名和密码都是guest</p><p>7.插件管理相关命令</p><p>rabbitmq-plugins enable|list|disable</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Rabbit-MQ&quot;&gt;&lt;a href=&quot;#Rabbit-MQ&quot; class=&quot;headerlink&quot; title=&quot;Rabbit MQ&quot;&gt;&lt;/a&gt;Rabbit MQ&lt;/h1&gt;&lt;h2 id=&quot;MQ基本概念&quot;&gt;&lt;a href=&quot;#MQ基本概念&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://huangrd.top/pages/uncategorized/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html"/>
    <id>http://huangrd.top/pages/uncategorized/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html</id>
    <published>2022-10-16T11:07:38.781Z</published>
    <updated>2022-11-01T16:33:36.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h3><p>给用户提供服务、对程序进行管理、对资源进行分配。</p><ul><li>操作系统是一个控制软件，管理应用程序</li><li>操作系统为应用程序提供服务，杀死应用程序</li><li>操作系统进行资源管理，管理外设、分配资源</li></ul><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210161917251.png" alt="image-20221016191756140" style="zoom: 50%;" /><h4 id="操作系统的架层次结构"><a href="#操作系统的架层次结构" class="headerlink" title="操作系统的架层次结构"></a>操作系统的架层次结构</h4><blockquote><p>硬件之上，应用程序之下。处于中间位置</p></blockquote><p>操作系统位于应用软件之下，为应用软件提供服务支撑。</p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210161922006.png" alt="image-20221016192204876" style="zoom: 50%;" /><p>操作系统给外部提供的服务shell</p><h4 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h4><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210161927344.png" alt="image-20221016192700234" style="zoom:50%;" /><ol><li>CPU的调度</li><li>物理内存的管理</li><li>虚拟内存的管理</li><li>文件系统的管理</li><li>中断处理和设备驱动</li></ol><h4 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h4><ol><li><p>并发</p><p>计算机系统中同时存在多个运行的程序，需要OS管理和调度</p><p><code>并发和并行的区别</code></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">并发：在一段时间内，有多个程序可以运行。</span><br><span class="line">并行：在一个时间点上，有多个程序可以运行。</span><br><span class="line">并行一般要求计算机系统存在多个<span class="meta">CPU</span>，这样才能使OS在一个时间同时执行多个程序。只有一个<span class="meta">CPU</span>，则不能并行。</span><br></pre></td></tr></table></figure></li><li><p>共享</p><ul><li>”同时“访问</li><li>互斥访问</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">互斥访问：对于同一个内存空间，同一个时间点只有一个程序能够访问。</span><br><span class="line">同时访问：一个程序可以在同一个时间点访问多块不同的内存。</span><br></pre></td></tr></table></figure></li><li><p>虚拟</p><ul><li>利用多道程序设计，让每个用户都觉得有一个计算机专门为他服务</li></ul></li><li><p>异步</p><ul><li>程序执行不是一贯到底，而是走走停停，向前推进的速度不可预知</li><li>但只要运行环境相同，OS需要保证程序运行的结果也要相同</li></ul></li></ol><h3 id="为什么学习操作系统"><a href="#为什么学习操作系统" class="headerlink" title="为什么学习操作系统"></a>为什么学习操作系统</h3><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210161958530.png" alt="image-20221016195802432"></p><h4 id="操作系统需要权衡"><a href="#操作系统需要权衡" class="headerlink" title="操作系统需要权衡"></a>操作系统需要权衡</h4><ul><li>空间和时间</li><li>性能和可预测性</li><li>公平和性能</li></ul><h3 id="操作系统实例"><a href="#操作系统实例" class="headerlink" title="操作系统实例"></a>操作系统实例</h3><ul><li>UNIX</li><li>LINUX</li><li>WINDOWS</li></ul><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162009726.png" alt="image-20221016200900650"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162010103.png" alt="image-20221016201051018"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162011766.png" alt="image-20221016201153666"></p><h3 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h3><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162013743.png" alt="image-20221016201341616"></p><ol><li>纸带机（监视器）</li></ol><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162014261.png" alt="image-20221016201450137"></p><ol start="2"><li>CPU等硬件快速发展，计算机速度提升，性能未得到充分利用。</li></ol><p>流水线程序设计</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162016585.png" alt="image-20221016201617502"></p><ol start="3"><li>内存容量越来越大，CPU执行多个程序。</li></ol><p>多道程序设计，cpu在IO执行过程中，执行其他的程序。</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162017166.png" alt="image-20221016201704115"></p><p>多道程序设计提高了CPU的利用效率，但是交互性不好。</p><ol start="4"><li>为了更好的利用计算机资源，并且更好的和用户进行交互，出现了分时系统。</li></ol><p>CPU将时间片分为1/1000S，1/1000执行程序1，之后执行程序2，再来回切换。</p><ol start="5"><li><p>个人电脑操作系统PC</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162026243.png" alt="image-20221016202656160"></p></li><li><p>网络的快速发展，出现了分布式的操作系统</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162028707.png" alt="image-20221016202830643"></p></li><li><p>云计算</p><p>人的周围出现大量嵌入式系统，给人个性化服务。</p></li></ol><h3 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h3><p>微内核的设计，尽可能把内核功能熙东到用户空间</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162038032.png" alt="image-20221016203805979"></p><p>VMM</p><p>位于操作系统之下，让OS觉得自己直接在操纵硬件。（虚拟化）</p><p>充分发挥硬件资源，防止资源过剩。</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162040832.png" alt="image-20221016204023743"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162041321.png" alt="image-20221016204103221"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162041559.png" alt="image-20221016204115441"></p><h2 id="操作系统的基本操作"><a href="#操作系统的基本操作" class="headerlink" title="操作系统的基本操作"></a>操作系统的基本操作</h2><h3 id="启动、中断、异常和系统调用"><a href="#启动、中断、异常和系统调用" class="headerlink" title="启动、中断、异常和系统调用"></a>启动、中断、异常和系统调用</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171640102.png" alt="image-20221017164000023" style="zoom:50%;" /><p>DISK:存放OS</p><p>BIOS:基本的I/O处理系统</p><p>Bootloader:加载OS</p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171641326.png" alt="image-20221017164154259" style="zoom:50%;" /><p>POST（加电自检）：寻找显卡和执行BIOS</p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171646179.png" alt="image-20221017164622111" style="zoom: 80%;" /><h4 id="中断、异常和系统调用"><a href="#中断、异常和系统调用" class="headerlink" title="中断、异常和系统调用"></a>中断、异常和系统调用</h4><p>操作系统怎样管理外设，怎么给应用程序提供服务?</p><ul><li><p>系统调用（来源于应用程序）：系统程序主动向操作系统发出服务请求。</p></li><li><p>异常（来源于不良的应用程序）：非法指令或者其他坏的处理状态（如：内存出错）</p></li><li><p>中断（来源于外设）：来自不同的硬件设备的计时器和网络中断</p></li></ul><p>为什么应用程序要通过操作系统来管理硬件？</p><ul><li>操作系统是一种特殊的软件，在计算机运行中，内核是被信任的第三方，计算机认为操作系统是安全的，而软件并不都是安全的。</li><li>因此，只有内核可以执行特权命令。</li><li>把计算机的硬件资源全部交给操作系统进行管理，有利于软件设计时便捷，软件的可移植性较高。</li></ul><p>操作系统如何实现中断、异常和系统调用？</p><p>这三者有什么联系和差异？</p><p>源头：</p><ul><li>中断：外设</li><li>异常：应用程序意想不到的行为</li><li>系统调用：应用程序请求操作提供服务（主动的）</li></ul><p>处理时间：</p><ul><li><p>中断：异步</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">  异步时间：当中断产生时，应用程序并不知道什么时候产生的</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>异常：同步</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>系统调用：异步或同步</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>系统调用发出请求时，返回的时间可能是异步的，当系统调用发送请求后，如果执行其他程序，则返回数据是异步的。<br>```</p></li></ul><p>响应：</p><ul><li>中断：持续，对用户应用程序是透明的（应用程序不知道有没有发生中断）。</li><li>异常：杀死或者重新执行意想不到的应用程序指令。</li><li>系统调用：等待和持续。</li></ul><h5 id="中断的处理过程"><a href="#中断的处理过程" class="headerlink" title="中断的处理过程"></a>中断的处理过程</h5><p>硬件：</p><ol><li>将内部、外部事件设置中断标记</li><li>中断事件的ID</li></ol><p>硬件：</p><ol><li>保存当前状态</li><li>中断服务程序处理</li><li>清楚中断标记</li><li>恢复之前保存的处理状态</li></ol><h5 id="异常的处理过程"><a href="#异常的处理过程" class="headerlink" title="异常的处理过程"></a>异常的处理过程</h5><p>异常会产生相应的异常编号:</p><ol><li>保存现场</li><li>异常处理<ul><li>杀死产生异常的程序</li><li>重新执行异常的指令</li></ul></li><li>恢复现常</li></ol><h5 id="系统调用的处理"><a href="#系统调用的处理" class="headerlink" title="系统调用的处理"></a>系统调用的处理</h5><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171915550.png" alt="image-20221017191542503" style="zoom:50%;" /><p>程序访问主要通过高层次的API接口而不是直接进行系统调用。</p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171919724.png" alt="image-20221017191919661" style="zoom:50%;" /><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171920439.png" alt="image-20221017192013385" style="zoom:50%;" /><p>当应用程序进行系统调用时，操作系统会从用户态到内核态的转化，操作权从应用程序转为操作系统。操作系统对应用程序的系统调用的id号进行标识。</p><p>系统调用和程序调用的区别？</p><p>程序调用是一个栈空间完成的</p><p>系统调用，在应用程序调用系统调用时会切换堆栈，还要完成用户态的转换，因此系统调用的开销比较大，但是安全性高。</p><h5 id="跨越操作系统边界的开销"><a href="#跨越操作系统边界的开销" class="headerlink" title="跨越操作系统边界的开销"></a>跨越操作系统边界的开销</h5><ul><li>在执行时间上的开销超过程序调用</li><li>开销：<ul><li>建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销</li><li>建立内核堆栈</li><li>验证参数</li><li>内核态映射到用户态的地址空间，更新页面映射权限</li><li>内核态独立地址空间 TLB</li></ul></li></ul><hr><blockquote><p>操作系统如何管理物理内存</p></blockquote><h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><h3 id="计算机体系结构、内存分层体系"><a href="#计算机体系结构、内存分层体系" class="headerlink" title="计算机体系结构、内存分层体系"></a>计算机体系结构、内存分层体系</h3><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182117488.png" alt="image-20221018211705744"></p><p>内存的层次结构：</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182118723.png" alt="image-20221018211801644"></p><p>通过操作系统来管理内存，达到稳定快速。</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182120477.png" alt="image-20221018212040398"></p><p>操作系统还能隔离进程之间的地址空间，也能在进程间进行保护。</p><ol><li>抽象(对逻辑地址空间)</li><li>保护(进程的独立地址空间)</li><li>共享</li><li>虚拟化(更多的地址空间 虚拟内存：硬盘)</li></ol><p>操作系统管理内存的方法：</p><ul><li>程序重定位</li><li>分段</li><li>分页</li><li>虚拟内存</li><li>按需分配内存</li></ul><p>以上的方法高度依赖于硬件：</p><ul><li>必须直到内存架构</li><li>MMU（内存管理单元）：硬件组件负责处理CPU的内存访问请求。</li></ul><h3 id="地址空间、地址生成"><a href="#地址空间、地址生成" class="headerlink" title="地址空间、地址生成"></a>地址空间、地址生成</h3><h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182128534.png" alt="image-20221018212807441"></p><p>物理地址空间：内存条、硬盘</p><p>逻辑地址空间：一个运行的程序对应的地址空间</p><p>逻辑地址空间实际上是落脚在实际的物理地址空间的，需要操作系统的管理。</p><h4 id="地址生成"><a href="#地址生成" class="headerlink" title="地址生成"></a>地址生成</h4><p>逻辑地址怎么生成的？</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182130906.png" alt="image-20221018213031811"></p><p>一步一步的编译，最后通过loader（应用程序）把执行程序的逻辑地址分配在物理地址。</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182133589.png" alt="image-20221018213334501"></p><p>CPU中的MMU保存了逻辑地址到物理地址的映射关系。来让我们通过映射访问到实际的物理地址。</p><ol><li>CPU执行某条指令，ALU请求逻辑地址</li><li>CPU的MMU查找逻辑地址的映射表map是否存在对应物理地址，找到，返回。没有，去内存找。</li><li>如果有，给主存发送请求，需要物理地址的内容。</li><li>主存通过总线，把内容传给CPU。</li><li>CPU拿到数据后，继续指令的执行。</li></ol><p>操作系统实际上是完成了从逻辑地址到物理地址关系的映射。</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182142610.png" alt="image-20221018214110531"></p><ul><li>编译器会把基于符号的地址空间到逻辑地址空间。</li><li>操作系统会把逻辑地址空间映射到物理地址空间。同时保证程序独立分配地址空间，保证程序的正常运行。</li></ul><h3 id="连续内存分配-1"><a href="#连续内存分配-1" class="headerlink" title="连续内存分配"></a>连续内存分配</h3><h4 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182143566.png" alt="image-20221018214320476"></p><p>希望通过一种有效的分配方法，来减少内碎片、外碎片的问题。</p><h4 id="分区的动态分配"><a href="#分区的动态分配" class="headerlink" title="分区的动态分配"></a>分区的动态分配</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182145391.png" alt="image-20221018214531315"></p><p>操作系统需要管理分配了和未分配的空间。</p><h4 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h4><h5 id="首次适配"><a href="#首次适配" class="headerlink" title="首次适配"></a>首次适配</h5><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182147966.png" alt="image-20221018214653040"></p><p>实现：从第一块开始分配 0地址</p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182149601.png" alt="image-20221018214916478" style="zoom: 67%;" /><h5 id="最优适配"><a href="#最优适配" class="headerlink" title="最优适配"></a>最优适配</h5><p>寻找最匹配的空间块。内存差最小。</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182150373.png" alt="image-20221018215023254"></p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182150929.png" alt="image-20221018215046854" style="zoom:67%;" /><h5 id="最差适配"><a href="#最差适配" class="headerlink" title="最差适配"></a>最差适配</h5><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182152368.png" alt="image-20221018215205253"></p><p>和最优适配对应，找到内存差最大的内存块。</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182152296.png" alt="image-20221018215253220"></p><p>中大型请求，最差适配还是比较合适的。</p><p>应对不同的情况，选择不同的分配策略。</p><h4 id="压缩式和交换式碎片处理"><a href="#压缩式和交换式碎片处理" class="headerlink" title="压缩式和交换式碎片处理"></a>压缩式和交换式碎片处理</h4><p>如何把碎片联合起来，组成大的连续的碎片？</p><h5 id="压缩式碎片处理"><a href="#压缩式碎片处理" class="headerlink" title="压缩式碎片处理"></a>压缩式碎片处理</h5><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182158695.png" alt="image-20221018215857582" style="zoom:50%;" /><p>把之前的内存进行拷贝。</p><p>问题：</p><ul><li>什么时候进行拷贝？(时机：可以在程序等待的过程中)</li><li>开销大不大？（时间的开销，会不会影响程序的执行）</li></ul><h5 id="交换式碎片整理"><a href="#交换式碎片整理" class="headerlink" title="交换式碎片整理"></a>交换式碎片整理</h5><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182202473.png" alt="image-20221018220200392"></p><p>没有空闲空间了，不能使用紧致(压缩式)。</p><p>通过把程序耗费的内存移到硬盘中。</p><p>问题：</p><ul><li>选择哪一个程序进行移动？</li><li>在什么时机进行移动？</li><li>开销的大小？</li></ul><h2 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h2><h3 id="为什么需要非连续内存分配这种管理方式？"><a href="#为什么需要非连续内存分配这种管理方式？" class="headerlink" title="为什么需要非连续内存分配这种管理方式？"></a>为什么需要非连续内存分配这种管理方式？</h3><p>连续内存分配的缺点：</p><ul><li>分配给一个程序的物理内存是连续的</li><li>内存利用率较低</li><li>有外碎片、内碎片问题</li></ul><p>非连续分配的优点：</p><ul><li>一个程序的物理地址空间是连续的</li><li>更好的内存利用和管理</li><li>允许共享代码与数据（贡献库等…）</li><li>支持动态加载和动态链接</li></ul><p>非连续分配的缺点：</p><p>建立虚拟地址和物理地址之间转换的开销</p><ul><li>硬件方案<ul><li>分页</li><li>分段</li></ul></li><li>软件方案</li></ul><h3 id="非连续内存分配的方法"><a href="#非连续内存分配的方法" class="headerlink" title="非连续内存分配的方法"></a>非连续内存分配的方法</h3><ul><li>分段(Segmentation)</li><li>分页(Paging)</li></ul><h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><ul><li>程序的分段地址空间</li><li>分段寻址方案</li></ul><img src="C:/Users/huangruidong/AppData/Roaming/Typora/typora-user-images/image-20221021112201543.png" alt="image-20221021112201543" style="zoom:50%;" /><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211123316.png" alt="image-20221021112305222"></p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211124935.png" alt="image-20221021112415866" style="zoom:67%;" /><p>将连续的逻辑地址空间分段为非连续的物理地址空间</p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211125905.png" alt="image-20221021112538821" style="zoom:67%;" /><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211126339.png" alt="image-20221021112646245"></p><p>分段地址选址：段号+段的偏移</p><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>页地址选址：页号+页的偏移</p><p>分页和分段的区别：</p><ul><li>在分段里边，段的尺寸是可变的</li><li>在分页里边，页的尺寸大小是不变的</li></ul><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211140279.png" alt="image-20221021114022106" style="zoom:50%;" /><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211141715.png" alt="image-20221021114130624" style="zoom: 80%;" /><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211144516.png" alt="image-20221021114456415" style="zoom:80%;" /><img src="C:/Users/huangruidong/AppData/Roaming/Typora/typora-user-images/image-20221021114907052.png" alt="image-20221021114907052" style="zoom:80%;" /><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211153061.png" alt="image-20221021115234290" style="zoom:80%;" /><p>通过页号查帧号</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211156179.png" alt="image-20221021115635068"></p><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211326985.png" alt="image-20221021132609864"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211326654.png" alt="image-20221021132637568"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211509423.png" alt="image-20221021150916315"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211515167.png" alt="image-20221021151523105"></p><ul><li>页表可能占的空间很大</li><li>页表如果放在内存上，时间上的开销很大。</li></ul><h5 id="应对时间开销：TLB"><a href="#应对时间开销：TLB" class="headerlink" title="应对时间开销：TLB"></a>应对时间开销：TLB</h5><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211515561.png" alt="image-20221021151553493"></p><h5 id="应对内存开销：多级页表"><a href="#应对内存开销：多级页表" class="headerlink" title="应对内存开销：多级页表"></a>应对内存开销：多级页表</h5><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211523651.png" alt="image-20221021152354583"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211524984.png" alt="image-20221021152404907"></p><p>像B+树一样</p><h5 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h5><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211526374.png" alt="image-20221021152622306"></p><p>反转：以物理页号查找逻辑页号</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211528561.png" alt="image-20221021152808496"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211529460.png" alt="image-20221021152930397"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211531525.png" alt="image-20221021153115447"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211532275.png" alt="image-20221021153208185"></p><h2 id="虚拟内存管理技术"><a href="#虚拟内存管理技术" class="headerlink" title="虚拟内存管理技术"></a>虚拟内存管理技术</h2><h3 id="虚拟内存的起因"><a href="#虚拟内存的起因" class="headerlink" title="虚拟内存的起因"></a>虚拟内存的起因</h3><p>程序规模的增长速度远大于存储器容量的增长速度。</p><hr><p>理想中的存储器：</p><ul><li>更大</li><li>更快</li><li>更便宜</li><li>非异失性</li><li><img src="C:/Users/huangruidong/AppData/Roaming/Typora/typora-user-images/image-20221024183501918.png" alt="image-20221024183501918" style="zoom:50%;" /></li></ul><p>硬盘比内存容量大，但是速度慢。</p><p>能不能让操作系统通过一种操作，达到理想中的存储器？</p><p><strong>自动的虚拟存储技术</strong></p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210241839139.png" alt="image-20221024183954026" style="zoom: 67%;" /><p>但是目前还达不到掉电不丢失的情况。</p><hr><p>在计算机系统中，尤其是多道程序运行的环境下，可能会出现内存不够用的情况，怎么办？</p><ul><li>手动的覆盖技术(overlay)：程序太大，超过了内存限制，只把需要的指令和数据保存在内存当中。</li><li>自动的交换技术(swapping)：程序太多，超过了内存的容量，把暂时不能执行的程序送到外存中。</li><li>自动的虚拟存储技术：在有限容量的内存中，以更小的页粒度为单位装入更多更大的程序。</li></ul><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210241859499.png" alt="image-20221024185954398"></p><p>​    简单理解为：分时共享</p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210241903462.png" alt="image-20221024190350386" style="zoom:80%;" /><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210241909327.png" alt="image-20221024190904279"></p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210241910196.png" alt="image-20221024191028116" style="zoom:80%;" /><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210241912140.png" alt="image-20221024191237043"></p><p>导入、导出的开销比较大。</p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210241915532.png" alt="image-20221024191546453" style="zoom: 80%;" /><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210241919082.png" alt="image-20221024191939005"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210241920570.png" alt="image-20221024192038504"></p><blockquote><p>覆盖发生在程序内部，需要成需要自己操作，可操作性强。</p><p>交换是程序和程序之间的交换，对程序员是透明的，但是开销较大。</p></blockquote><h3 id="虚存技术"><a href="#虚存技术" class="headerlink" title="虚存技术"></a>虚存技术</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242000811.png" alt="image-20221024200008723"></p><p>解决方法：<strong>虚存技术</strong></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242002491.png" alt="image-20221024200233396"></p><h4 id="程序局部性原理"><a href="#程序局部性原理" class="headerlink" title="程序局部性原理"></a>程序局部性原理</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242004817.png" alt="image-20221024200412708"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242006623.png" alt="image-20221024200625532"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242012746.png" alt="image-20221024201256673"></p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242013872.png" alt="image-20221024201349772"></p><h4 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242021943.png" alt="image-20221024202147848"></p><h4 id="虚拟页氏内存管理"><a href="#虚拟页氏内存管理" class="headerlink" title="虚拟页氏内存管理"></a>虚拟页氏内存管理</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242023031.png" alt="image-20221024202349935"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242035433.png" alt="image-20221024203504348"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242036655.png" alt="image-20221024203607559"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242038440.png" alt="image-20221024203826351"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242045765.png" alt="image-20221024204539674"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242048614.png" alt="image-20221024204835527"></p><p>1+q换入换出比例</p><p>如果P足够小，EAT接近10ns。</p><p>因为程序具有局部性的特点，所以可以保证接近10ns。</p><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><h3 id="功能设置"><a href="#功能设置" class="headerlink" title="功能设置"></a>功能设置</h3><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261900658.png" alt="image-20221026185719787"></p><h3 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h3><h4 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h4><blockquote><p>思路：把将来最少用到的页面置换出去</p></blockquote><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261902822.png" alt="image-20221026190240689"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261906943.png" alt="image-20221026190611852"></p><p>d在将来用的距离最短，先置换出去。</p><h4 id="先进先出算法（FIFO）"><a href="#先进先出算法（FIFO）" class="headerlink" title="先进先出算法（FIFO）"></a>先进先出算法（FIFO）</h4><blockquote><p>思路：像队列一样，把先进入的先置换出去。</p></blockquote><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261907776.png" alt="image-20221026190744628"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261913970.png" alt="image-20221026191335866"></p><h4 id="最近最久未使用算法（LRU）"><a href="#最近最久未使用算法（LRU）" class="headerlink" title="最近最久未使用算法（LRU）"></a>最近最久未使用算法（LRU）</h4><blockquote><p>思路：替换出最近一段时间没有使用的页面，通过过去推测置换页面，对最优置换算法的改写。</p><p>利用了程序的时间局部性。</p></blockquote><blockquote><p>程序局部性：</p><ul><li>时间局部性：最近访问过的数据，之后还要访问。</li><li>空间局部性：数据内聚在一起。</li></ul></blockquote><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261915707.png" alt="image-20221026191553571"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261926322.png" alt="image-20221026192608208"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261928790.png" alt="image-20221026192831635"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261930470.png" alt="image-20221026193048348"></p><h4 id="时钟页面置换算法（Clock）"><a href="#时钟页面置换算法（Clock）" class="headerlink" title="时钟页面置换算法（Clock）"></a>时钟页面置换算法（Clock）</h4><blockquote><p>思路</p><p>当访问一个页时，硬件会把该页的access bit置1，过一段时间，OS会把access bit置0。</p><p>Clock算法就是对FIFO的改进，让他找一个相对比较“老”的数据置换出去。</p></blockquote><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261933471.png" alt="image-20221026193337321"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261938558.png" alt="image-20221026193846449"></p><p>构建一个环形链表，遇到要置换的情况，从当前指针开始遍历链表。    </p><ul><li><p>先看会不会发生缺页，缺页就是查询的过程，如果有的话，access byte 先置1，表示最近访问过。</p></li><li><p>下来才会进行Clock算法。</p></li><li><p>遇到access bit为1，置0，让他”老”一步，跳到下一个位置。</p></li><li><p>遇到access bit为0，替换，指针指向下一个节点。</p></li></ul><h4 id="二次机会法"><a href="#二次机会法" class="headerlink" title="二次机会法"></a>二次机会法</h4><p>如果是写操作，dirty bit会为1</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262013789.png" alt="image-20221026201351687"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262022938.png" alt="image-20221026202258814"></p><h4 id="最不常用算法（LFU）"><a href="#最不常用算法（LFU）" class="headerlink" title="最不常用算法（LFU）"></a>最不常用算法（LFU）</h4><blockquote><p>思路：选择访问次数最少的页面</p></blockquote><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262024919.png" alt="image-20221026202410800"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262025948.png" alt="image-20221026202548885"></p><h4 id="Belady现象"><a href="#Belady现象" class="headerlink" title="Belady现象"></a>Belady现象</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262029595.png" alt="image-20221026202918485"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262032255.png" alt="image-20221026203200127"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262033818.png" alt="image-20221026203310691"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262034483.png" alt="image-20221026203420381"></p><ul><li>LRU满足栈算法</li><li>FIFO不满足栈算法</li></ul><h4 id="LRU、FIFO、Clock的比较"><a href="#LRU、FIFO、Clock的比较" class="headerlink" title="LRU、FIFO、Clock的比较"></a>LRU、FIFO、Clock的比较</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262035833.png" alt="image-20221026203539653"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262038624.png" alt="image-20221026203815501"></p><p>Clock和LRU如果不具备局部性，会退化为FIFO</p><h3 id="全局页面置换算法"><a href="#全局页面置换算法" class="headerlink" title="全局页面置换算法"></a>全局页面置换算法</h3><h4 id="局部页替换算法的问题"><a href="#局部页替换算法的问题" class="headerlink" title="局部页替换算法的问题"></a>局部页替换算法的问题</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262039313.png" alt="image-20221026203937206"></p><ul><li>固定分配的页帧大小没有考虑实际的动态变化，可能会发生较多缺失，能不能动态地分配页帧大小？</li></ul><h4 id="工作集模式"><a href="#工作集模式" class="headerlink" title="工作集模式"></a>工作集模式</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262041114.png" alt="image-20221026204100955"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262043366.png" alt="image-20221026204303245"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262045042.png" alt="image-20221026204515932"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262046727.png" alt="image-20221026204614633"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262046569.png" alt="image-20221026204658421"></p><h4 id="工作集页置换算法"><a href="#工作集页置换算法" class="headerlink" title="工作集页置换算法"></a>工作集页置换算法</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262050687.png" alt="image-20221026205054584"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262055025.png" alt="image-20221026205539898"></p><p>如果数据的时间大于工作集大小，即使空间还有，也会换出。</p><h4 id="缺页率置换算法"><a href="#缺页率置换算法" class="headerlink" title="缺页率置换算法"></a>缺页率置换算法</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262056906.png" alt="image-20221026205626748"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262057721.png" alt="image-20221026205706623"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262057843.png" alt="image-20221026205747759"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262058975.png" alt="image-20221026205843873"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262104019.png" alt="image-20221026210411888"></p><p>时刻4时，两次中断的时间大于预定时间T，认为跑的比较好，减少工作集，把1-4访问的页继续留在这，其他的页移除。</p><h4 id="抖动问题"><a href="#抖动问题" class="headerlink" title="抖动问题"></a>抖动问题</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262106107.png" alt="image-20221026210658924"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262110155.png" alt="image-20221026211027063"></p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程-process-描述"><a href="#进程-process-描述" class="headerlink" title="进程(process)描述"></a>进程(process)描述</h3><h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><p><strong>进程：</strong>一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210281915900.png" alt="image-20221028191536744"></p><h4 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210311635633.png" alt="image-20221031163515491"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210311636358.png" alt="image-20221031163602283"></p><p>进程不等于程序，进程是cpu的依次执行过程，程序只是静态的代码。</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312249680.png" alt=" "></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312251791.png" alt="image-20221031225136685"></p><h4 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h4><blockquote><p>并发，一段时间内多个进程同时执行</p><p>并行，一个时刻多个进程同时执行</p></blockquote><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312258326.png" alt="image-20221031225850239"></p><p>如何设计一个OS来保证以上特点？</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312300208.png" alt="image-20221031230021117"></p><p>通过进程控制块来保证进程的特点。</p><h4 id="进程控制结构"><a href="#进程控制结构" class="headerlink" title="进程控制结构"></a>进程控制结构</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312317566.png" alt="image-20221031231749475"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312318331.png" alt="image-20221031231826227"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312319603.png" alt="image-20221031231912491"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312320922.png" alt="image-20221031232033815"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312323409.png" alt="image-20221031232310314"></p><h3 id="进程状态-State"><a href="#进程状态-State" class="headerlink" title="进程状态(State)"></a>进程状态(State)</h3><h4 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h4><ol><li><p>进程创建</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312325340.png" alt="image-20221031232557255"></p></li><li><p>进程运行</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312326280.png" alt="image-20221031232657201"></p></li><li><p>进程等待</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312327433.png" alt="image-20221031232730351"></p></li><li><p>进程唤醒</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312328585.png" alt="image-20221031232852501"></p></li><li><p>进程结束</p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312329921.png" alt="image-20221031232928822"></p></li></ol><h4 id="进程的状态变化"><a href="#进程的状态变化" class="headerlink" title="进程的状态变化"></a>进程的状态变化</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312330026.png" alt="image-20221031233057933"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312331823.png" alt="image-20221031233140734"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312332877.png" alt="image-20221031233207784"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312334156.png" alt="image-20221031233414083"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312335248.png" alt="image-20221031233525168"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312336793.png" alt="image-20221031233601720"></p><h4 id="进程挂起模型"><a href="#进程挂起模型" class="headerlink" title="进程挂起模型"></a>进程挂起模型</h4><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312337280.png" alt="image-20221031233731185"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312340601.png" alt="image-20221031234050492"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312341015.png" alt="image-20221031234142922"></p><blockquote><p>OS如何管理PCD?</p></blockquote><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312342090.png" alt="image-20221031234233017"></p><p><img src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312343000.png" alt="image-20221031234319915"></p><h3 id="线程-Thread"><a href="#线程-Thread" class="headerlink" title="线程(Thread)"></a>线程(Thread)</h3><h3 id="进程间通信-INTER-PROCESS-COMMUNICATION"><a href="#进程间通信-INTER-PROCESS-COMMUNICATION" class="headerlink" title="进程间通信(INTER-PROCESS COMMUNICATION)"></a>进程间通信(INTER-PROCESS COMMUNICATION)</h3><h3 id="进程互斥与同步"><a href="#进程互斥与同步" class="headerlink" title="进程互斥与同步"></a>进程互斥与同步</h3><h3 id="死锁-DEADLOCK"><a href="#死锁-DEADLOCK" class="headerlink" title="死锁(DEADLOCK)"></a>死锁(DEADLOCK)</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>图解MySQL</title>
    <link href="http://huangrd.top/pages/uncategorized/mysql.html"/>
    <id>http://huangrd.top/pages/uncategorized/mysql.html</id>
    <published>2022-09-06T00:06:26.951Z</published>
    <updated>2022-11-01T16:31:52.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图解MySQL"><a href="#图解MySQL" class="headerlink" title="图解MySQL"></a>图解MySQL</h1><h2 id="一、MySQL的执行流程"><a href="#一、MySQL的执行流程" class="headerlink" title="一、MySQL的执行流程"></a>一、MySQL的执行流程</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p><p>MySQL 的架构共分为两层：<code>Server 层</code>和<code>存储引擎层</code></p><ul><li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</li><li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</li></ul><p>好了，现在我们对 Server 层和存储引擎层有了一个简单认识，接下来，就详细说一条 SQL 查询语句的执行流程，依次看看每一个功能模块的作用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图解MySQL&quot;&gt;&lt;a href=&quot;#图解MySQL&quot; class=&quot;headerlink&quot; title=&quot;图解MySQL&quot;&gt;&lt;/a&gt;图解MySQL&lt;/h1&gt;&lt;h2 id=&quot;一、MySQL的执行流程&quot;&gt;&lt;a href=&quot;#一、MySQL的执行流程&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
</feed>
