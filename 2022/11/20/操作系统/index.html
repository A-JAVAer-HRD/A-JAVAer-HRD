<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统 | Huang Blog</title><meta name="author" content="Huang RD"><meta name="copyright" content="Huang RD"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="操作系统一、概述1、什么是操作系统给用户提供服务、对程序进行管理、对资源进行分配。  操作系统是一个控制软件，管理应用程序 操作系统为应用程序提供服务，杀死应用程序 操作系统进行资源管理，管理外设、分配资源    1.1、操作系统的架层次结构 硬件之上，应用程序之下。处于中间位置  操作系统位于应用软件之下，为应用软件提供服务支撑。   操作系统给外部提供的服务shell 1.2、操作系统的功能">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://www.haungrd.top/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Huang Blog">
<meta property="og:description" content="操作系统一、概述1、什么是操作系统给用户提供服务、对程序进行管理、对资源进行分配。  操作系统是一个控制软件，管理应用程序 操作系统为应用程序提供服务，杀死应用程序 操作系统进行资源管理，管理外设、分配资源    1.1、操作系统的架层次结构 硬件之上，应用程序之下。处于中间位置  操作系统位于应用软件之下，为应用软件提供服务支撑。   操作系统给外部提供的服务shell 1.2、操作系统的功能">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.huangrd.top/images/agentina/11.jpg">
<meta property="article:published_time" content="2022-11-20T04:12:57.000Z">
<meta property="article:modified_time" content="2023-03-05T11:49:04.464Z">
<meta property="article:author" content="Huang RD">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="计算机基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.huangrd.top/images/agentina/11.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.haungrd.top/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-05 19:49:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://getwallpapers.com/wallpaper/full/a/1/8/1057222-free-download-cool-nature-backgrounds-1920x1200-windows-10.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.huangrd.top/images/agentina/11.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Huang Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-20T04:12:57.000Z" title="发表于 2022-11-20 12:12:57">2022-11-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-05T11:49:04.464Z" title="更新于 2023-03-05 19:49:04">2023-03-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>74分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1、什么是操作系统"><a href="#1、什么是操作系统" class="headerlink" title="1、什么是操作系统"></a>1、什么是操作系统</h3><p>给用户提供服务、对程序进行管理、对资源进行分配。</p>
<ul>
<li>操作系统是一个控制软件，管理应用程序</li>
<li>操作系统为应用程序提供服务，杀死应用程序</li>
<li>操作系统进行资源管理，管理外设、分配资源</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210161917251.png" alt="image-20221016191756140" style="zoom: 50%;" />

<h4 id="1-1、操作系统的架层次结构"><a href="#1-1、操作系统的架层次结构" class="headerlink" title="1.1、操作系统的架层次结构"></a>1.1、操作系统的架层次结构</h4><blockquote>
<p>硬件之上，应用程序之下。处于中间位置</p>
</blockquote>
<p>操作系统位于应用软件之下，为应用软件提供服务支撑。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210161922006.png" alt="image-20221016192204876" style="zoom: 50%;" />

<p>操作系统给外部提供的服务shell</p>
<h4 id="1-2、操作系统的功能"><a href="#1-2、操作系统的功能" class="headerlink" title="1.2、操作系统的功能"></a>1.2、操作系统的功能</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210161927344.png" alt="image-20221016192700234" style="zoom:50%;" />

<ol>
<li>CPU的调度</li>
<li>物理内存的管理</li>
<li>虚拟内存的管理</li>
<li>文件系统的管理</li>
<li>中断处理和设备驱动</li>
</ol>
<h4 id="1-3、操作系统的特征"><a href="#1-3、操作系统的特征" class="headerlink" title="1.3、操作系统的特征"></a>1.3、操作系统的特征</h4><ol>
<li><p>并发</p>
<p>计算机系统中同时存在多个运行的程序，需要OS管理和调度</p>
<p><code>并发和并行的区别</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">并发：在一段时间内，有多个程序可以运行。</span><br><span class="line">并行：在一个时间点上，有多个程序可以运行。</span><br><span class="line">并行一般要求计算机系统存在多个CPU，这样才能使OS在一个时间同时执行多个程序。只有一个CPU，则不能并行。</span><br></pre></td></tr></table></figure>
</li>
<li><p>共享</p>
<ul>
<li>”同时“访问</li>
<li>互斥访问</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">互斥访问：对于同一个内存空间，同一个时间点只有一个程序能够访问。</span><br><span class="line">同时访问：一个程序可以在同一个时间点访问多块不同的内存。</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚拟</p>
<ul>
<li>利用多道程序设计，让每个用户都觉得有一个计算机专门为他服务</li>
</ul>
</li>
<li><p>异步</p>
<ul>
<li>程序执行不是一贯到底，而是走走停停，向前推进的速度不可预知</li>
<li>但只要运行环境相同，OS需要保证程序运行的结果也要相同</li>
</ul>
</li>
</ol>
<h3 id="2、为什么学习操作系统"><a href="#2、为什么学习操作系统" class="headerlink" title="2、为什么学习操作系统"></a>2、为什么学习操作系统</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210161958530.png" alt="image-20221016195802432"></p>
<h4 id="2-1、操作系统需要权衡"><a href="#2-1、操作系统需要权衡" class="headerlink" title="2.1、操作系统需要权衡"></a>2.1、操作系统需要权衡</h4><ul>
<li>空间和时间</li>
<li>性能和可预测性</li>
<li>公平和性能</li>
</ul>
<h3 id="3、操作系统实例"><a href="#3、操作系统实例" class="headerlink" title="3、操作系统实例"></a>3、操作系统实例</h3><ul>
<li>UNIX</li>
<li>LINUX</li>
<li>WINDOWS</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162009726.png" alt="image-20221016200900650"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162010103.png" alt="image-20221016201051018"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162011766.png" alt="image-20221016201153666"></p>
<h3 id="4、操作系统的发展"><a href="#4、操作系统的发展" class="headerlink" title="4、操作系统的发展"></a>4、操作系统的发展</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162013743.png" alt="image-20221016201341616"></p>
<ol>
<li>纸带机（监视器）</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162014261.png" alt="image-20221016201450137"></p>
<ol start="2">
<li>CPU等硬件快速发展，计算机速度提升，性能未得到充分利用。</li>
</ol>
<p>流水线程序设计</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162016585.png" alt="image-20221016201617502"></p>
<ol start="3">
<li>内存容量越来越大，CPU执行多个程序。</li>
</ol>
<p>多道程序设计，cpu在IO执行过程中，执行其他的程序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162017166.png" alt="image-20221016201704115"></p>
<p>多道程序设计提高了CPU的利用效率，但是交互性不好。</p>
<ol start="4">
<li>为了更好的利用计算机资源，并且更好的和用户进行交互，出现了分时系统。</li>
</ol>
<p>CPU将时间片分为1&#x2F;1000S，1&#x2F;1000执行程序1，之后执行程序2，再来回切换。</p>
<ol start="5">
<li><p>个人电脑操作系统PC</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162026243.png" alt="image-20221016202656160"></p>
</li>
<li><p>网络的快速发展，出现了分布式的操作系统</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162028707.png" alt="image-20221016202830643"></p>
</li>
<li><p>云计算</p>
<p>人的周围出现大量嵌入式系统，给人个性化服务。</p>
</li>
</ol>
<h3 id="5、操作系统的结构"><a href="#5、操作系统的结构" class="headerlink" title="5、操作系统的结构"></a>5、操作系统的结构</h3><p>微内核的设计，尽可能把内核功能熙东到用户空间</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162038032.png" alt="image-20221016203805979"></p>
<p>VMM</p>
<p>位于操作系统之下，让OS觉得自己直接在操纵硬件。（虚拟化）</p>
<p>充分发挥硬件资源，防止资源过剩。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162040832.png" alt="image-20221016204023743"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162041321.png" alt="image-20221016204103221"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210162041559.png" alt="image-20221016204115441"></p>
<h2 id="二、操作系统的基本操作"><a href="#二、操作系统的基本操作" class="headerlink" title="二、操作系统的基本操作"></a>二、操作系统的基本操作</h2><h3 id="1、启动、中断、异常和系统调用"><a href="#1、启动、中断、异常和系统调用" class="headerlink" title="1、启动、中断、异常和系统调用"></a>1、启动、中断、异常和系统调用</h3><h4 id="1-1、启动"><a href="#1-1、启动" class="headerlink" title="1.1、启动"></a>1.1、启动</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171640102.png" alt="image-20221017164000023" style="zoom:50%;" />



<p>DISK:存放OS</p>
<p>BIOS:基本的I&#x2F;O处理系统</p>
<p>Bootloader:加载OS</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171641326.png" alt="image-20221017164154259" style="zoom:50%;" />

<p>POST（加电自检）：寻找显卡和执行BIOS</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171646179.png" alt="image-20221017164622111" style="zoom: 80%;" />

<h4 id="1-2、中断、异常和系统调用"><a href="#1-2、中断、异常和系统调用" class="headerlink" title="1.2、中断、异常和系统调用"></a>1.2、中断、异常和系统调用</h4><p>操作系统怎样管理外设，怎么给应用程序提供服务?</p>
<ul>
<li><p>系统调用（来源于应用程序）：系统程序主动向操作系统发出服务请求。</p>
</li>
<li><p>异常（来源于不良的应用程序）：非法指令或者其他坏的处理状态（如：内存出错）</p>
</li>
<li><p>中断（来源于外设）：来自不同的硬件设备的计时器和网络中断</p>
</li>
</ul>
<p>为什么应用程序要通过操作系统来管理硬件？</p>
<ul>
<li>操作系统是一种特殊的软件，在计算机运行中，内核是被信任的第三方，计算机认为操作系统是安全的，而软件并不都是安全的。</li>
<li>因此，只有内核可以执行特权命令。</li>
<li>把计算机的硬件资源全部交给操作系统进行管理，有利于软件设计时便捷，软件的可移植性较高。</li>
</ul>
<p>操作系统如何实现中断、异常和系统调用？</p>
<p>这三者有什么联系和差异？</p>
<p>源头：</p>
<ul>
<li>中断：外设</li>
<li>异常：应用程序意想不到的行为</li>
<li>系统调用：应用程序请求操作提供服务（主动的）</li>
</ul>
<p>处理时间：</p>
<ul>
<li><p>中断：异步</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  异步时间：当中断产生时，应用程序并不知道什么时候产生的</span><br><span class="line"></span><br><span class="line">- 异常：同步</span><br><span class="line"></span><br><span class="line">- 系统调用：异步或同步</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>系统调用发出请求时，返回的时间可能是异步的，当系统调用发送请求后，如果执行其他程序，则返回数据是异步的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">响应：</span><br><span class="line"></span><br><span class="line">- 中断：持续，对用户应用程序是透明的（应用程序不知道有没有发生中断）。</span><br><span class="line">- 异常：杀死或者重新执行意想不到的应用程序指令。</span><br><span class="line">- 系统调用：等待和持续。</span><br><span class="line"></span><br><span class="line">##### 中断的处理过程</span><br><span class="line"></span><br><span class="line">硬件：</span><br><span class="line"></span><br><span class="line">1. 将内部、外部事件设置中断标记</span><br><span class="line">2. 中断事件的ID</span><br><span class="line"></span><br><span class="line">硬件：</span><br><span class="line"></span><br><span class="line">1. 保存当前状态</span><br><span class="line">2. 中断服务程序处理</span><br><span class="line">3. 清楚中断标记</span><br><span class="line">4. 恢复之前保存的处理状态</span><br><span class="line"></span><br><span class="line">##### 异常的处理过程</span><br><span class="line"></span><br><span class="line">异常会产生相应的异常编号:</span><br><span class="line"></span><br><span class="line">1. 保存现场</span><br><span class="line">2. 异常处理</span><br><span class="line">   - 杀死产生异常的程序</span><br><span class="line">   - 重新执行异常的指令</span><br><span class="line">3. 恢复现常</span><br><span class="line"></span><br><span class="line">##### 系统调用的处理</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171915550.png&quot; alt=&quot;image-20221017191542503&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">程序访问主要通过高层次的API接口而不是直接进行系统调用。</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171919724.png&quot; alt=&quot;image-20221017191919661&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://gitee.com/messi-study-java/pic_go/raw/master/img/202210171920439.png&quot; alt=&quot;image-20221017192013385&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">当应用程序进行系统调用时，操作系统会从用户态到内核态的转化，操作权从应用程序转为操作系统。操作系统对应用程序的系统调用的id号进行标识。</span><br><span class="line"></span><br><span class="line">系统调用和程序调用的区别？</span><br><span class="line"></span><br><span class="line">程序调用是一个栈空间完成的</span><br><span class="line"></span><br><span class="line">系统调用，在应用程序调用系统调用时会切换堆栈，还要完成用户态的转换，因此系统调用的开销比较大，但是安全性高。</span><br><span class="line"></span><br><span class="line">##### 跨越操作系统边界的开销</span><br><span class="line"></span><br><span class="line">- 在执行时间上的开销超过程序调用</span><br><span class="line">- 开销：</span><br><span class="line">  - 建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销</span><br><span class="line">  - 建立内核堆栈</span><br><span class="line">  - 验证参数</span><br><span class="line">  - 内核态映射到用户态的地址空间，更新页面映射权限</span><br><span class="line">  - 内核态独立地址空间 TLB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&gt; 操作系统如何管理物理内存</span><br><span class="line"></span><br><span class="line">## 三、连续内存分配</span><br><span class="line"></span><br><span class="line">### 1、计算机体系结构、内存分层体系</span><br><span class="line"></span><br><span class="line">![image-20221018211705744](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182117488.png)</span><br><span class="line"></span><br><span class="line">内存的层次结构：</span><br><span class="line"></span><br><span class="line">![image-20221018211801644](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182118723.png)</span><br><span class="line"></span><br><span class="line">通过操作系统来管理内存，达到稳定快速。</span><br><span class="line"></span><br><span class="line">![image-20221018212040398](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182120477.png)</span><br><span class="line"></span><br><span class="line">操作系统还能隔离进程之间的地址空间，也能在进程间进行保护。</span><br><span class="line"></span><br><span class="line">1. 抽象(对逻辑地址空间)</span><br><span class="line">2. 保护(进程的独立地址空间)</span><br><span class="line">3. 共享</span><br><span class="line">4. 虚拟化(更多的地址空间 虚拟内存：硬盘)</span><br><span class="line"></span><br><span class="line">操作系统管理内存的方法：</span><br><span class="line"></span><br><span class="line">- 程序重定位</span><br><span class="line">- 分段</span><br><span class="line">- 分页</span><br><span class="line">- 虚拟内存</span><br><span class="line">- 按需分配内存</span><br><span class="line"></span><br><span class="line">以上的方法高度依赖于硬件：</span><br><span class="line"></span><br><span class="line">- 必须直到内存架构</span><br><span class="line">- MMU（内存管理单元）：硬件组件负责处理CPU的内存访问请求。</span><br><span class="line"></span><br><span class="line">### 2、地址空间、地址生成</span><br><span class="line"></span><br><span class="line">#### 地址空间</span><br><span class="line"></span><br><span class="line">![image-20221018212807441](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182128534.png)</span><br><span class="line"></span><br><span class="line">物理地址空间：内存条、硬盘</span><br><span class="line"></span><br><span class="line">逻辑地址空间：一个运行的程序对应的地址空间</span><br><span class="line"></span><br><span class="line">逻辑地址空间实际上是落脚在实际的物理地址空间的，需要操作系统的管理。</span><br><span class="line"></span><br><span class="line">#### 地址生成</span><br><span class="line"></span><br><span class="line">逻辑地址怎么生成的？</span><br><span class="line"></span><br><span class="line">![image-20221018213031811](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182130906.png)</span><br><span class="line"></span><br><span class="line">一步一步的编译，最后通过loader（应用程序）把执行程序的逻辑地址分配在物理地址。</span><br><span class="line"></span><br><span class="line">![image-20221018213334501](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182133589.png)</span><br><span class="line"></span><br><span class="line">CPU中的MMU保存了逻辑地址到物理地址的映射关系。来让我们通过映射访问到实际的物理地址。</span><br><span class="line"></span><br><span class="line">1. CPU执行某条指令，ALU请求逻辑地址</span><br><span class="line">2. CPU的MMU查找逻辑地址的映射表map是否存在对应物理地址，找到，返回。没有，去内存找。</span><br><span class="line">3. 如果有，给主存发送请求，需要物理地址的内容。</span><br><span class="line">4. 主存通过总线，把内容传给CPU。</span><br><span class="line">5. CPU拿到数据后，继续指令的执行。</span><br><span class="line"></span><br><span class="line">操作系统实际上是完成了从逻辑地址到物理地址关系的映射。</span><br><span class="line"></span><br><span class="line">![image-20221018214110531](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182142610.png)</span><br><span class="line"></span><br><span class="line">- 编译器会把基于符号的地址空间到逻辑地址空间。</span><br><span class="line">- 操作系统会把逻辑地址空间映射到物理地址空间。同时保证程序独立分配地址空间，保证程序的正常运行。</span><br><span class="line"></span><br><span class="line">### 3、连续内存分配</span><br><span class="line"></span><br><span class="line">#### 内存碎片问题</span><br><span class="line"></span><br><span class="line">![image-20221018214320476](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182143566.png)</span><br><span class="line"></span><br><span class="line">希望通过一种有效的分配方法，来减少内碎片、外碎片的问题。</span><br><span class="line"></span><br><span class="line">#### 分区的动态分配</span><br><span class="line"></span><br><span class="line">![image-20221018214531315](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182145391.png)</span><br><span class="line"></span><br><span class="line">操作系统需要管理分配了和未分配的空间。</span><br><span class="line"></span><br><span class="line">#### 分配策略</span><br><span class="line"></span><br><span class="line">##### 首次适配</span><br><span class="line"></span><br><span class="line">![image-20221018214653040](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182147966.png)</span><br><span class="line"></span><br><span class="line">实现：从第一块开始分配 0地址</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182149601.png&quot; alt=&quot;image-20221018214916478&quot; style=&quot;zoom: 67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">##### 最优适配</span><br><span class="line"></span><br><span class="line">寻找最匹配的空间块。内存差最小。</span><br><span class="line"></span><br><span class="line">![image-20221018215023254](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182150373.png)</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182150929.png&quot; alt=&quot;image-20221018215046854&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">##### 最差适配</span><br><span class="line"></span><br><span class="line">![image-20221018215205253](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182152368.png)</span><br><span class="line"></span><br><span class="line">和最优适配对应，找到内存差最大的内存块。</span><br><span class="line"></span><br><span class="line">![image-20221018215253220](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182152296.png)</span><br><span class="line"></span><br><span class="line">中大型请求，最差适配还是比较合适的。</span><br><span class="line"></span><br><span class="line">应对不同的情况，选择不同的分配策略。</span><br><span class="line"></span><br><span class="line">#### 压缩式和交换式碎片处理</span><br><span class="line"></span><br><span class="line">如何把碎片联合起来，组成大的连续的碎片？</span><br><span class="line"></span><br><span class="line">##### 压缩式碎片处理</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182158695.png&quot; alt=&quot;image-20221018215857582&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">把之前的内存进行拷贝。</span><br><span class="line"></span><br><span class="line">问题：</span><br><span class="line"></span><br><span class="line">- 什么时候进行拷贝？(时机：可以在程序等待的过程中)</span><br><span class="line">- 开销大不大？（时间的开销，会不会影响程序的执行）</span><br><span class="line"></span><br><span class="line">##### 交换式碎片整理</span><br><span class="line"></span><br><span class="line">![image-20221018220200392](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210182202473.png)</span><br><span class="line"></span><br><span class="line">没有空闲空间了，不能使用紧致(压缩式)。</span><br><span class="line"></span><br><span class="line">通过把程序耗费的内存移到硬盘中。</span><br><span class="line"></span><br><span class="line">问题：</span><br><span class="line"></span><br><span class="line">- 选择哪一个程序进行移动？</span><br><span class="line">- 在什么时机进行移动？</span><br><span class="line">- 开销的大小？</span><br><span class="line"></span><br><span class="line">## 四、非连续内存分配</span><br><span class="line"></span><br><span class="line">### 1、为什么需要非连续内存分配这种管理方式？</span><br><span class="line"></span><br><span class="line">连续内存分配的缺点：</span><br><span class="line"></span><br><span class="line">- 分配给一个程序的物理内存是连续的</span><br><span class="line">- 内存利用率较低</span><br><span class="line">- 有外碎片、内碎片问题</span><br><span class="line"></span><br><span class="line">非连续分配的优点：</span><br><span class="line"></span><br><span class="line">- 一个程序的物理地址空间是连续的</span><br><span class="line">- 更好的内存利用和管理</span><br><span class="line">- 允许共享代码与数据（贡献库等...）</span><br><span class="line">- 支持动态加载和动态链接</span><br><span class="line"></span><br><span class="line">非连续分配的缺点：</span><br><span class="line"></span><br><span class="line">建立虚拟地址和物理地址之间转换的开销</span><br><span class="line"></span><br><span class="line">- 硬件方案</span><br><span class="line">  - 分页</span><br><span class="line">  - 分段</span><br><span class="line">- 软件方案</span><br><span class="line"></span><br><span class="line">### 2、非连续内存分配的方法</span><br><span class="line"></span><br><span class="line">- 分段(Segmentation)</span><br><span class="line">- 分页(Paging)</span><br><span class="line"></span><br><span class="line">#### 分段</span><br><span class="line"></span><br><span class="line">- 程序的分段地址空间</span><br><span class="line">- 分段寻址方案</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;C:/Users/huangruidong/AppData/Roaming/Typora/typora-user-images/image-20221021112201543.png&quot; alt=&quot;image-20221021112201543&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">![image-20221021112305222](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211123316.png)</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211124935.png&quot; alt=&quot;image-20221021112415866&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">将连续的逻辑地址空间分段为非连续的物理地址空间</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211125905.png&quot; alt=&quot;image-20221021112538821&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">![image-20221021112646245](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211126339.png)</span><br><span class="line"></span><br><span class="line">分段地址选址：段号+段的偏移</span><br><span class="line"></span><br><span class="line">#### 分页</span><br><span class="line"></span><br><span class="line">页地址选址：页号+页的偏移</span><br><span class="line"></span><br><span class="line">分页和分段的区别：</span><br><span class="line"></span><br><span class="line">- 在分段里边，段的尺寸是可变的</span><br><span class="line">- 在分页里边，页的尺寸大小是不变的</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211140279.png&quot; alt=&quot;image-20221021114022106&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211141715.png&quot; alt=&quot;image-20221021114130624&quot; style=&quot;zoom: 80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211144516.png&quot; alt=&quot;image-20221021114456415&quot; style=&quot;zoom:80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;C:/Users/huangruidong/AppData/Roaming/Typora/typora-user-images/image-20221021114907052.png&quot; alt=&quot;image-20221021114907052&quot; style=&quot;zoom:80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211153061.png&quot; alt=&quot;image-20221021115234290&quot; style=&quot;zoom:80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">通过页号查帧号</span><br><span class="line"></span><br><span class="line">![image-20221021115635068](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211156179.png)</span><br><span class="line"></span><br><span class="line">#### 页表</span><br><span class="line"></span><br><span class="line">![image-20221021132609864](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211326985.png)</span><br><span class="line"></span><br><span class="line">![image-20221021132637568](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211326654.png)</span><br><span class="line"></span><br><span class="line">![image-20221021150916315](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211509423.png)</span><br><span class="line"></span><br><span class="line">![image-20221021151523105](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211515167.png)</span><br><span class="line"></span><br><span class="line">- 页表可能占的空间很大</span><br><span class="line">- 页表如果放在内存上，时间上的开销很大。</span><br><span class="line"></span><br><span class="line">##### 应对时间开销：TLB</span><br><span class="line"></span><br><span class="line">![image-20221021151553493](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211515561.png)</span><br><span class="line"></span><br><span class="line">##### 应对内存开销：多级页表</span><br><span class="line"></span><br><span class="line">![image-20221021152354583](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211523651.png)</span><br><span class="line"></span><br><span class="line">![image-20221021152404907](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211524984.png)</span><br><span class="line"></span><br><span class="line">像B+树一样</span><br><span class="line"></span><br><span class="line">##### 反向页表</span><br><span class="line"></span><br><span class="line">![image-20221021152622306](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211526374.png)</span><br><span class="line"></span><br><span class="line">反转：以物理页号查找逻辑页号</span><br><span class="line"></span><br><span class="line">![image-20221021152808496](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211528561.png)</span><br><span class="line"></span><br><span class="line">![image-20221021152930397](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211529460.png)</span><br><span class="line"></span><br><span class="line">![image-20221021153115447](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211531525.png)</span><br><span class="line"></span><br><span class="line">![image-20221021153208185](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210211532275.png)</span><br><span class="line"></span><br><span class="line">## 五、虚拟内存管理技术</span><br><span class="line"></span><br><span class="line">### 1、虚拟内存的起因</span><br><span class="line"></span><br><span class="line">程序规模的增长速度远大于存储器容量的增长速度。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">理想中的存储器：</span><br><span class="line"></span><br><span class="line">- 更大</span><br><span class="line">- 更快</span><br><span class="line">- 更便宜</span><br><span class="line">- 非异失性</span><br><span class="line">- &lt;img src=&quot;C:/Users/huangruidong/AppData/Roaming/Typora/typora-user-images/image-20221024183501918.png&quot; alt=&quot;image-20221024183501918&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">硬盘比内存容量大，但是速度慢。</span><br><span class="line"></span><br><span class="line">能不能让操作系统通过一种操作，达到理想中的存储器？</span><br><span class="line"></span><br><span class="line">**自动的虚拟存储技术**</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://gitee.com/messi-study-java/pic_go/raw/master/img/202210241839139.png&quot; alt=&quot;image-20221024183954026&quot; style=&quot;zoom: 67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">但是目前还达不到掉电不丢失的情况。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">在计算机系统中，尤其是多道程序运行的环境下，可能会出现内存不够用的情况，怎么办？</span><br><span class="line"></span><br><span class="line">- 手动的覆盖技术(overlay)：程序太大，超过了内存限制，只把需要的指令和数据保存在内存当中。</span><br><span class="line">- 自动的交换技术(swapping)：程序太多，超过了内存的容量，把暂时不能执行的程序送到外存中。</span><br><span class="line">- 自动的虚拟存储技术：在有限容量的内存中，以更小的页粒度为单位装入更多更大的程序。</span><br><span class="line"></span><br><span class="line">### 2、覆盖技术</span><br><span class="line"></span><br><span class="line">![image-20221024185954398](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210241859499.png)</span><br><span class="line"></span><br><span class="line">​	简单理解为：分时共享</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://gitee.com/messi-study-java/pic_go/raw/master/img/202210241903462.png&quot; alt=&quot;image-20221024190350386&quot; style=&quot;zoom:80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">![image-20221024190904279](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210241909327.png)</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://gitee.com/messi-study-java/pic_go/raw/master/img/202210241910196.png&quot; alt=&quot;image-20221024191028116&quot; style=&quot;zoom:80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3、交换技术</span><br><span class="line"></span><br><span class="line">![image-20221024191237043](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210241912140.png)</span><br><span class="line"></span><br><span class="line">导入、导出的开销比较大。</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://gitee.com/messi-study-java/pic_go/raw/master/img/202210241915532.png&quot; alt=&quot;image-20221024191546453&quot; style=&quot;zoom: 80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">![image-20221024191939005](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210241919082.png)</span><br><span class="line"></span><br><span class="line">![image-20221024192038504](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210241920570.png)</span><br><span class="line"></span><br><span class="line">&gt;覆盖发生在程序内部，需要成需要自己操作，可操作性强。</span><br><span class="line">&gt;</span><br><span class="line">&gt;交换是程序和程序之间的交换，对程序员是透明的，但是开销较大。</span><br><span class="line"></span><br><span class="line">### 4、虚存技术</span><br><span class="line"></span><br><span class="line">#### 目标</span><br><span class="line"></span><br><span class="line">![image-20221024200008723](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242000811.png)</span><br><span class="line"></span><br><span class="line">解决方法：**虚存技术**</span><br><span class="line"></span><br><span class="line">![image-20221024200233396](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242002491.png)</span><br><span class="line"></span><br><span class="line">#### 程序局部性原理</span><br><span class="line"></span><br><span class="line">![image-20221024200412708](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242004817.png)</span><br><span class="line"></span><br><span class="line">![image-20221024200625532](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242006623.png)</span><br><span class="line"></span><br><span class="line">![image-20221024201256673](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242012746.png)</span><br><span class="line"></span><br><span class="line">#### 基本概念</span><br><span class="line"></span><br><span class="line">![image-20221024201349772](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242013872.png)</span><br><span class="line"></span><br><span class="line">#### 基本特性</span><br><span class="line"></span><br><span class="line">![image-20221024202147848](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242021943.png)</span><br><span class="line"></span><br><span class="line">#### 虚拟页氏内存管理</span><br><span class="line"></span><br><span class="line">![image-20221024202349935](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242023031.png)</span><br><span class="line"></span><br><span class="line">![image-20221024203504348](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242035433.png)</span><br><span class="line"></span><br><span class="line">![image-20221024203607559](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242036655.png)</span><br><span class="line"></span><br><span class="line">![image-20221024203826351](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242038440.png)</span><br><span class="line"></span><br><span class="line">![image-20221024204539674](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242045765.png)</span><br><span class="line"></span><br><span class="line">![image-20221024204835527](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210242048614.png)</span><br><span class="line"></span><br><span class="line">1+q换入换出比例</span><br><span class="line"></span><br><span class="line">如果P足够小，EAT接近10ns。</span><br><span class="line"></span><br><span class="line">因为程序具有局部性的特点，所以可以保证接近10ns。</span><br><span class="line"></span><br><span class="line">## 六、页面置换算法</span><br><span class="line"></span><br><span class="line">### 1、功能设置</span><br><span class="line"></span><br><span class="line">![image-20221026185719787](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261900658.png)</span><br><span class="line"></span><br><span class="line">### 2、局部页面置换算法</span><br><span class="line"></span><br><span class="line">#### 最优页面置换算法</span><br><span class="line"></span><br><span class="line">&gt; 思路：把将来最少用到的页面置换出去</span><br><span class="line"></span><br><span class="line">![image-20221026190240689](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261902822.png)</span><br><span class="line"></span><br><span class="line">![image-20221026190611852](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261906943.png)</span><br><span class="line"></span><br><span class="line">d在将来用的距离最短，先置换出去。</span><br><span class="line"></span><br><span class="line">#### 先进先出算法（FIFO）</span><br><span class="line"></span><br><span class="line">&gt; 思路：像队列一样，把先进入的先置换出去。</span><br><span class="line"></span><br><span class="line">![image-20221026190744628](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261907776.png)</span><br><span class="line"></span><br><span class="line">![image-20221026191335866](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261913970.png)</span><br><span class="line"></span><br><span class="line">#### 最近最久未使用算法（LRU）</span><br><span class="line"></span><br><span class="line">&gt; 思路：替换出最近一段时间没有使用的页面，通过过去推测置换页面，对最优置换算法的改写。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 利用了程序的时间局部性。</span><br><span class="line"></span><br><span class="line">&gt; 程序局部性：</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 时间局部性：最近访问过的数据，之后还要访问。</span><br><span class="line">&gt; - 空间局部性：数据内聚在一起。</span><br><span class="line"></span><br><span class="line">![image-20221026191553571](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261915707.png)</span><br><span class="line"></span><br><span class="line">![image-20221026192608208](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261926322.png)</span><br><span class="line"></span><br><span class="line">![image-20221026192831635](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261928790.png)</span><br><span class="line"></span><br><span class="line">![image-20221026193048348](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261930470.png)</span><br><span class="line"></span><br><span class="line">#### 时钟页面置换算法（Clock）</span><br><span class="line"></span><br><span class="line">&gt; 思路</span><br><span class="line">&gt;</span><br><span class="line">&gt; 当访问一个页时，硬件会把该页的access bit置1，过一段时间，OS会把access bit置0。</span><br><span class="line">&gt;</span><br><span class="line">&gt; Clock算法就是对FIFO的改进，让他找一个相对比较“老”的数据置换出去。</span><br><span class="line"></span><br><span class="line">![image-20221026193337321](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261933471.png)</span><br><span class="line"></span><br><span class="line">![image-20221026193846449](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261938558.png)</span><br><span class="line"></span><br><span class="line">构建一个环形链表，遇到要置换的情况，从当前指针开始遍历链表。	</span><br><span class="line"></span><br><span class="line">- 先看会不会发生缺页，缺页就是查询的过程，如果有的话，access byte 先置1，表示最近访问过。</span><br><span class="line">- 下来才会进行Clock算法。</span><br><span class="line"></span><br><span class="line">- 遇到access bit为1，置0，让他&quot;老&quot;一步，跳到下一个位置。</span><br><span class="line">- 遇到access bit为0，替换，指针指向下一个节点。</span><br><span class="line"></span><br><span class="line">#### 二次机会法</span><br><span class="line"></span><br><span class="line">如果是写操作，dirty bit会为1</span><br><span class="line"></span><br><span class="line">![image-20221026201351687](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262013789.png)</span><br><span class="line"></span><br><span class="line">![image-20221026202258814](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262022938.png)</span><br><span class="line"></span><br><span class="line">#### 最不常用算法（LFU）</span><br><span class="line"></span><br><span class="line">&gt; 思路：选择访问次数最少的页面</span><br><span class="line"></span><br><span class="line">![image-20221026202410800](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262024919.png)</span><br><span class="line"></span><br><span class="line">![image-20221026202548885](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262025948.png)</span><br><span class="line"></span><br><span class="line">#### Belady现象</span><br><span class="line"></span><br><span class="line">![image-20221026202918485](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262029595.png)</span><br><span class="line"></span><br><span class="line">![image-20221026203200127](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262032255.png)</span><br><span class="line"></span><br><span class="line">![image-20221026203310691](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262033818.png)</span><br><span class="line"></span><br><span class="line">![image-20221026203420381](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262034483.png)</span><br><span class="line"></span><br><span class="line">- LRU满足栈算法</span><br><span class="line">- FIFO不满足栈算法</span><br><span class="line"></span><br><span class="line">#### LRU、FIFO、Clock的比较</span><br><span class="line"></span><br><span class="line">![image-20221026203539653](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262035833.png)</span><br><span class="line"></span><br><span class="line">![image-20221026203815501](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262038624.png)</span><br><span class="line"></span><br><span class="line">Clock和LRU如果不具备局部性，会退化为FIFO</span><br><span class="line"></span><br><span class="line">### 3、全局页面置换算法</span><br><span class="line"></span><br><span class="line">#### 局部页替换算法的问题</span><br><span class="line"></span><br><span class="line">![image-20221026203937206](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262039313.png)</span><br><span class="line"></span><br><span class="line">- 固定分配的页帧大小没有考虑实际的动态变化，可能会发生较多缺失，能不能动态地分配页帧大小？</span><br><span class="line"></span><br><span class="line">#### 工作集模式</span><br><span class="line"></span><br><span class="line">![image-20221026204100955](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262041114.png)</span><br><span class="line"></span><br><span class="line">![image-20221026204303245](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262043366.png)</span><br><span class="line"></span><br><span class="line">![image-20221026204515932](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262045042.png)</span><br><span class="line"></span><br><span class="line">![image-20221026204614633](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262046727.png)</span><br><span class="line"></span><br><span class="line">![image-20221026204658421](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262046569.png)</span><br><span class="line"></span><br><span class="line">#### 工作集页置换算法</span><br><span class="line"></span><br><span class="line">![image-20221026205054584](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262050687.png)</span><br><span class="line"></span><br><span class="line">![image-20221026205539898](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262055025.png)</span><br><span class="line"></span><br><span class="line">如果数据的时间大于工作集大小，即使空间还有，也会换出。</span><br><span class="line"></span><br><span class="line">#### 缺页率置换算法</span><br><span class="line"></span><br><span class="line">![image-20221026205626748](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262056906.png)</span><br><span class="line"></span><br><span class="line">![image-20221026205706623](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262057721.png)</span><br><span class="line"></span><br><span class="line">![image-20221026205747759](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262057843.png)</span><br><span class="line"></span><br><span class="line">![image-20221026205843873](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262058975.png)</span><br><span class="line"></span><br><span class="line">![image-20221026210411888](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262104019.png)</span><br><span class="line"></span><br><span class="line">时刻4时，两次中断的时间大于预定时间T，认为跑的比较好，减少工作集，把1-4访问的页继续留在这，其他的页移除。</span><br><span class="line"></span><br><span class="line">#### 抖动问题</span><br><span class="line"></span><br><span class="line">![image-20221026210658924](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262106107.png)</span><br><span class="line"></span><br><span class="line">![image-20221026211027063](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210262110155.png)</span><br><span class="line"></span><br><span class="line">## 七、进程管理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 1、进程(process)描述</span><br><span class="line"></span><br><span class="line">#### 进程的定义</span><br><span class="line"></span><br><span class="line">**进程：**一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。</span><br><span class="line"></span><br><span class="line">![image-20221028191536744](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210281915900.png)</span><br><span class="line"></span><br><span class="line">#### 进程的组成</span><br><span class="line"></span><br><span class="line">![image-20221031163515491](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210311635633.png)</span><br><span class="line"></span><br><span class="line">![image-20221031163602283](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210311636358.png)</span><br><span class="line"></span><br><span class="line">进程不等于程序，进程是cpu的依次执行过程，程序只是静态的代码。</span><br><span class="line"></span><br><span class="line">![ ](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312249680.png)</span><br><span class="line"></span><br><span class="line">![image-20221031225136685](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312251791.png)</span><br><span class="line"></span><br><span class="line">#### 进程的特点</span><br><span class="line"></span><br><span class="line">&gt; 并发，一段时间内多个进程同时执行</span><br><span class="line">&gt;</span><br><span class="line">&gt; 并行，一个时刻多个进程同时执行</span><br><span class="line"></span><br><span class="line">![image-20221031225850239](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312258326.png)</span><br><span class="line"></span><br><span class="line">如何设计一个OS来保证以上特点？</span><br><span class="line"></span><br><span class="line">![image-20221031230021117](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312300208.png)</span><br><span class="line"></span><br><span class="line">通过进程控制块来保证进程的特点。</span><br><span class="line"></span><br><span class="line">#### 进程控制结构</span><br><span class="line"></span><br><span class="line">![image-20221031231749475](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312317566.png)</span><br><span class="line"></span><br><span class="line">![image-20221031231826227](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312318331.png)</span><br><span class="line"></span><br><span class="line">![image-20221031231912491](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312319603.png)</span><br><span class="line"></span><br><span class="line">![image-20221031232033815](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312320922.png)</span><br><span class="line"></span><br><span class="line">![image-20221031232310314](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312323409.png)</span><br><span class="line"></span><br><span class="line">### 2、进程状态(State)</span><br><span class="line"></span><br><span class="line">#### 进程的生命周期</span><br><span class="line"></span><br><span class="line">1. 进程创建</span><br><span class="line"></span><br><span class="line">   ![image-20221031232557255](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312325340.png)</span><br><span class="line"></span><br><span class="line">2. 进程运行</span><br><span class="line"></span><br><span class="line">   ![image-20221031232657201](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312326280.png)</span><br><span class="line"></span><br><span class="line">3. 进程等待</span><br><span class="line"></span><br><span class="line">   ![image-20221031232730351](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312327433.png)</span><br><span class="line"></span><br><span class="line">4. 进程唤醒</span><br><span class="line"></span><br><span class="line">   ![image-20221031232852501](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312328585.png)</span><br><span class="line"></span><br><span class="line">5. 进程结束</span><br><span class="line"></span><br><span class="line">   ![image-20221031232928822](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312329921.png)</span><br><span class="line"></span><br><span class="line">#### 进程的状态变化</span><br><span class="line"></span><br><span class="line">![image-20221031233057933](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312330026.png)</span><br><span class="line"></span><br><span class="line">![image-20221031233140734](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312331823.png)</span><br><span class="line"></span><br><span class="line">![image-20221031233207784](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312332877.png)</span><br><span class="line"></span><br><span class="line">![image-20221031233414083](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312334156.png)</span><br><span class="line"></span><br><span class="line">![image-20221031233525168](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312335248.png)</span><br><span class="line"></span><br><span class="line">![image-20221031233601720](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312336793.png)</span><br><span class="line"></span><br><span class="line">#### 进程挂起模型</span><br><span class="line"></span><br><span class="line">![image-20221031233731185](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312337280.png)</span><br><span class="line"></span><br><span class="line">![image-20221031234050492](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312340601.png)</span><br><span class="line"></span><br><span class="line">![image-20221031234142922](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312341015.png)</span><br><span class="line"></span><br><span class="line">&gt; OS如何管理PCD?</span><br><span class="line"></span><br><span class="line">![image-20221031234233017](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312342090.png)</span><br><span class="line"></span><br><span class="line">![image-20221031234319915](https://gitee.com/messi-study-java/pic_go/raw/master/img/202210312343000.png)</span><br><span class="line"></span><br><span class="line">### 3、线程(Thread)</span><br><span class="line"></span><br><span class="line">#### 线程的来源</span><br><span class="line"></span><br><span class="line">![image-20221104192636095](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211041927546.png)</span><br><span class="line"></span><br><span class="line">![image-20221104192758934](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211041928477.png)</span><br><span class="line"></span><br><span class="line">![image-20221104193022595](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211041930805.png)</span><br><span class="line"></span><br><span class="line">如何解决以上问题？</span><br><span class="line"></span><br><span class="line">需要一种新的实体（线程），满足以下特性：</span><br><span class="line"></span><br><span class="line">1. 实体之间可以并发的执行。</span><br><span class="line">2. 实体之间共享相同的地址空间。（进程是独立的地址空间）</span><br><span class="line"></span><br><span class="line">#### 什么是线程</span><br><span class="line"></span><br><span class="line">![image-20221104193428409](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211041934423.png)</span><br><span class="line"></span><br><span class="line">**线程成为进程的重要组成部分。**</span><br><span class="line"></span><br><span class="line">一个进程可以有多个线程，线程之间共享进程的资源，直接访问进程的代码、数据、空间、文件等。</span><br><span class="line"></span><br><span class="line">![image-20221104193820117](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211041938411.png)</span><br><span class="line"></span><br><span class="line">![image-20221104194344117](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211041943117.png)</span><br><span class="line"></span><br><span class="line">![image-20221104194448694](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211041944162.png)</span><br><span class="line"></span><br><span class="line">#### 线程与进程的比较</span><br><span class="line"></span><br><span class="line">- 进程是资源分配的单位，线程是CPU调度单位。</span><br><span class="line"></span><br><span class="line">  &gt; CPU是一种特殊的资源，会给线程分配所需要的寄存器和栈。</span><br><span class="line"></span><br><span class="line">- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈。</span><br><span class="line"></span><br><span class="line">- 线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系。</span><br><span class="line"></span><br><span class="line">- 线程能减少并发执行的时间和空间开销。</span><br><span class="line"></span><br><span class="line">  - 线程的创建时间比进程段；</span><br><span class="line">  - 线程的终止时间比进程短；</span><br><span class="line">  - 同一进程内的线程切换时间比进程短；</span><br><span class="line">  - 由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信。</span><br><span class="line"></span><br><span class="line">#### 线程的实现</span><br><span class="line"></span><br><span class="line">主要的三种线程的实现方式：</span><br><span class="line"></span><br><span class="line">1. 用户线程：在用户空间实现`POSIX Pthreads`,`Mach C-threads`，`Solaris threads`</span><br><span class="line">2. 内核线程：在内核中实现`Windows`,`Solaris`,`Linux`</span><br><span class="line">3. 轻量级进程：在内核中实现，支持用户线程`Solaris`</span><br><span class="line"></span><br><span class="line">用户线程和内核线程的关系：</span><br><span class="line"></span><br><span class="line">- 多对一</span><br><span class="line">- 一对一</span><br><span class="line">- 多对多</span><br><span class="line"></span><br><span class="line">![image-20221104202842607](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211042028802.png)</span><br><span class="line"></span><br><span class="line">![image-20221104202904428](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211042029726.png)</span><br><span class="line"></span><br><span class="line">![image-20221104203207570](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211042032135.png)</span><br><span class="line"></span><br><span class="line">![image-20221104203244373](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211042032847.png)</span><br><span class="line"></span><br><span class="line">![image-20221104203541357](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211042035853.png)</span><br><span class="line"></span><br><span class="line">### 4、上下文切换</span><br><span class="line"></span><br><span class="line">![image-20221104203632771](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211042036676.png)</span><br><span class="line"></span><br><span class="line">![image-20221104203950516](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211042039221.png)</span><br><span class="line"></span><br><span class="line">![image-20221104204600381](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211042046492.png)</span><br><span class="line"></span><br><span class="line">### 5、进程控制</span><br><span class="line"></span><br><span class="line">#### 加载执行进程</span><br><span class="line"></span><br><span class="line">![image-20221104204728497](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211042047592.png)</span><br><span class="line"></span><br><span class="line">![image-20221104205018688](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211042050789.png)</span><br><span class="line"></span><br><span class="line">![image-20221104205229519](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211042052610.png)</span><br><span class="line"></span><br><span class="line">![image-20221104205306761](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211042053855.png)</span><br><span class="line"></span><br><span class="line">#### 等待和终止进程</span><br><span class="line"></span><br><span class="line">![image-20221104205727684](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211042057809.png)</span><br><span class="line"></span><br><span class="line">父进程要等待子进程的exit()，后来回收进程控制块PCB，这一块开销，子进程自己释放不掉。</span><br><span class="line"></span><br><span class="line">![image-20221104210247662](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211042102757.png)</span><br><span class="line"></span><br><span class="line">还有一种情况，子进程执行exit()后，父进程还没来得及释放子进程的PCB，这个时候子进程处于僵尸态。(zombie)</span><br><span class="line"></span><br><span class="line">如果父进程已经死了，子进程的PCB还没来得及释放，处于僵尸态。操作系统会扫描根进程来释放僵尸态的进程，清理空间。</span><br><span class="line"></span><br><span class="line">![image-20221104210710818](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211042107922.png)</span><br><span class="line"></span><br><span class="line">执行exec()系统可以处于不同状态。</span><br><span class="line"></span><br><span class="line">- 被调度</span><br><span class="line">- 被阻塞</span><br><span class="line"></span><br><span class="line">## 八、调度</span><br><span class="line"></span><br><span class="line">### 1、背景</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171317139.png&quot; alt=&quot;image-20221117131753050&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">![image-20221117131903172](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171319253.png)</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171320607.png&quot; alt=&quot;image-20221117132008510&quot; style=&quot;zoom:80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">**CPU调度方式**</span><br><span class="line"></span><br><span class="line">(1)不可抢占</span><br><span class="line"></span><br><span class="line">调度程序必须等待事件结束(效率低，不采用)；</span><br><span class="line"></span><br><span class="line">(2)可以抢占</span><br><span class="line"></span><br><span class="line">- 调度程序在中断被响应后执行；</span><br><span class="line">- 当前的进程从运行切换到就绪，或者一个进程从等待切换到就绪；</span><br><span class="line">- 当前运行的进程可以被换出。</span><br><span class="line"></span><br><span class="line">注意，以上一般指用户态；内核态也可能涉及到是否抢占。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">现在操作系统常用的就是抢占式的调度策略。</span><br><span class="line"></span><br><span class="line">### 2、调度原则</span><br><span class="line"></span><br><span class="line">![image-20221117161918259](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171619394.png)</span><br><span class="line"></span><br><span class="line">#### 评价指标</span><br><span class="line"></span><br><span class="line">![image-20221117161935593](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171619680.png)</span><br><span class="line"></span><br><span class="line">![image-20221117162309343](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171623440.png)</span><br><span class="line"></span><br><span class="line">#### 理想的调度原则</span><br><span class="line"></span><br><span class="line">![image-20221117162517231](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171625329.png)</span><br><span class="line"></span><br><span class="line">![image-20221117162602080](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171626155.png)</span><br><span class="line"></span><br><span class="line">#### 调度公平性</span><br><span class="line"></span><br><span class="line">![image-20221117162715043](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171627116.png)</span><br><span class="line"></span><br><span class="line">### 3、调度算法</span><br><span class="line"></span><br><span class="line">![image-20221117162827019](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171628102.png)</span><br><span class="line"></span><br><span class="line">#### 先来先服务</span><br><span class="line"></span><br><span class="line">![image-20221117162939645](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171629729.png)</span><br><span class="line"></span><br><span class="line">![image-20221117163158967](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171631052.png)</span><br><span class="line"></span><br><span class="line">![image-20221117163301181](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171633276.png)</span><br><span class="line"></span><br><span class="line">![image-20221117163433581](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171634675.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>相当于P4和P5各少等一个P3的执行时间，但是P3要多等一个P4+P5的执行时间，总的算下来还是亏了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">优点：平均等待时间最短</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line">![image-20221117163741644](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171637733.png)</span><br><span class="line"></span><br><span class="line">预估程序的执行时间（通过当前时间，预估未来的执行时间，类似TCP rtt）</span><br><span class="line"></span><br><span class="line">![image-20221117163951772](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171639859.png)</span><br><span class="line"></span><br><span class="line">#### 最高响应比优先</span><br><span class="line"></span><br><span class="line">![image-20221117164131232](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171641316.png)</span><br><span class="line"></span><br><span class="line">R越大，等待的占比越高，越需要优先相应。</span><br><span class="line"></span><br><span class="line">缺点：要不要考虑抢占问题</span><br><span class="line"></span><br><span class="line">优点：饥饿问题得到有效缓解。</span><br><span class="line"></span><br><span class="line">#### 轮询</span><br><span class="line"></span><br><span class="line">![image-20221117164737470](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171647555.png)</span><br><span class="line"></span><br><span class="line">![image-20221117164758981](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171647069.png)</span><br><span class="line"></span><br><span class="line">设定一个固定的时间片，达到时间片就把CPU让出来。</span><br><span class="line"></span><br><span class="line">每一个进程都有机会被执行。（公平）</span><br><span class="line"></span><br><span class="line">通过等待时间来衡量轮询调度算法效率。</span><br><span class="line"></span><br><span class="line">![image-20221117164956958](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171649040.png)</span><br><span class="line"></span><br><span class="line">时间片的选择尤为重要。</span><br><span class="line"></span><br><span class="line">![image-20221117165118170](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171651274.png)</span><br><span class="line"></span><br><span class="line">#### 多级反馈队列</span><br><span class="line"></span><br><span class="line">![image-20221117165308096](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171653183.png)</span><br><span class="line"></span><br><span class="line">![image-20221117165356096](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171653187.png)</span><br><span class="line"></span><br><span class="line">根据优先级来进行调度</span><br><span class="line"></span><br><span class="line">&gt; 更正：时间量子大小随优先级增加级别降低</span><br><span class="line"></span><br><span class="line">#### 公平共享</span><br><span class="line"></span><br><span class="line">![image-20221117165710833](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171657927.png)</span><br><span class="line"></span><br><span class="line">#### 如何评价</span><br><span class="line"></span><br><span class="line">![image-20221117165839658](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171658746.png)</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line"></span><br><span class="line">![image-20221117165936369](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171659439.png)</span><br><span class="line"></span><br><span class="line">### 4、实时调度</span><br><span class="line"></span><br><span class="line">#### 实时系统</span><br><span class="line"></span><br><span class="line">![image-20221117170145971](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171701049.png)</span><br><span class="line"></span><br><span class="line">#### 实时系统的分类</span><br><span class="line"></span><br><span class="line">![image-20221117170233321](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171702398.png)</span><br><span class="line"></span><br><span class="line">#### 实时调度的描述</span><br><span class="line"></span><br><span class="line">![image-20221117170332299](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171703382.png)</span><br><span class="line"></span><br><span class="line">![image-20221117170431859](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171704945.png)</span><br><span class="line"></span><br><span class="line">![image-20221117170510147](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171705236.png)</span><br><span class="line"></span><br><span class="line">![image-20221117170545971](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171705050.png)</span><br><span class="line"></span><br><span class="line">静态优先级调度：任务开始之前已经定义好了优先级。</span><br><span class="line"></span><br><span class="line">动态优先级调度：任务开始后，根据任务的运行情况，定义优先级。</span><br><span class="line"></span><br><span class="line">![image-20221117170652159](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171706243.png)</span><br><span class="line"></span><br><span class="line">### 5、多处理器调度</span><br><span class="line"></span><br><span class="line">![image-20221117170841772](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171708865.png)</span><br><span class="line"></span><br><span class="line">针对多处理器系统，能否达到负载均衡。</span><br><span class="line"></span><br><span class="line">### 6、优先级反转</span><br><span class="line"></span><br><span class="line">![image-20221117171118959](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171711099.png)</span><br><span class="line"></span><br><span class="line">![image-20221117171300574](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171713649.png)</span><br><span class="line"></span><br><span class="line">问题：优先级：T1&gt;T2&gt;T3；T1和T3共享某一块资源，而正被T3占用，T1等待，T2抢占T3，于是T3等待，进而导致T1等待，而T1优先级高于T3，产生矛盾，称为优先级反转。</span><br><span class="line"></span><br><span class="line">![image-20221117171508686](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171715763.png)</span><br><span class="line"></span><br><span class="line">解决方法：优先级继承</span><br><span class="line"></span><br><span class="line">当T3拿了T1的贡献资源时，让T3的优先级=T1优先级，先执行完T3，就可以接着执行T1了，而且不会被T2打断。</span><br><span class="line"></span><br><span class="line">![image-20221117171708021](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171717098.png)</span><br><span class="line"></span><br><span class="line">## 九、同步</span><br><span class="line"></span><br><span class="line">### 1、背景</span><br><span class="line"></span><br><span class="line">![image-20221119201800034](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192018022.png)</span><br><span class="line"></span><br><span class="line">&gt; 独立的线程：</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 不和其他线程共享资源或状态</span><br><span class="line">&gt; - 确定性：输入状态决定结果</span><br><span class="line">&gt; - 可重现：能够重现起始条件I/O</span><br><span class="line">&gt; - 调度顺序不重要</span><br><span class="line">&gt;</span><br><span class="line">&gt; 合作线程：</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 在多个线程中共享状态</span><br><span class="line">&gt; - 不确定性</span><br><span class="line">&gt; - 不可重现</span><br><span class="line">&gt;</span><br><span class="line">&gt; 不确定性和不可重现意味着bug可能是间歇性发生的。</span><br><span class="line"></span><br><span class="line">合作的优点：</span><br><span class="line"></span><br><span class="line">1. 共享资源</span><br><span class="line">2. 加速</span><br><span class="line">3. 模块化</span><br><span class="line"></span><br><span class="line">![image-20221119202302449](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192023554.png)</span><br><span class="line"></span><br><span class="line">![image-20221119202433106](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192024235.png)</span><br><span class="line"></span><br><span class="line">next_pid系统当前最高的进程id号</span><br><span class="line"></span><br><span class="line">![image-20221119202811321](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192028424.png)</span><br><span class="line"></span><br><span class="line">&gt; 在切换到进程2时，会保存进程1的状态值，所以在切回来时，reg1 = 1</span><br><span class="line"></span><br><span class="line">![image-20221119203053757](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192030861.png)</span><br><span class="line"></span><br><span class="line">### 2、一些概念</span><br><span class="line"></span><br><span class="line">#### 竞态条件</span><br><span class="line"></span><br><span class="line">![image-20221119203254209](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192032302.png)</span><br><span class="line"></span><br><span class="line">#### 原子操作</span><br><span class="line"></span><br><span class="line">![image-20221119203325393](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192033523.png)</span><br><span class="line"></span><br><span class="line">![image-20221119203640782](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192036893.png) </span><br><span class="line"></span><br><span class="line">#### 一些概念</span><br><span class="line"></span><br><span class="line"> ![image-20221119204019305](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192040419.png)</span><br><span class="line"></span><br><span class="line">#### 举例</span><br><span class="line"></span><br><span class="line">![image-20221119204455657](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192044785.png)</span><br><span class="line"></span><br><span class="line">![image-20221119204637236](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192046358.png)</span><br><span class="line"></span><br><span class="line">![image-20221119204827809](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192048908.png)</span><br><span class="line"></span><br><span class="line">![image-20221119205101608](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192051717.png)</span><br><span class="line"></span><br><span class="line">![image-20221119205201899](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192052003.png)</span><br><span class="line"></span><br><span class="line">![image-20221119205327759](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192053889.png)</span><br><span class="line"></span><br><span class="line">![image-20221119205609145](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192056245.png)</span><br><span class="line"></span><br><span class="line">![image-20221119205656972](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192056089.png)</span><br><span class="line"></span><br><span class="line">可以解决购买面包的情况。</span><br><span class="line"></span><br><span class="line">![image-20221119205938148](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192059252.png)</span><br><span class="line"></span><br><span class="line">![image-20221119210332907](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192104204.png)</span><br><span class="line"></span><br><span class="line">### 3、临界区</span><br><span class="line"></span><br><span class="line">  ![](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192104103.png)</span><br><span class="line"></span><br><span class="line">### 方法一：禁用硬件中断</span><br><span class="line"></span><br><span class="line">![image-20221119210623922](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192106028.png)</span><br><span class="line"></span><br><span class="line">- 进入临界区：**屏蔽中断**</span><br><span class="line"></span><br><span class="line">- 出临界区：**开启中断**</span><br><span class="line"></span><br><span class="line">![image-20221119210747586](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192107696.png)</span><br><span class="line"></span><br><span class="line">多CPU屏蔽一个中断，无法解决互斥问题。而且屏蔽中断的话，有其他请求就要等待，影响速度。</span><br><span class="line"></span><br><span class="line">### 方法二：基于软件的解决方法</span><br><span class="line"></span><br><span class="line">![image-20221119211028598](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192110670.png)</span><br><span class="line"></span><br><span class="line">![image-20221119211126722](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192111800.png)</span><br><span class="line"></span><br><span class="line">![image-20221119211913913](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192119000.png)</span><br><span class="line"></span><br><span class="line">​                                                                        </span><br><span class="line"></span><br><span class="line">无法保证互斥，存在死锁。</span><br><span class="line"></span><br><span class="line">![image-20221119212056573](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192120672.png)</span><br><span class="line"></span><br><span class="line">![image-20221119212250411](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192122493.png)</span><br><span class="line"></span><br><span class="line">![image-20221119212907562](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192129641.png)</span><br><span class="line"></span><br><span class="line">针对N个进程实现互斥：</span><br><span class="line"></span><br><span class="line">![image-20221119212956649](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192129732.png)</span><br><span class="line"></span><br><span class="line">![image-20221119213030329](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192130418.png)</span><br><span class="line"></span><br><span class="line">![image-20221119213150737](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192131833.png)</span><br><span class="line"></span><br><span class="line">### 方法三：更高的抽象</span><br><span class="line"></span><br><span class="line">![image-20221119213254200](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192132295.png)</span><br><span class="line"></span><br><span class="line">![image-20221119213314802](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192133891.png)</span><br><span class="line"></span><br><span class="line">![image-20221119213354336](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192133611.png)</span><br><span class="line"></span><br><span class="line">![image-20221119213455651](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192134728.png)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">![image-20221119214007913](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192140003.png)</span><br><span class="line"></span><br><span class="line">如果锁被释放，返回值是0，设置target为1，跳出循环，进入等待区。</span><br><span class="line"></span><br><span class="line">如果锁没被释放，返回值是1，设置target为1，持续循环，忙等，等待释放锁。</span><br><span class="line"></span><br><span class="line">不管可以支持2线程，还可以支持n线程。</span><br><span class="line"></span><br><span class="line">![image-20221119214206586](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192142681.png)</span><br><span class="line"></span><br><span class="line">怎么样能不忙等？</span><br><span class="line"></span><br><span class="line">让他进行睡眠，释放资源。</span><br><span class="line"></span><br><span class="line">主要是看上下文切换的开销和忙等的开销。睡眠的话，唤醒时，会进行进程的上下文切换。</span><br><span class="line"></span><br><span class="line">![image-20221119214247477](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192142564.png)</span><br><span class="line"></span><br><span class="line">![image-20221119214441291](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192144370.png)</span><br><span class="line"></span><br><span class="line">如果锁被释放，lock是0，key为1，exchange, lock = 1，进入等待区。</span><br><span class="line"></span><br><span class="line">如果锁没被释放,lock是1，持续循环，忙等，等待释放锁lock = 0。</span><br><span class="line"></span><br><span class="line">![image-20221119214733923](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192147000.png)</span><br><span class="line"></span><br><span class="line">![image-20221119214749866](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211231916054.png)</span><br><span class="line"></span><br><span class="line">![image-20221119214851711](https://gitee.com/messi-study-java/pic_go/raw/master/img/202211192148796.png)</span><br><span class="line"></span><br><span class="line">**总结**：</span><br><span class="line"></span><br><span class="line">![image-20221209213233020](../images/操作系统/image-20221209213233020.png)</span><br><span class="line"></span><br><span class="line">![image-20221209213254629](../images/操作系统/image-20221209213254629.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 十、信号量和管程</span><br><span class="line"></span><br><span class="line">针对互斥的问题，采用更级的手段解决同步问题。</span><br><span class="line"></span><br><span class="line">### 1、信号量</span><br><span class="line"></span><br><span class="line">![image-20221209213853231](../images/操作系统/image-20221209213853231.png)</span><br><span class="line"></span><br><span class="line">![image-20221209213952479](../images/操作系统/image-20221209213952479.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2、信号量使用</span><br><span class="line"></span><br><span class="line">可以把信号量看成是现在所拥有的资源数。当有程序访问时，就占到了这个资源，信号量--。</span><br><span class="line"></span><br><span class="line">p操作就相当于程序占有资源，如果信号量&gt;0,就--表示使用。如果信号量&lt;=0 --就表示预约。</span><br><span class="line"></span><br><span class="line">v操作就相当于一个程序执行完后，释放资源。释放的资源可以给其他程序分配使用。如果此时信号量&lt;=0，说明有程序在排队等待，因此唤醒一个程序，把资源给他，让他运行。</span><br><span class="line"></span><br><span class="line">![image-20221209214137005](../images/操作系统/image-20221209214137005.png)</span><br><span class="line"></span><br><span class="line">![image-20221209215032607](../images/操作系统/image-20221209215032607.png)</span><br><span class="line"></span><br><span class="line">&gt; 二进制的信号量可以模拟 **锁机制** 的功能</span><br><span class="line"></span><br><span class="line">使用案例：</span><br><span class="line"></span><br><span class="line">二进制信号量的使用：</span><br><span class="line"></span><br><span class="line">![image-20221209215212293](../images/操作系统/image-20221209215212293.png)</span><br><span class="line"></span><br><span class="line">![image-20221209215252781](../images/操作系统/image-20221209215252781.png)</span><br><span class="line"></span><br><span class="line">a程序调用p操作，阻塞。等待b完成操作调用v，这个时候a才可以进行后半段的程序。</span><br><span class="line"></span><br><span class="line">二进制信号量解决一些简单的问题，遇到复杂的问题，需要用到计数信号量。</span><br><span class="line"></span><br><span class="line">![image-20221209215607297](../images/操作系统/image-20221209215607297.png)</span><br><span class="line"></span><br><span class="line">![image-20221209215824532](../images/操作系统/image-20221209215824532.png)</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">Class BoundedBuffer &#123;</span><br><span class="line">    mutex = new Semaphore(1); // 互斥锁</span><br><span class="line">    fullBuffers = new Semaphore(0); // 缓冲区buffer是，生产者生产，消费者消费，初始值0，表示没有消息</span><br><span class="line">    emptyBuffers = new Semaphore(n); // 生产者，初始化有n个生产者</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::Deposit(c)&#123; // 生产者的生产过程</span><br><span class="line">    emptyBuffers-&gt;P(); // 从生产者中拿到资源，也就是看生产的数量是不是已经够了</span><br><span class="line">    mutex-&gt;P(); // 拿互斥锁，同一时间，只能读 or 写</span><br><span class="line">    Add c to the buffer; // 写数据到 buffer</span><br><span class="line">    mutex-&gt;V(); // 释放锁</span><br><span class="line">    fullBuffers-&gt;V(); // 写完之后，也就是生产者生产完之后，消费者可以消费</span><br><span class="line">&#125;</span><br><span class="line">BoundedBuffer::Remove(c)&#123; // 消费者消费过程</span><br><span class="line">    fullBuffers-&gt;P(); // 先拿缓冲区数据，看是不是可以拿到消息</span><br><span class="line">	mutex-&gt;P(); // 拿互斥锁</span><br><span class="line">    Remove c from buffer; // 读数据</span><br><span class="line">    mutex-&gt;V(); // 释放锁</span><br><span class="line">    emptyBuffers-&gt;V(); // 读完之后，也就是消费者消费完消息之后，生产者可以继续消费</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>P、V操作的顺序有影响吗 ?</p>
<p>具体问题具体分析，可能会产生影响。如在生产者的生产过程中，如果是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mutex-&gt;<span class="built_in">P</span>(); <span class="comment">// 拿互斥锁，同一时间，只能读 or 写</span></span><br><span class="line">emptyBuffers-&gt;<span class="built_in">P</span>(); <span class="comment">// 从生产者中拿到资源，也就是看生产的数量是不是已经够了</span></span><br></pre></td></tr></table></figure>

<p>先拿互斥锁，如果此时生产者的数量已经是n个了，emptyBuffers 的信号量为0，生产者的p操作会阻塞主。</p>
<p>此时消费者再拿互斥锁的时候，拿不到，形成 <strong>死锁</strong>。</p>
<h3 id="3、信号量实现"><a href="#3、信号量实现" class="headerlink" title="3、信号量实现"></a>3、信号量实现</h3><p>信号量的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classSemaphore&#123;</span><br><span class="line">	<span class="type">int</span> sem; <span class="comment">// 信号量</span></span><br><span class="line">    WaitQueue q; <span class="comment">// 等待队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Semaphore::<span class="built_in">P</span>()&#123;</span><br><span class="line">    sem--; <span class="comment">// 信号量-- 拿资源</span></span><br><span class="line">    <span class="keyword">if</span> (sem &lt; <span class="number">0</span>) &#123; <span class="comment">// 资源被拿完了 排队等待（阻塞）</span></span><br><span class="line">        Add <span class="keyword">this</span> thread t to q;<span class="built_in">block</span>(p); <span class="comment">// 排队</span></span><br><span class="line">        <span class="built_in">block</span>(p); <span class="comment">// 阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Semaphore::<span class="built_in">V</span>() &#123;</span><br><span class="line">    sem++; <span class="comment">// 信号量++ 释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (sem&lt;=<span class="number">0</span>) &#123; <span class="comment">// 有程序等待（处于阻塞状态）</span></span><br><span class="line">        Remove a thread t from q; <span class="comment">// 出队</span></span><br><span class="line">        <span class="built_in">wakeup</span>(t); <span class="comment">// 唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>信号量的双用途<ul>
<li>互斥和条件同步</li>
<li>但等待条件是独立的互斥</li>
</ul>
</li>
<li>读&#x2F;开发代码比较困难<ul>
<li>程序员必须非常精通信号量</li>
</ul>
</li>
<li>容易出错<ul>
<li>使用的信号量已经被另一个线程占用</li>
<li>忘记释放信号量</li>
</ul>
</li>
<li>不能够处理死锁问题</li>
</ol>
<h3 id="4、管程"><a href="#4、管程" class="headerlink" title="4、管程"></a>4、管程</h3><p>最早是针对语言的并发问题来设计的。</p>
<p><strong>目的</strong>: 分离互斥和条件同步的关注</p>
<p><strong>什么是管程</strong>？</p>
<ul>
<li>一个锁: 指定临界区</li>
<li>0或者多个条件变量:等待&#x2F;通知信号量用于管理并发访问共享数据</li>
</ul>
<p><strong>一般方法</strong></p>
<ul>
<li>收集在对象&#x2F;模块中的相关共享数据</li>
<li>定义方法来访问共享数据</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221212142342550.png" alt="image-20221212142342550"></p>
<ul>
<li>Lock锁机制<ol>
<li>Lock::Acquire ()等待直到锁可用，然后抢占锁 </li>
<li>Lock::Release ()释放锁，唤醒等待者如果有</li>
</ol>
</li>
<li>Condition Variable条件变量<ul>
<li>允许等待状态进入临界区<ol>
<li>允许处于等待 (睡眠) 的线程进入临界区</li>
<li>某个时刻原子释放锁进入睡眠</li>
</ol>
</li>
<li>Wait () operation<ul>
<li>释放锁，睡眠，重新获得锁返回后</li>
</ul>
</li>
<li>Signal() operation (or broadcast() operation)<ul>
<li>唤醒等待者 (或者所有等待者)，如果有</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>实现</strong></p>
<ul>
<li>需要维持每个条件队列</li>
<li>线程等待的条件等待signal ()</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Class Condition &#123; <span class="comment">// 条件变量</span></span><br><span class="line">    <span class="type">int</span> numWaiting = <span class="number">0</span>; <span class="comment">// 等待的个数</span></span><br><span class="line">    WaitQueue q; <span class="comment">// 等待队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Condition::<span class="built_in">Wait</span>(lock) &#123; <span class="comment">// 等待操作</span></span><br><span class="line">    numWaiting++; <span class="comment">// 等待的个数++</span></span><br><span class="line">    Add <span class="keyword">this</span> thread t to q; <span class="comment">// 加入等待数组</span></span><br><span class="line">	<span class="built_in">release</span>(lock); <span class="comment">// 释放锁，释放锁是因为一开始就会获取锁，因为运行资源不够，需要做等待操作，所以先释放资源，让其他线程正常运行</span></span><br><span class="line">	<span class="built_in">schedule</span>(); <span class="comment">//need mutex</span></span><br><span class="line">	<span class="built_in">require</span>(lock); <span class="comment">// 获取锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Condition::<span class="built_in">Signal</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (numWaiting &gt; <span class="number">0</span>) &#123; <span class="comment">// 有等待的情况</span></span><br><span class="line">        !Remove a thread t from q;</span><br><span class="line">        <span class="built_in">wakeup</span>(t); <span class="comment">//need mutex 唤醒</span></span><br><span class="line">        numWaiting-;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者、消费者模型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**管程的定义</span></span><br><span class="line"><span class="comment">* 一个锁：表示只有一个线程</span></span><br><span class="line"><span class="comment">* 若干个条件变量：表示情况</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">classBoundedBuffer &#123;</span><br><span class="line">    Lock lock:</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>:</span><br><span class="line">	Condition notFull, notEmpty:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::<span class="built_in">Deposit</span>(c) &#123; <span class="comment">// 生产者生产</span></span><br><span class="line">    lock-&gt;<span class="built_in">Acquire</span>(); <span class="comment">// 获取锁 </span></span><br><span class="line">	<span class="keyword">while</span> (count == n) &#123; <span class="comment">// 生产者的个数过多</span></span><br><span class="line">        notFull.<span class="built_in">Wait</span>(&amp;lock); <span class="comment">// 等待</span></span><br><span class="line">        Add c to the buffer;</span><br><span class="line">        count++;</span><br><span class="line">        notEmpty.<span class="built_in">Signal</span>(); <span class="comment">// 消费者开始消费</span></span><br><span class="line">        lock-&gt;<span class="built_in">Release</span>(): <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::<span class="built_in">Remove</span>(c) &#123; <span class="comment">// 消费者消费</span></span><br><span class="line">    lock-&gt;Acquire0);</span><br><span class="line">    <span class="keyword">while</span> (count == <span class="number">0</span>)  <span class="comment">// 没有东西可以消费</span></span><br><span class="line">        notEmpty.<span class="built_in">Wait</span>(&amp;lock); <span class="comment">// 等待</span></span><br><span class="line">    Remove c from buffer;</span><br><span class="line">    count--;</span><br><span class="line">    notFull.<span class="built_in">Signal</span>(); <span class="comment">// 生产者生产</span></span><br><span class="line">    lock-&gt;<span class="built_in">Release</span>(); <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唤醒后该不该继续执行该线程？</p>
<p>两种方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221212151358276.png" alt="image-20221212151358276"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221212151336604.png" alt="image-20221212151336604"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221212144539037.png" alt="image-20221212144539037"></p>
<ul>
<li>开发&#x2F;调试并行程序很难<ul>
<li>非确定性的交叉指令</li>
</ul>
</li>
<li>同步结构<ul>
<li>锁: 互斥</li>
<li>条件变量: 有条件的同步</li>
<li>其他原语: 信号量</li>
<li>怎样有效的使用这些结构?<ul>
<li>制定并遵循严格的程序设计风格&#x2F;策略</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5、经典同步问题"><a href="#5、经典同步问题" class="headerlink" title="5、经典同步问题"></a>5、经典同步问题</h3><h4 id="读写者问题"><a href="#读写者问题" class="headerlink" title="读写者问题"></a>读写者问题</h4><p><strong>动机</strong>：共享数据的访问</p>
<p>两种类型使用者：</p>
<ul>
<li>读者:不需要修改数据</li>
<li>写者: 读取和修改数据</li>
</ul>
<p>问题的约束：</p>
<ul>
<li>允许同一时间有多个读者，但在任何时候只有一个写者</li>
<li>当没有写者是读者才能访问数据</li>
<li>当没有读者和写者时写者才能访问数据</li>
<li>在任何时候只能有一个线程可以操作共享变量</li>
</ul>
<p>多个并发进程的数据集共享</p>
<ul>
<li>读者 - 只读数据集;他们不执行任何更新</li>
<li>写者 - 可以读取和写入</li>
</ul>
<p><strong>共享数据</strong></p>
<ul>
<li>数据集</li>
<li>信号量CountMutex初始化为1，对Rcount的互斥</li>
<li>信号量WriteMutex初始化为1，对写者的互斥</li>
<li>整数 Rcount 初始化为0，表示读者</li>
</ul>
<p><code>信号量</code>实现</p>
<p>读者优先</p>
<p>写者</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sem <span class="title">wait</span><span class="params">( WriteMutex)</span>: // p()操作，获取锁</span></span><br><span class="line"><span class="function">write // 写</span></span><br><span class="line"><span class="function">sem post( WriteMutex): // v()操作，释放锁</span></span><br></pre></td></tr></table></figure>

<p>读者</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sem <span class="title">wait</span><span class="params">(CountMutex)</span></span>; <span class="comment">// 防止同时多个读者进入， p() 获取锁</span></span><br><span class="line"><span class="keyword">if</span>(Rcount == <span class="number">0</span>) <span class="comment">// 没有读者</span></span><br><span class="line">	<span class="function">sem <span class="title">wait</span> <span class="params">(WriteMutex)</span></span>; <span class="comment">// 获取锁，可能存在写者</span></span><br><span class="line">++Rcount; <span class="comment">// 读者++</span></span><br><span class="line"><span class="function">sem <span class="title">post</span><span class="params">(CountMutex)</span>: // v() 对rcount操作完成，释放锁，让其他读者进入</span></span><br><span class="line"><span class="function">read;</span></span><br><span class="line"><span class="comment">// 读完了</span></span><br><span class="line"><span class="function">sem <span class="title">wait</span><span class="params">(CountMutex)</span>:</span></span><br><span class="line"><span class="function">--Rcount;</span></span><br><span class="line"><span class="keyword">if</span>(Rcount == <span class="number">0</span>) <span class="comment">// 没有读者了</span></span><br><span class="line"><span class="function">sem <span class="title">post</span> <span class="params">(WriteMutex)</span></span>; <span class="comment">// 释放写锁，让可能有的写者能进行写操作</span></span><br><span class="line"><span class="function">sem <span class="title">post</span><span class="params">(CountMutex)</span></span>; <span class="comment">// 释放rcount的锁</span></span><br></pre></td></tr></table></figure>

<p>基于读者优先策略的方法，只要有一个读者处于活动状态，后来的读者都会被接纳。如果读者源源不断地出现的话，那么写者就始终处于阻塞状态</p>
<p>基于写者优先策略的方法: 一旦写者就绪，那么写者会尽可能快地执行写操作。如果写者源源不断地出现的话，那么读者就始终处于阻塞状态。(如何实现 ? )</p>
<p><code>管程</code>实现</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221212160707590.png" alt="image-20221212160707590"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管程的定义</span></span><br><span class="line">AR = <span class="number">0</span>; <span class="comment">// # of active writers 正在读的读者</span></span><br><span class="line">AW = <span class="number">0</span>; <span class="comment">// # of waiting readers 正在写的写者</span></span><br><span class="line">WR = <span class="number">0</span>; <span class="comment">// # of waiting readers 等待的读者</span></span><br><span class="line">WW = <span class="number">0</span>: <span class="comment">// # of waiting writers 等待的写者</span></span><br><span class="line"></span><br><span class="line">Condition okToRead;Condition okToWrite; <span class="comment">// 两个情况</span></span><br><span class="line">Lock lock; <span class="comment">// 一个锁</span></span><br></pre></td></tr></table></figure>

<p>读者</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Public <span class="title">Database::Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Wait until no writers;</span></span><br><span class="line">    <span class="built_in">StartRead</span>();</span><br><span class="line">    read database;</span><br><span class="line">    <span class="comment">//check out - wake upwaiting writers;</span></span><br><span class="line">    <span class="built_in">DoneRead</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Private <span class="title">Database::StartRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.<span class="built_in">Acquire</span>(); <span class="comment">// 获取锁，一个管程只能有一个线程</span></span><br><span class="line">	<span class="keyword">while</span> ((AW+WW)&gt; <span class="number">0</span>) &#123; <span class="comment">// 有写者</span></span><br><span class="line">        WR++; <span class="comment">// 等待</span></span><br><span class="line">        okToRead.<span class="built_in">wait</span>(&amp;lock); </span><br><span class="line">		WR--;</span><br><span class="line">    &#125;</span><br><span class="line">    AR++; <span class="comment">// 正在读的读者++</span></span><br><span class="line">    lock. <span class="built_in">Release</span>(); <span class="comment">// 释放管程的锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Private <span class="title">Database::DoneRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.<span class="built_in">Acquire</span>();</span><br><span class="line">	AR-; <span class="comment">// 正在读的读者--</span></span><br><span class="line">    <span class="keyword">if</span>(AR==<span class="number">0</span> &amp;&amp; WW&gt;<span class="number">0</span>) <span class="comment">// 已经没有读者，并且有等待的写者，唤醒</span></span><br><span class="line">        okToWrite.<span class="built_in">signal</span>();</span><br><span class="line">	lock. <span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写者</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Public <span class="title">Database::Write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Wait until no readers/writers;</span></span><br><span class="line">    <span class="function">Start <span class="title">Write</span><span class="params">()</span></span>;</span><br><span class="line">    write database;</span><br><span class="line">	<span class="comment">//check out - wake up waitingreaders/writers;</span></span><br><span class="line">    <span class="built_in">DoneWrite</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Private <span class="title">Database::StartWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.<span class="built_in">Acquire</span>();</span><br><span class="line">    <span class="keyword">while</span> ((AW+AR)&gt; <span class="number">0</span>) &#123; <span class="comment">// 有正在运行的读者 or 写者</span></span><br><span class="line">        WW++; <span class="comment">// 等待</span></span><br><span class="line">        okToWrite.<span class="built_in">wait</span>(&amp;lock);</span><br><span class="line">        WW-；</span><br><span class="line">    &#125;</span><br><span class="line">    AW++;</span><br><span class="line">    lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Private <span class="title">Database::DoneWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.<span class="built_in">Acquire</span>();</span><br><span class="line">    AW--;</span><br><span class="line">	<span class="keyword">if</span>(ww&gt; <span class="number">0</span>) <span class="comment">// 有等待的写者</span></span><br><span class="line">        fokToWrite.<span class="built_in">signal</span>(); <span class="comment">// 唤醒等待的写者</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(WR &gt; <span class="number">0</span>) <span class="comment">// 有等待的读者</span></span><br><span class="line">        okToRead.<span class="built_in">broadcast</span>(); <span class="comment">// 唤醒等待的读者</span></span><br><span class="line">	lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221212163821225.png" alt="image-20221212163821225"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221212164149047.png" alt="image-20221212164149047"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221212164355712.png" alt="image-20221212164355712"></p>
<p>等待时间确定的话，就存在问题，可能会同时拿上，同时放下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221212164631289.png" alt="image-20221212164631289"></p>
<p>可行，不够完美。不能应对饥饿问题。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221212164814199.png" alt="image-20221212164814199"></p>
<p>信号量，同步互斥。</p>
<p>方案4的缺点：</p>
<p>它把就餐 (而不是又子) 看成是必须互斥访问的临界资源，因此会造成(又子) 资源的浪费。</p>
<p>从理论上说，如果有五把叉子，应允许两个不相邻的哲学家同时进餐。</p>
<p>思路(1)哲学家自己怎么来解决这个问题 ?<br>指导原则: 要么不拿，要么就拿两把叉子。<br>S1 思考中…<br>S2 进入饥饿状态<br>S3 如果左邻居或右邻居正在进餐，等待: 否则转S4<br>S4 拿起两把叉子<br>S5 吃面条…<br>S6 放下左边的叉子:<br>S7 放下右边的叉子:<br>S8 新的循环又开始了，转S1</p>
<p>思路(2) 计算机程序怎么来解决这个问题 ?<br>指导原则: 不能浪费CPU时间;进程间相互通信<br>S1 思考中…<br>S2 进入饥饿状态<br>S3 如果左邻居或右邻居正在进餐，进程进入阻塞态,否则转S4<br>S4 拿起两把叉子;S4<br>S5 吃面条<br>S6 放下左边的叉子，看看左邻居现在能否进餐(饥饿状态、两把叉子都在)，若能则唤醒<br>S7 放下右边的又子，看看右邻居现在能否进餐(饥饿状态、两把叉子都在)，若能则唤醒<br>S8 新的一天又开始了，转S1</p>
<p>思路(3) 怎么样来编写程序 ?<br>1.必须有数据结构，来描述每个哲学家的当前状态<br>2.该状态是一个临界资源，各个哲学家对它的访问应该互斥地进行一进程互斥<br>3.一个哲学家吃饱后，可能要唤醒它的左邻右舍，两者之间存在着同步关系一一进程同步:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221212165715752.png" alt="image-20221212165715752"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221212171659903.png" alt="image-20221212171659903"></p>
<p>eat不用，think需要。think p v 保护一下就行。</p>
<p>函数take forks的定义</p>
<p><strong>功能</strong>: 要么拿到两把又子，要么被阻塞起来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">voidtake <span class="title">forks</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="comment">// i的取值: 0到N - 1</span></span><br><span class="line">    <span class="built_in">P</span>(mutex) ; <span class="comment">// 进入临界区</span></span><br><span class="line">    state[i] = HUNGRY; <span class="comment">// 我饿了!</span></span><br><span class="line">    <span class="function">test_take_left right <span class="title">forks</span><span class="params">(i)</span> </span>; <span class="comment">// 试图拿两把叉子</span></span><br><span class="line">    <span class="built_in">V</span>(mutex) ; <span class="comment">// 退出临界区</span></span><br><span class="line">    <span class="built_in">P</span>(s[i]); <span class="comment">// 没有又子便阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数test_take_left_right forks的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> test take left right <span class="title">forks</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="comment">//i: 0到N-1</span></span><br><span class="line">    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp;<span class="comment">// i: 我自己，or 其他人</span></span><br><span class="line">    state[LEFT]!= EATING &amp;&amp;</span><br><span class="line">    state[RIGHT] != EATING) &#123;</span><br><span class="line">        state[i] = EATING; <span class="comment">// 两把叉子到手</span></span><br><span class="line">    	<span class="built_in">V</span>(s[i]); <span class="comment">// 通知第i人可以吃饭了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数put_forks的定义</p>
<p>功能: 把两把又子放回原处，并在需要的时候，去唤醒左邻右舍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">voidput <span class="title">forks</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="comment">// i的取值: 0到N-1</span></span><br><span class="line">    <span class="built_in">P</span>(mutex) ; <span class="comment">// 进入临界区</span></span><br><span class="line">	state[i] = THINKING; <span class="comment">// 交出两把叉子</span></span><br><span class="line">	<span class="function">test_take_left right <span class="title">forks</span> <span class="params">(LEFT)</span> </span>;<span class="comment">// 看左邻居能否进餐</span></span><br><span class="line">    <span class="function">test_take left right <span class="title">forks</span> <span class="params">(RIGHT)</span> </span>;<span class="comment">// 看右邻居能否进餐</span></span><br><span class="line">    <span class="built_in">V</span>(mutex) ; <span class="comment">// 退出临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十一、死锁"><a href="#十一、死锁" class="headerlink" title="十一、死锁"></a>十一、死锁</h2><h3 id="1、死锁问题"><a href="#1、死锁问题" class="headerlink" title="1、死锁问题"></a>1、死锁问题</h3><p><strong>死锁的概念</strong>：一组阻塞的进程持有一种资源等待获取另一个进程所占有的一个资源。</p>
<p>例子：</p>
<ul>
<li>系统有2个磁带驱动器</li>
<li>P1 和 P2 各有一个，都需要另外一个</li>
</ul>
<p>为什么会出现死锁？</p>
<p>死锁是因为在多线程的并发执行下，线程抢占资源导致的情况。单一线程不会产生死锁。</p>
<h3 id="2、系统模型"><a href="#2、系统模型" class="headerlink" title="2、系统模型"></a>2、系统模型</h3><p>资源类型R1，R2，…Rm</p>
<ul>
<li>CPU cycles</li>
<li>memory space</li>
<li>I&#x2F;0 devices</li>
</ul>
<p>每个资源类型 Ri 有 Wi 实例。</p>
<p>每个进程使用资源如下:</p>
<ul>
<li>request&#x2F;get&lt;– free resource</li>
<li>use&#x2F;hold &lt;– requested&#x2F;used resource</li>
<li>release &lt;–free resource</li>
</ul>
<h4 id="可重复使用的资源"><a href="#可重复使用的资源" class="headerlink" title="可重复使用的资源"></a>可重复使用的资源</h4><ul>
<li>在一个时间只能一个进程使用且不能被删除</li>
<li>进程获得资源，后来释放由其他进程重用</li>
<li>资源的分类：处理器，I &#x2F; 0通道，主和副存储器，设备和数据结构，如文件，数据库和信号量</li>
<li>如果每个进程拥有一个资源并请求其它资源，死锁可能发生</li>
</ul>
<h4 id="使用资源"><a href="#使用资源" class="headerlink" title="使用资源"></a>使用资源</h4><ul>
<li>创建和销毁</li>
<li>在I &#x2F; 0缓冲区的中断，信号，消息，信息</li>
<li>如果接收消息阻塞可能会发生死锁</li>
<li>可能少见的组合事件会引起死锁</li>
</ul>
<h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><p>一组顶点 V 和边 E 的集合</p>
<p>V有两种类型：</p>
<ul>
<li>P &#x3D; {P1,P2,…,Pn} 集合包括系统中的所有进程。</li>
<li>R &#x3D; {R1,R2,…,Rn} 集合包括系统中的所有资源类型。</li>
</ul>
<p>E的两种类型：</p>
<ul>
<li>requesting&#x2F;claiming edge - directed edge Pi –&gt; Rj 进程请求资源</li>
<li>assignment&#x2F;holding edge - directed edge Ri –&gt; Pj 资源分配给进程</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221213175354705.png" alt="image-20221213175354705"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221213175402863.png" alt="image-20221213175402863"></p>
<p>无死锁情况</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221213175420526.png" alt="image-20221213175420526"></p>
<p>有死锁，形成了一个环。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221213175447638.png" alt="image-20221213175447638"></p>
<p>无死锁，形成了一个环。</p>
<p><strong>总结</strong>：</p>
<ul>
<li>如果图中不包含循环&#x3D;&#x3D;&gt;没有死锁。</li>
<li>如果图中包括循环&#x3D;&#x3D;&gt;<ul>
<li>如果每个资源类只有一个实例，那么死锁。</li>
<li>如果每个资源类有几个实例，可能死锁。</li>
</ul>
</li>
</ul>
<h3 id="3、死锁特征"><a href="#3、死锁特征" class="headerlink" title="3、死锁特征"></a>3、死锁特征</h3><p>死锁可能出现如果四个条件同时成立</p>
<p>死锁的四个特征，有死锁则一定有以下条件。有以下条件，不一定有死锁。</p>
<ul>
<li><strong>互斥</strong>:在一个时间只能有一个进程使用资源</li>
<li><strong>持有并等待</strong>:进程保持至少一个资源正在等待获取其他进程持有的额外资源</li>
<li><strong>无抢占</strong>:一个资源只能被进程自愿释放，进程已经完成了它的任务之后。</li>
<li><strong>循环等待</strong>:存在等待进程集合{PO，P1，…，PN)，PO正在等待P1所占用的资源,P1正在等待P2占用的资源，…,PN-1在等待PN所占用资源。PN正在等待PO所占用的资源。</li>
</ul>
<h3 id="4、死锁处理方法"><a href="#4、死锁处理方法" class="headerlink" title="4、死锁处理方法"></a>4、死锁处理方法</h3><ul>
<li>确保系统永远不会进入死锁状态。</li>
<li>运行系统进入死锁状态，然后恢复。</li>
<li>忽略这个问题，假装系统中从来没有发生死锁;用于大多数操作系统包括UNIX。</li>
</ul>
<h4 id="4-1、Deadlock-Prevention-死锁预防"><a href="#4-1、Deadlock-Prevention-死锁预防" class="headerlink" title="4.1、Deadlock Prevention 死锁预防"></a>4.1、Deadlock Prevention 死锁预防</h4><p>让死锁不会出现，打破他的四个必要条件。</p>
<p>限制申请方式</p>
<ul>
<li>互斥 - 共享资源不是必须的，必须占用非共享资源。</li>
<li>占用并等待 - 必须保证当一个进程请求的资源，它不持有任何其他资源。<ul>
<li>需要进程请求并分配其所有资源，它开始执行之前或允许进程请求资源仅当进程没有资源。</li>
<li>资源利用率低;可能发生饥饿</li>
</ul>
</li>
<li>无抢占 - <ul>
<li>如果进程占有某些资源，并请求其它不能被立即分配的资源，则释放当前正占有的资源</li>
<li>被抢占资源添加到资源列表中</li>
<li>只有当它能够获得旧的资源以及它请求新的资源，进程可以得到执行</li>
</ul>
</li>
<li>循环等待 - 对所有资源类型进行排序，并要求每个进程按照资源的顺序进行申请。</li>
</ul>
<h4 id="4-2、Deadlock-Avoidance-死锁避免"><a href="#4-2、Deadlock-Avoidance-死锁避免" class="headerlink" title="4.2、Deadlock Avoidance 死锁避免"></a>4.2、Deadlock Avoidance 死锁避免</h4><p><strong>需要系统具有一些额外的先验信息提供</strong></p>
<ul>
<li>最简单和最有效的模式是要求每个进程声明它可能需要的每个类型资源的<code>最大数目</code></li>
<li>资源的分配状态是通过限定提供与分配的资源数量，和进程的最大需求。</li>
<li>死锁避免算法动态检查的资源分配状态，以确保永远不会有一个环形等待状态。</li>
<li>当一个进程请求可用资源，系统必须判断立即分配是否能使系统处于安全状态。</li>
<li>系统处于安全状态指: 针对所有进程，存在安全序列。</li>
<li>序列&lt;P1,P2,…,PN&gt;是<code>安全的</code>: 针对每个Pi，Pi要求的资源能够由当前可用的资源+所有的Pj持有的资源来满足，其中 j &lt; i。<ul>
<li>如果Pi资源的需求不是立即可用，那么Pi可以等到所有Pj完成。</li>
<li>当Pi完成后，Pi+1可以得到所需要的资源，执行，返回所分配的资源，并终止。</li>
<li>用同样的方法， Pi+2, Pi+3 和Pn能获得其所需的资源。</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221213200256194.png" alt="image-20221213200256194"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221213195531208.png" alt="image-20221213195531208"></p>
<h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><p>通用的死锁避免算法：<strong>银行家算法</strong></p>
<p>银行家算法 (Banker’s Algorithm)是一个死锁避免的著名算法，是由艾兹格·迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。</p>
<p>背景<br>在银行系统中，客户完成项目需要申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求并完成项目时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要请资源的进程。</p>
<p>Banker’s Algorithm 前提条件：</p>
<ul>
<li>多个实例。</li>
<li>每个进程都必须能最大限度地利用资源。</li>
<li>当一个进程请求一个资源，就不得不等待。</li>
<li>当一个进程获得所有的资源就必须在一段有限的时间释放它们。</li>
</ul>
<p>基于上述前提条件，银行家算法通过尝试寻找允许每个进程获得的最大资源并结束 (把资源返还给系统)的进程请求的一个理想执行时序，来决定一个状态是否是安全的。不存在这满足要求的执行时序的状态都是不安全的。</p>
<p><strong>银行家算法数据结构</strong><br>n &#x3D; 进程数量，m &#x3D; 资源类型数量</p>
<ul>
<li>Max(总需求量): n * m 矩阵.。如果 Max [i,j] &#x3D; k，表示进程Pi最多请求资源类型Rj的k个实例。</li>
<li>Available (剩余空闲量) :长度为 m 的向量。如果Available [j]&#x3D; k.有 k 个类型 Rj 的资源实例可用。</li>
<li>Allocation (已分配量) : n * m矩阵。如果Allocation[i，j] &#x3D; k，则Pi当前分配了k个Rj的实例。</li>
<li>Need (未来需要量) : n * m矩阵。如果 Need[i，j] &#x3D; k，则Pi可能需少k个Rj实例完成任务。<br>          <code>Need [i,j] = Max[i,j] - Allocation [i,j]</code></li>
</ul>
<ol>
<li><p>Work 和 Finish 分别是长度为m和n的向量。<br>初始化:<br>Work &#x3D; Available &#x2F;&#x2F;当前资源剩余空闲量<br>Finish [i] &#x3D; false for i - 1,2,…, n.  &#x2F;&#x2F;线程i没结束</p>
</li>
<li><p>找这样的i: &#x2F;&#x2F;接下来找出Need比Work小的进程i<br>(a) Finish [i] &#x3D; false<br>(b) Needi &lt;&#x3D; Work</p>
</li>
</ol>
<p>没有找到这样的i，转4。</p>
<ol start="3">
<li>Work &#x3D; Work + Allocation; &#x2F;&#x2F;进程i的资源需求量小于当前剩余空闲资源量</li>
</ol>
<p>  Finish[i] &#x3D; true            所以配置给它再回收<br>  转2.</p>
<ol start="4">
<li>If Finish [i] &#x3D;&#x3D; true for all i, &#x2F;&#x2F;所有进程的Finish为True</li>
</ol>
<p>  then the system is in a safe state. 表明系统处于安全状态</p>
<p>Banker’s Algorithm</p>
<p>initial: Request &#x3D; request vector for process Pi. if Requesti[j]&#x3D; k then process Pi wants k instances of resource type Rj.</p>
<p>While:</p>
<ol>
<li><p>如果 Requesti &lt;&#x3D; Needi，转到步骤 2。  否则，提出错误条件，因为进程已经超过了其最大要求。</p>
</li>
<li><p>如果 Requesti &lt;&#x3D; Available，转到步骤3 否则 pi 必须等待，因为资源不可用。</p>
</li>
<li><p>假装给Pi分配它需要的资源: &#x2F;&#x2F;生成一个需要判断状态是否安全的资源分配环境<br>Available &#x3D; Available - Requesti</p>
<p>Allocationi &#x3D; Allocationi + Requesti</p>
<p>Needi &#x3D; Needi - Requesti</p>
</li>
</ol>
<p>CALL Safety State Estimating Algorithm</p>
<ul>
<li>如果返回safe，将资源分配给Pi。</li>
<li>如果返回unsafe,Pi必须等待,旧的资源分配状态被恢复</li>
</ul>
<h4 id="4-3、Deadlock-Detection-死锁检测"><a href="#4-3、Deadlock-Detection-死锁检测" class="headerlink" title="4.3、Deadlock Detection 死锁检测"></a>4.3、Deadlock Detection 死锁检测</h4><ul>
<li>允许系统进入死锁状态</li>
<li>死锁检测算法</li>
<li>恢复机制</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221213210924539.png" alt="image-20221213210924539"></p>
<p>资源类型的几个实例</p>
<p>数据结构<br>Available:长度为M的向量表示每种类型可用资源的数量<br>Allocation:一个n<em>m阵定义了当前分配给各个进程每种类型资源的数量。如果 Allocation[i ，j] &#x3D; k，进程Pi 拥有 资源Ri的k个实例。<br>Request:一个n</em>m矩阵表示各进程的当前请求.。 如果Request [i ，j] &#x3D; k,表示进程Pi 请求k 个资源Rj的实例。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221213211327578.png" alt="image-20221213211327578"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221213211625435.png" alt="image-20221213211625435"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221213211716498.png" alt="image-20221213211716498"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221213211816748.png" alt="image-20221213211816748"></p>
<p>检测算法使用<br>何时、使用什么样的频率来检测依赖于</p>
<ul>
<li>死锁多久可能会发生?</li>
<li>多少进程需要被回滚?</li>
</ul>
<p>one for each disjoint cycle<br>如果检测算法多次被调用，有可能是资源图有多个循环，所以我们无法分辨出多个可能死锁进程中的哪些“造成”死锁。</p>
<h4 id="4-4、Recovery-from-Deadlock-死锁恢复"><a href="#4-4、Recovery-from-Deadlock-死锁恢复" class="headerlink" title="4.4、Recovery from Deadlock 死锁恢复"></a>4.4、Recovery from Deadlock 死锁恢复</h4><ul>
<li>终止所有的死锁进程</li>
<li>在一个时间内终止一个进程直到死锁消除</li>
<li>终止进程的顺序应该是<ul>
<li>进程的优先级</li>
<li>进程运行了多久以及需要多少时间才能完成</li>
<li>进程占用的资源</li>
<li>进程完成需要的资源</li>
<li>多少进程需要被终止</li>
<li>进程是交互还是批处理</li>
</ul>
</li>
</ul>
<p>特点：</p>
<ul>
<li>选择一个受害者 - 最小的成本</li>
<li>回滚- 返回到一些安全状态，重启进程到安全状态</li>
<li>饥饿 -同一进程可能一直被选作受害者，包括回滚的数量。</li>
</ul>
<h2 id="十二、进程间通信"><a href="#十二、进程间通信" class="headerlink" title="十二、进程间通信"></a>十二、进程间通信</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><h4 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h4><p>IPC ：进程间通信（<strong>确保进程间能够进行数据传输</strong>）</p>
<ul>
<li>进程通信的机制及同步</li>
<li>不使用共享变量的进程通信</li>
<li>IPC facility 提供2个操作<ul>
<li>send(message) -消息大小固定或者可变</li>
<li>receive(message)</li>
</ul>
</li>
<li>如果P 和  Q 想通信，需要<ul>
<li>在它们之间建立通信链路</li>
<li>通过 send&#x2F;receive交换消息</li>
</ul>
</li>
<li>通信链路的实现<ul>
<li>物理《例如，共享内存，硬件总线)</li>
<li>逻辑(例如，逻辑属性)</li>
</ul>
</li>
</ul>
<h4 id="直接及间接通信"><a href="#直接及间接通信" class="headerlink" title="直接及间接通信"></a>直接及间接通信</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221213212812177.png" alt="image-20221213212812177"></p>
<p>A 间接通信，通过操作系统内核</p>
<p>B 直接通信</p>
<p><strong>直接通信</strong></p>
<p>进程必须正确的命名对方</p>
<ul>
<li>send (P发送信息到进程Pmessage)</li>
<li>receive(Q message)- 从进程 Q接受消息</li>
</ul>
<p>通信链路的属性：</p>
<ul>
<li>自动建立链路</li>
<li>一条链路恰好对应一对通信进程</li>
<li>每对进程之间只有一个链接存在</li>
<li>链接可以是单向的，但通常为双向的</li>
</ul>
<p><strong>间接通信</strong></p>
<p>定向从消息队列接收消息</p>
<ul>
<li>每个消息队列都有一个唯一的ID</li>
<li>只有它们共享了一个消息队列，进程才能够通信</li>
</ul>
<p>通信链路的属性：</p>
<ul>
<li>只有进程共享一个共同的消息队列，才建立链路</li>
<li>链接可以与许多进程相关联</li>
<li>每对进程可以共享多个通信链路</li>
<li>连接可以是单向或双向</li>
</ul>
<p>操作：</p>
<ul>
<li>创建一个新的消息队列</li>
<li>通过消息队列发送和接收消息</li>
<li>销毁消息队列</li>
</ul>
<p>原语的定义如下</p>
<ul>
<li>send(A,message)发送消息到队列A</li>
<li>receive(A,message)从队列 A接受消息</li>
</ul>
<h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><p>另一种分类：阻塞非阻塞</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221213213606346.png" alt="image-20221213213606346"></p>
<h4 id="通信链路缓冲"><a href="#通信链路缓冲" class="headerlink" title="通信链路缓冲"></a>通信链路缓冲</h4><p>队列的消息被附加到链路，可以是以下3种方式之一:参考buffer</p>
<ol>
<li><p>0 容量 - 0 messages<br>发送方必须等待接收方(rendezvous)</p>
</li>
<li><p>有限容量 -n messages的有限长度</p>
<p>发送方必须等待，如果队列满</p>
</li>
<li><p>无限容量 - 无限长度<br>发送方不需要等待</p>
</li>
</ol>
<h3 id="2、信号"><a href="#2、信号" class="headerlink" title="2、信号"></a>2、信号</h3><p>Signal (信号)</p>
<ul>
<li>软件中断通知事件处理</li>
<li>Examples: SIGFPE， SIGKILL，SIGUSR1， SIGSTOP， SIGCONT</li>
</ul>
<p>接收到信号时会发生什么？</p>
<ul>
<li>Catch:指定信号处理函数被调用</li>
<li>Ignore:依靠操作系统的默认操作<ul>
<li>Example: Abort, memory dump, suspend or resume process</li>
</ul>
</li>
<li>Mask:闭塞信号因此不会传送<ul>
<li>可能是暂时的(当处理同样类型的信号)</li>
</ul>
</li>
<li>不足<br>不能传输要交换的任何数据，因为信号只有1 byte 的大小，一般就用来发送通知。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221213214733119.png" alt="image-20221213214733119"></p>
<p>针对每一个信号都有自己的处理器handler，处理器就是信号函数。当收到信号时，系统调用先把当前运行的堆栈段移至信号函数，即让信号函数开始执行，执行之后再返回原有的操作执行。（相当于中断）</p>
<h3 id="3、管道"><a href="#3、管道" class="headerlink" title="3、管道"></a>3、管道</h3><p>子进程从父进程继承文件描述符(<code>父进程建立管道，来让子进程之间进行通信</code>)</p>
<ul>
<li>file descriptor 0 stdin, 1 stdout, 2 stderr</li>
</ul>
<p>进程不知道 (或不关心!) 从键盘，文件，程序读取或写入到终端，文件，程序。<br>% ls l more<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221213215610324.png" alt="image-20221213215610324"></p>
<p>|就是管道 两个线程ls more 共享管道中的数据 ,ls 输出到管道 buffer 上， more 从管道输入。</p>
<p>shell:</p>
<ul>
<li>创建管道</li>
<li>为 ls 创建一个进程 ，设置 stdout为 管道写端</li>
<li>为 more 创建一个进程，设置 stdin 为管道读端</li>
</ul>
<h3 id="4、消息队列"><a href="#4、消息队列" class="headerlink" title="4、消息队列"></a>4、消息队列</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221213220033690.png" alt="image-20221213220033690"></p>
<h3 id="5、共享内存"><a href="#5、共享内存" class="headerlink" title="5、共享内存"></a>5、共享内存</h3><p>前边的管道、消息队列都是一种间接通信的方式，共享内存是一种直接通信的方式。</p>
<p>共享内存，一个写了之后，一个可以直接看到。</p>
<p>进程</p>
<ul>
<li>每个进程都有私有地址空间</li>
<li>在每个地址空间内，明确地设置了共享内存段</li>
</ul>
<p>优点</p>
<ul>
<li>快速、方便地共享数据</li>
</ul>
<p>不足</p>
<ul>
<li>必须同步数据访问，存在同步互斥的问题。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221213220407035.png" alt="image-20221213220407035"></p>
<ul>
<li>最快的方法</li>
<li>一个进程写另外一个进程立即可见没有系统调用干预</li>
<li>没有数据复制</li>
<li>不提供同步<ul>
<li>由程序员提供同步</li>
</ul>
</li>
</ul>
<p>如何实现两个进程共享一块内存？</p>
<p>把同一块物理内存，映射到不同的进程相同或者不同的地址空间。通过虚地址访问内存，其实就访问的是同一块物理内存。</p>
<h2 id="十三、文件"><a href="#十三、文件" class="headerlink" title="十三、文件"></a>十三、文件</h2><h3 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h3><h4 id="1-1、文件系统和文件"><a href="#1-1、文件系统和文件" class="headerlink" title="1.1、文件系统和文件"></a>1.1、文件系统和文件</h4><p><strong>文件系统</strong>: 一种用于持久性存储的系统抽象</p>
<ul>
<li>在存储器上: 组织、控制、导航、访问和检索数据</li>
<li>大多数计算机系统包含文件系统</li>
<li>个人电脑、服务器、笔记本电脑</li>
<li>iPod、Tivo &#x2F;机顶盒、</li>
<li>手机&#x2F;掌上电脑 </li>
<li>Google 可能是由一个文件系统构成的</li>
</ul>
<p><strong>文件</strong>: 文件系统中一个单元的相关数据在操作系统中的抽象</p>
<p><strong>文件系统的功能</strong>：</p>
<ul>
<li>分配文件磁盘空间<ul>
<li>管理文件块 (哪一块属于哪一个文件)</li>
<li>管理空闲空间(哪一块是空闲的)</li>
<li>分配算法 (策略)</li>
</ul>
</li>
<li>管理文件集合<ul>
<li>定位文件及其内容</li>
<li>命名: 通过名字找到文件的接口</li>
<li>最常见:分层文件系统</li>
<li>文件系统类型(组织文件的不同方式)</li>
</ul>
</li>
<li>提供的便利及特征<ul>
<li>保护: 分层来保护数据安全</li>
<li>可靠性&#x2F;持久性: 保持文件的持久即使发生崩溃、媒体错误、攻击等</li>
</ul>
</li>
</ul>
<p>文件属性：</p>
<p>名称、类型、位置、大小、保护、创建者、创建时间、最近修改时间、</p>
<p>文件头：</p>
<ul>
<li>在存储元数据中保存了每个文件的信息</li>
<li>保存文件的属性</li>
<li>跟踪哪一块存储块属于逻辑上文件结构的哪个偏移</li>
</ul>
<h4 id="1-2、文件描述符"><a href="#1-2、文件描述符" class="headerlink" title="1.2、文件描述符"></a>1.2、文件描述符</h4><p>需要元数据数据来管理打开文件：</p>
<ul>
<li>文件指针:指向最近的一次读写位置，每个打开了这个文件的进程都这个指针</li>
<li>文件打开计数: 记录文件打开的次数 - 当最后一个进程关闭了文件时，允许将其从打开文件表中移除</li>
<li>文件磁盘位置: 缓存数据访问信息</li>
<li>访问权限: 每个程序访问模式信息</li>
</ul>
<p>用户视图</p>
<ul>
<li>持久的数据结构</li>
</ul>
<p>系统访问接口</p>
<ul>
<li>字节的集合(UNIX)</li>
<li>系统不会关心你想存储在磁盘上的任何的数据结构!</li>
</ul>
<p>操作系统内部视角</p>
<ul>
<li>块的集合(块是逻辑转换单元，而扇区是物理转换单元)</li>
<li>块大小&lt;&gt; 扇区大小;在UNIX中，块的大小是 4 KB</li>
</ul>
<p>当用户说: 给我2-12字节空间时会发生什么?</p>
<ul>
<li>获取字节所在的块</li>
<li>返回块内对应部分</li>
</ul>
<p>如果说要写2-12字节呢?</p>
<ul>
<li>获取块</li>
<li>修改块内对应部分</li>
<li>写回块</li>
</ul>
<p>在文件系统中的所有操作都是在整个块空间上进行的</p>
<ul>
<li>举个例子，getc()，putc() : 即使每次只访问1字节的数据，也会缓存目标数据4096字节</li>
</ul>
<p>用户怎么访问文件</p>
<ul>
<li><p>在系统层面需要知道用户的访问模式</p>
</li>
<li><p>顺序访问: 按字节依次读取</p>
<ul>
<li>几乎所有的访问都是这种方式</li>
</ul>
</li>
<li><p>随机访问: 从中间读写</p>
<ul>
<li><p>不常用，但是仍然重要.例如，虚拟内存支持文件: 内存页存储在文件中</p>
</li>
<li><p>更加快速 - 不希望获取文件中间的内容的时候也必须先获取块内所有字节</p>
</li>
</ul>
</li>
<li><p>基于内容访问: 通过特征</p>
<ul>
<li>许多系统不提供此种访问方式，相反，数据库是建立在索引内容的磁盘访问上(需要高效的随机访问)</li>
</ul>
</li>
</ul>
<p>类似于数据库的访问模式<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214163740751.png" alt="image-20221214163740751"></p>
<p>文件内部结构</p>
<ul>
<li>无结构<ul>
<li>单词、比特的队列</li>
</ul>
</li>
<li>简单记录结构<ul>
<li>列</li>
<li>固定长度</li>
<li>可变长度</li>
</ul>
</li>
<li>复杂结构<ul>
<li>格式化的文档(如，MS Word，PDF)</li>
<li>可执行文件</li>
</ul>
</li>
</ul>
<p>多用户系统中的文件共享是很必要的</p>
<p>访问控制</p>
<ul>
<li>谁能够获得哪些文件的哪些访问权限</li>
<li>访问模式: 读、写、执行、删除、列举等</li>
</ul>
<p>文件访问控制列表(ACL)</p>
<ul>
<li>&lt;文件实体，权限&gt;</li>
</ul>
<p>Unix 模式</p>
<ul>
<li>&lt;用户|组|所有人，读|写|可执行&gt;</li>
<li>用户ID识别用户，表明每个用户所允许的权限及保护模式组ID</li>
<li>允许用户组成组，并指定了组访问权限</li>
</ul>
<p>指定多用户&#x2F;客户如何同时访问共享文件</p>
<ul>
<li>和过程同步算法相似</li>
<li>因磁盘I&#x2F;0和网络延迟而设计简单</li>
</ul>
<p>Unix 文件系统(UFS) 语义</p>
<ul>
<li>对打开文件的写入内容立即对其他打开同一文件的其他用户可见</li>
<li>共享文件指针允许多用户同时读取和写入文件</li>
</ul>
<p>会话语义</p>
<ul>
<li>写入内容只有当文件关闭时可见</li>
</ul>
<p>锁</p>
<ul>
<li>一些操作系统和文件系统提供该功能</li>
</ul>
<h4 id="1-3、目录"><a href="#1-3、目录" class="headerlink" title="1.3、目录"></a>1.3、目录</h4><p>文件以目录的方式组织起来</p>
<p>目录是一类特殊的文件</p>
<ul>
<li>每个目录都包含了一张表&lt;name， pointer to file header&gt;</li>
</ul>
<p>目录和文件的树型结构</p>
<ul>
<li>早期的文件系统是扁平的 (只有一层目录)</li>
<li>层次名称空间 树状</li>
</ul>
<p>目录的典型操作：</p>
<ul>
<li>搜索文件</li>
<li>创建文件</li>
<li>删除文件</li>
<li>枚举目录</li>
<li>重命名文件</li>
<li>在文件系统中遍历一个路径</li>
</ul>
<p>操作系统应该只允许内核模式修改目录</p>
<ul>
<li>确保映射的完整性</li>
<li>应用程序能够读目录 (如 ls)</li>
</ul>
<p>目录如何存储完成：</p>
<ul>
<li><p>文件名的线性列表，包涵了指向数据块的指针（数组、链表）</p>
<ul>
<li><p>编程简单</p>
</li>
<li><p>执行耗时</p>
</li>
</ul>
</li>
<li><p>Hash表- hash数据结构的线性表</p>
<ul>
<li>减少目录搜索时间</li>
<li>碰撞两个文件名的hash值相同I</li>
<li>固定大小</li>
</ul>
</li>
</ul>
<p>路径的遍历：（比较耗费时间）</p>
<ul>
<li><p>名字解析: 逻辑名字转换成物理资源 (如文件)的过程</p>
<ul>
<li><p>在文件系统中: 到实际文件的文件名 (路径)</p>
</li>
<li><p>遍历文件目录直到找到目标文件</p>
</li>
</ul>
</li>
<li><p>举例:解析“&#x2F;bin&#x2F;ls”</p>
<ul>
<li>读取root的文件头 (在磁盘固定位置)读取root的数据块; 搜索“bin”项</li>
<li>读取bin的文件头</li>
<li>读取bin的数据块: 搜索“ls”项</li>
<li>读取ls的文件头</li>
</ul>
</li>
<li><p>当前工作目录</p>
<ul>
<li>每个进程都会指向一个文件目录用于解析文件名</li>
<li>允许用户指定相对路径来代替绝对路径</li>
</ul>
</li>
</ul>
<p><strong>挂载</strong> 把一个文件系统挂载到一个目录上去</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214165525795.png" alt="image-20221214165525795"></p>
<p>挂载点是特殊的文件，一般是根</p>
<h4 id="1-4、文件别名"><a href="#1-4、文件别名" class="headerlink" title="1.4、文件别名"></a>1.4、文件别名</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214165608627.png" alt="image-20221214165608627"></p>
<p>如果删除一个有别名的文件会如何呢 ?</p>
<ul>
<li>软链接的话会形成悬空指针</li>
<li>硬链接的话会让引用值–</li>
</ul>
<p>Backpointers 方案</p>
<ul>
<li>每个文件有一个包含多个 backpointers 的列表，所以删除所有的 backpointers</li>
<li>Backpointers使用菊花链管理</li>
</ul>
<p>添加一个间接层: 目录项数据结构链接 </p>
<ul>
<li>已存在文件的另外一个名字 (指针)链接处理 </li>
<li>跟随指针来定位文件</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214170047129.png" alt="image-20221214170047129"></p>
<h4 id="1-5、文件系统种类"><a href="#1-5、文件系统种类" class="headerlink" title="1.5、文件系统种类"></a>1.5、文件系统种类</h4><p>磁盘文件系统</p>
<ul>
<li>文件存储在数据存储设备上，如磁盘</li>
<li>例如: FAT，NTFS，ext2&#x2F;3，IS09660，等</li>
</ul>
<p>数据库文件系统</p>
<ul>
<li>文件根据其特征是可被寻址 (辨识)的</li>
<li>例如: WinFS</li>
</ul>
<p>日志文件系统</p>
<ul>
<li>记录文件系统的修改&#x2F;事件</li>
<li>例如: journaling file system</li>
</ul>
<p>网络&#x2F;分布式文件系统</p>
<ul>
<li>例如: NFS，SMB，AFS， GFS</li>
</ul>
<p>特殊&#x2F;虚拟文件系统</p>
<p>关于分布式文件系统的补充：</p>
<ul>
<li>文件可以通过网络被共享<ul>
<li>文件位于远程服务器</li>
<li>客户端远程挂载服务器文件系统</li>
<li>标准系统文件访问被转换成远程访问</li>
<li>标准文件共享协议: NFS for Unix，CIFS for Windows</li>
</ul>
</li>
<li>分布式文件系统的问题<ul>
<li>客户端和客户端上的用户辨别起来很复杂</li>
<li>例如，NFS是不安全的</li>
<li>一致性问题</li>
<li>错误处理模式</li>
</ul>
</li>
</ul>
<h3 id="2、虚拟文件系统"><a href="#2、虚拟文件系统" class="headerlink" title="2、虚拟文件系统"></a>2、虚拟文件系统</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214173543640.png" alt="image-20221214173543640"></p>
<p><strong>目的</strong> ：对所有不同文件系统的抽象<br><strong>功能</strong> ：</p>
<ul>
<li>提供相同的文件和文件系统接口</li>
<li>管理所有文件和文件系统关联的数据结构</li>
<li>高效查询例程，遍历文件系统</li>
<li>与特定文件系统模块的交互</li>
</ul>
<p>文件系统数据结构</p>
<ul>
<li>卷控制块 (每个文件系统一个)</li>
<li>文件控制块 (每个文件一个)</li>
<li>目录节点(每个目录项一个)</li>
</ul>
<p>持续存储在二级存储中</p>
<ul>
<li>在分配在存储设备中的数据块中</li>
</ul>
<p>当需要时加载进内存</p>
<ul>
<li>卷控制模块 : 当文件系统挂载时进入内存</li>
<li>文件控制块: 当文件被访问时进入每次</li>
<li>目录节点: 在遍历一个文件路径时进入内存</li>
</ul>
<p>卷控制块 (Unix: “superblock”)</p>
<ul>
<li>每个文件系统一个</li>
<li>文件系统详细信息</li>
<li>块、块大小、空余块、计数&#x2F;指针等</li>
</ul>
<p>文件控制块(Unix:“vnode”or “inode”)</p>
<ul>
<li>每个文件一个</li>
<li>文件详细信息</li>
<li>许可、拥有者、大小、数据库位置等</li>
</ul>
<p>目录节点(Linux:“dentry”)</p>
<ul>
<li>每个目录项一个(目录和文件)</li>
<li>将目录项数据结构及树型布局编码成树型数据结构</li>
<li>指向文件控制块、父节点、项目列表等</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214174157737.png" alt="image-20221214174157737"></p>
<p>暗黄色 vol: 卷控制信息</p>
<p>蓝色 dir : 目录节点信息</p>
<p>黄色 file : 文件节点信息</p>
<h3 id="3、数据块缓存"><a href="#3、数据块缓存" class="headerlink" title="3、数据块缓存"></a>3、数据块缓存</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214202237289.png" alt="image-20221214202237289"></p>
<p>数据块按需读入内存</p>
<ul>
<li>提供read() 操作</li>
<li>预读: 预选读取后面的数据块</li>
</ul>
<p>数据块使用后被缓存</p>
<ul>
<li>假设数据将会再次被使用</li>
<li>写操作可能被缓存和延迟写入</li>
</ul>
<p>两种数据块缓存方式</p>
<ul>
<li>普通缓冲区缓存</li>
<li>页缓存: 统一缓存数据块和内存页</li>
</ul>
<p>分页要求：当需要一个页时才将其载入内存<br>支持存储：一个页 (在虚拟地址空间中) 可以被映射到一个本地文件中 (在二级存储中)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214202326356.png" alt="image-20221214202326356"></p>
<p>文件数据块的页缓存</p>
<ul>
<li>在虚拟内存中文件数据块被映射成页</li>
<li>文件的读&#x2F;写操作被转换成对内存的访问</li>
<li>可能导致缺页和&#x2F;或设置为脏页</li>
<li>问题:页置换- 从进程或文件页缓存中?</li>
</ul>
<h3 id="4、打开文件的数据结构"><a href="#4、打开文件的数据结构" class="headerlink" title="4、打开文件的数据结构"></a>4、打开文件的数据结构</h3><p>打开文件描述</p>
<ul>
<li>每个被打开的文件一个</li>
<li>文件状态信息</li>
<li>目录项、当前文件指针、文件操作设置等</li>
</ul>
<p>打开文件表</p>
<ul>
<li>一个进程一个</li>
<li>一个系统级的</li>
<li>每个卷控制块也会保存一个列表</li>
<li>所以如果有文件被打开将不能被卸载</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214202716488.png" alt="image-20221214202716488"></p>
<p>一些操作系统和文件系统提供该</p>
<p>功能调节对文件的访问</p>
<p>强制和劝告</p>
<ul>
<li>强制 - 根据锁保持情况和需求拒绝访问</li>
<li>劝告- 进程可以查找锁的状态来决定怎么做</li>
</ul>
<h3 id="5、文件分配"><a href="#5、文件分配" class="headerlink" title="5、文件分配"></a>5、文件分配</h3><p>大多数文件都很小</p>
<ul>
<li>需要对小文件提供强力的支持</li>
<li>块空间不能太大</li>
</ul>
<p>一些文件非常大</p>
<ul>
<li>必须支持大文件 (64-bit 文件偏移)</li>
<li>大文件访问需要相当高效</li>
</ul>
<p>如何为一个文件分配数据块</p>
<p>分配方式</p>
<ul>
<li>连续分配</li>
<li>链式分配</li>
<li>索引分配</li>
</ul>
<p>指标</p>
<ul>
<li>高效: 如存储利用(外部碎片)</li>
<li>表现: 如访问速度</li>
</ul>
<h4 id="文件分配方式"><a href="#文件分配方式" class="headerlink" title="文件分配方式"></a>文件分配方式</h4><p>连续分配：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214203817759.png" alt="image-20221214203817759"></p>
<p>链式存储：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214204637617.png" alt="image-20221214204637617"></p>
<p>索引存储：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214204842162.png" alt="image-20221214204842162"></p>
<p>应对大文件，一个索引不够的情况下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214205116917.png" alt="image-20221214205116917"></p>
<p>多级索引</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214205416391.png" alt="image-20221214205416391"></p>
<p>文件头包含13个指针</p>
<ul>
<li>10 个指针指向数据块</li>
<li>第11个指针指向间接数据块</li>
<li>第12个指针指向二重间接数据块</li>
<li>第13个指针指向三重间接数据块</li>
</ul>
<p>影响</p>
<ul>
<li>提高了文件大小限制阀值</li>
<li>动态分配数据块，文件扩展很容易</li>
<li>小文件开销小</li>
<li>只为大文件分配间接数据块，大文件在访问间接数据块是需要大量的查询</li>
</ul>
<h3 id="6、空闲空间列表"><a href="#6、空闲空间列表" class="headerlink" title="6、空闲空间列表"></a>6、空闲空间列表</h3><p>跟踪在存储中的所有未分配的数据块</p>
<p>空闲空间列表存储在哪里?</p>
<p>空闲空间列表的最佳数据结构是什么样的 ?</p>
<hr>
<p>用位图代表空闲数据块列表</p>
<ul>
<li>10101011101111..</li>
<li>如果i &#x3D; 0 表明数据块(扇区)i是空闲，反之则已分配</li>
</ul>
<p>使用简单但是可能会是一个big vector:</p>
<ul>
<li>160 GB disk -&gt; 40 M blocks -&gt; 5 MB worth of bits</li>
<li>然而，如果空闲空间在磁盘中均匀分布，那么在找到“0”之前需要扫描n&#x2F;r<ul>
<li>n &#x3D; 磁盘上数据块的总数</li>
<li>r &#x3D; 空闲块的数目</li>
</ul>
</li>
</ul>
<p>需要保护</p>
<ul>
<li>指向空闲列表的指针</li>
<li>位图<ul>
<li>必须保存在磁盘上</li>
<li>在内存和磁盘拷贝可能有所不同</li>
<li>不允许block[i]在内存中的状态为bit[i] &#x3D; 1而在磁盘中bit[i] &#x3D; 0</li>
</ul>
</li>
<li>解决:<ul>
<li>在磁盘上设置bit[i] &#x3D; 1</li>
<li>分配block[i]</li>
<li>在内存中设置bit[i] &#x3D; 1</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214210259270.png" alt="image-20221214210259270"></p>
<h3 id="7、多磁盘管理-RAID"><a href="#7、多磁盘管理-RAID" class="headerlink" title="7、多磁盘管理 - RAID"></a>7、多磁盘管理 - RAID</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214210919500.png" alt="image-20221214210919500"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214211018943.png" alt="image-20221214211018943"></p>
<p>使用多个并行磁盘来增加</p>
<ul>
<li>吞吐量(通过并行)</li>
<li>可靠性和可用性 (通过几余)</li>
</ul>
<p>RAID - 元余磁盘阵列</p>
<ul>
<li>各种磁盘管理技术</li>
<li>RAID levels: 不同RAID 分类(如，RAID-0，RAID-1，RAID-5)</li>
</ul>
<p>实现</p>
<ul>
<li>在操作系统内核: 存储&#x2F;卷管理</li>
<li>RAID硬件控制器(I&#x2F;0)</li>
</ul>
<p>RAID 0:文件储存在多个盘上，可以并发请求，提高效率。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214211310336.png" alt="image-20221214211310336"></p>
<p>RAID 1：相同的数据写在多个盘上，加强可靠性。一个盘坏了，另一个接着用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214211456896.png" alt="image-20221214211456896"></p>
<p>RAID 4：结合RAID 0 和 RAID 1 的优点，实现分盘存储和可靠存储，加一个校验盘。通过校验盘来推出坏了的盘的数据，其他的盘正常的分盘存储。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214211618510.png" alt="image-20221214211618510"></p>
<p>RAID 5：在RAID 4 的基础上，把奇偶校验做一个修改，让奇偶校验均匀的分配在其他的盘上。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214211727662.png" alt="image-20221214211727662"></p>
<h3 id="8、磁盘调度"><a href="#8、磁盘调度" class="headerlink" title="8、磁盘调度"></a>8、磁盘调度</h3><p>磁盘结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214212534375.png" alt="image-20221214212534375"></p>
<p>读取或写入时，磁头必须被定位在期望的磁道，并从所期望的扇区的开始</p>
<p>寻道时间：定位到期望的磁道所花费的时间</p>
<p>旋转延迟：从扇区的开始处到到达目的处花费的时间</p>
<p>平均旋转延迟时间 &#x3D; 磁盘旋转一周时间的一半</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214212952591.png" alt="image-20221214212952591"></p>
<ul>
<li><p>寻道时间是性能上区别的原因</p>
</li>
<li><p>对单个磁盘，会有一个I&#x2F;0请求数目</p>
</li>
<li><p>如果请求是随机的，那么会表现很差</p>
</li>
</ul>
<p>寻道时间是比较长的，开销过大。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214214015096.png" alt="image-20221214214015096"></p>
<p>FIFO</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214214126578.png" alt="image-20221214214126578"></p>
<p>存在的问题：一前一后，开销过大</p>
<p>最短服务优先 SSTF</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214214212603.png" alt="image-20221214214212603"></p>
<p>存在的问题：可能只负责最近的，导致饥饿现象</p>
<p>SCAN</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214214441631.png" alt="image-20221214214441631"></p>
<p>C-SCAN 单方向</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20221214214543986.png" alt="image-20221214214543986"></p>
<p>在SSTF、SCAN及CSCAN几种调度算法中，都可能出现磁臂停留在某处不动的情况，例如进程反复请求对某一磁道的I&#x2F;0操作。 我们把这一现象称为“磁臂粘着”(arm stickiness)。</p>
<p>N-Step-SCAN算法是将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次处理这些子队列。 而每处理一个队列时又是按SCAN算法，对一个队列处理完后，再处理其他队列。</p>
<p>当正在处理某子队列时，如果又出现新的磁盘I&#x2F;0请求，便将新请求进程放入其他队列，这样就可避免出现粘着现象。</p>
<p>FSCAN算法实质上是N步SCAN算法的简化，即FSCAN只将磁盘请求队列分成两个子队列。</p>
<p>一个是由当前所有请求磁盘I&#x2F;0的进程形成的队列，由磁盘调度按SCAN算法进行处理。在处理某队列期间，将新出现的所有请求磁盘I&#x2F;0的进程放入另一个等待处理的请求队列。这样，所有的新请求都将被推迟到下一次扫描时处理。	</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://www.haungrd.top">Huang RD</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.haungrd.top/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">http://www.haungrd.top/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.haungrd.top" target="_blank">Huang Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></div><div class="post_share"><div class="social-share" data-image="https://www.huangrd.top/images/agentina/11.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/20/html/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HTML</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/16/Linux%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/" title="Linux 复习提升"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-16</div><div class="title">Linux 复习提升</div></div></a></div><div><a href="/2023/03/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/" title="操作系统复习提升"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">操作系统复习提升</div></div></a></div><div><a href="/2023/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E6%8F%90%E5%8D%87/" title="计算机网络复习提升"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-16</div><div class="title">计算机网络复习提升</div></div></a></div><div><a href="/2023/02/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" title="面试题整理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-27</div><div class="title">面试题整理</div></div></a></div><div><a href="/2023/04/10/%E7%AE%97%E6%B3%95%E7%AF%87-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/" title="算法篇-二分搜索"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-10</div><div class="title">算法篇-二分搜索</div></div></a></div><div><a href="/2023/04/11/%E7%AE%97%E6%B3%95%E7%AF%87-%E5%8F%8C%E6%8C%87%E9%92%88/" title="算法篇-双指针"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">算法篇-双指针</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">一、概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">1、什么是操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">1.1、操作系统的架层次结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">1.2、操作系统的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-text">1.3、操作系统的特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">2、为什么学习操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9C%80%E8%A6%81%E6%9D%83%E8%A1%A1"><span class="toc-text">2.1、操作系统需要权衡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B"><span class="toc-text">3、操作系统实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-text">4、操作系统的发展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">5、操作系统的结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">二、操作系统的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%90%AF%E5%8A%A8%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">1、启动、中断、异常和系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E3%80%81%E5%90%AF%E5%8A%A8"><span class="toc-text">1.1、启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">1.2、中断、异常和系统调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0"><span class="toc-text">3、信号量实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%AE%A1%E7%A8%8B"><span class="toc-text">4、管程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-text">5、经典同步问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">读写者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-text">哲学家就餐问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%AD%BB%E9%94%81"><span class="toc-text">十一、死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-text">1、死锁问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B"><span class="toc-text">2、系统模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-text">可重复使用的资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%B5%84%E6%BA%90"><span class="toc-text">使用资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="toc-text">资源分配图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%AD%BB%E9%94%81%E7%89%B9%E5%BE%81"><span class="toc-text">3、死锁特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-text">4、死锁处理方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1%E3%80%81Deadlock-Prevention-%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="toc-text">4.1、Deadlock Prevention 死锁预防</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2%E3%80%81Deadlock-Avoidance-%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-text">4.2、Deadlock Avoidance 死锁避免</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-text">银行家算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3%E3%80%81Deadlock-Detection-%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-text">4.3、Deadlock Detection 死锁检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4%E3%80%81Recovery-from-Deadlock-%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D"><span class="toc-text">4.4、Recovery from Deadlock 死锁恢复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">十二、进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">1、概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B"><span class="toc-text">通信模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%8F%8A%E9%97%B4%E6%8E%A5%E9%80%9A%E4%BF%A1"><span class="toc-text">直接及间接通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">阻塞与非阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E9%93%BE%E8%B7%AF%E7%BC%93%E5%86%B2"><span class="toc-text">通信链路缓冲</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-text">2、信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%AE%A1%E9%81%93"><span class="toc-text">3、管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">4、消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-text">5、共享内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E6%96%87%E4%BB%B6"><span class="toc-text">十三、文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1、基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E6%96%87%E4%BB%B6"><span class="toc-text">1.1、文件系统和文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">1.2、文件描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E3%80%81%E7%9B%AE%E5%BD%95"><span class="toc-text">1.3、目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4%E3%80%81%E6%96%87%E4%BB%B6%E5%88%AB%E5%90%8D"><span class="toc-text">1.4、文件别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%8D%E7%B1%BB"><span class="toc-text">1.5、文件系统种类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">2、虚拟文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%95%B0%E6%8D%AE%E5%9D%97%E7%BC%93%E5%AD%98"><span class="toc-text">3、数据块缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">4、打开文件的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D"><span class="toc-text">5、文件分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">文件分配方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E5%88%97%E8%A1%A8"><span class="toc-text">6、空闲空间列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%A4%9A%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86-RAID"><span class="toc-text">7、多磁盘管理 - RAID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6"><span class="toc-text">8、磁盘调度</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Huang RD</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>