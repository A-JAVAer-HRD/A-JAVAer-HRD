<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>算法总结 | Huang Blog</title><meta name="author" content="Huang RD"><meta name="copyright" content="Huang RD"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="部分来源于： 力扣Krahets，链接：https:&#x2F;&#x2F;leetcode.cn&#x2F;leetbook&#x2F;read&#x2F;illustration-of-algorithm&#x2F;5dj09d&#x2F; 代码随想录  算法总结一、二分搜索Binary Search 对于已经有序的数组，使用二分搜索加快搜索速度。 时间复杂度O(logN) 二分法的两种写法：  左闭右闭[left,right] 左闭右开[left,right">
<meta property="og:type" content="article">
<meta property="og:title" content="算法总结">
<meta property="og:url" content="http://www.haungrd.top/2022/12/26/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Huang Blog">
<meta property="og:description" content="部分来源于： 力扣Krahets，链接：https:&#x2F;&#x2F;leetcode.cn&#x2F;leetbook&#x2F;read&#x2F;illustration-of-algorithm&#x2F;5dj09d&#x2F; 代码随想录  算法总结一、二分搜索Binary Search 对于已经有序的数组，使用二分搜索加快搜索速度。 时间复杂度O(logN) 二分法的两种写法：  左闭右闭[left,right] 左闭右开[left,right">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.huangrd.top/images/agentina/14.jpg">
<meta property="article:published_time" content="2022-12-26T04:12:57.000Z">
<meta property="article:modified_time" content="2022-12-26T07:25:54.039Z">
<meta property="article:author" content="Huang RD">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="计算机基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.huangrd.top/images/agentina/14.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.haungrd.top/2022/12/26/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"��","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-26 15:25:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://getwallpapers.com/wallpaper/full/a/1/8/1057222-free-download-cool-nature-backgrounds-1920x1200-windows-10.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> ���类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清���</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> �����</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> ���链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关��</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.huangrd.top/images/agentina/14.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Huang Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> ���类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清���</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> �����</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> ���链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关��</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-26T04:12:57.000Z" title="发表于 2022-12-26 12:12:57">2022-12-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-26T07:25:54.039Z" title="更新于 2022-12-26 15:25:54">2022-12-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">75k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>292分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>部分来源于：</p>
<p>力扣Krahets，链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/5dj09d/">https://leetcode.cn/leetbook/read/illustration-of-algorithm/5dj09d/</a></p>
<p>代码随想录</p>
</blockquote>
<h1 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h1><h2 id="一、二分搜索"><a href="#一、二分搜索" class="headerlink" title="一、二分搜索"></a>一、二分搜索</h2><p>Binary Search</p>
<p>对于已经有序的数组，使用二分搜索加快搜索速度。</p>
<p>时间复杂度O(logN)</p>
<p>二分法的两种写法：</p>
<ul>
<li>左闭右闭[left,right]</li>
<li>左闭右开[left,right)</li>
</ul>
<h3 id="1-1、左闭右闭"><a href="#1-1、左闭右闭" class="headerlink" title="1.1、左闭右闭"></a>1.1、左闭右闭</h3><p> target 是在一个在左闭右闭的区间里，[left, right] 。</p>
<p>对于左闭右闭的写法：</p>
<ul>
<li>while (left &lt;&#x3D; right) 要使用 &lt;&#x3D; ，因为left &#x3D;&#x3D; right是有意义的，所以使用 &lt;&#x3D;</li>
<li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210311153055723.jpg" alt="704.二分查找" style="zoom:100%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 左闭右闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch1</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;<span class="comment">//区间[left，right]要有意义</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;<span class="comment">//注意点1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) / <span class="number">2</span>);<span class="comment">//防止溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2、左闭右开"><a href="#1-2、左闭右开" class="headerlink" title="1.2、左闭右开"></a>1.2、左闭右开</h3><p>定义 target 是在一个在左闭右开的区间里，也就是[left, right)。</p>
<p>对于左闭右开的写法：</p>
<ul>
<li>while (left &lt; right)，这里使用 &lt; ,因为left &#x3D;&#x3D; right在区间[left, right)是没有意义的</li>
<li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210311153123632.jpg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 左闭右开</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch2</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;<span class="comment">//区间[left,right)</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;<span class="comment">//左闭</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;<span class="comment">//右开</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3、LC69-x-的平方根"><a href="#1-3、LC69-x-的平方根" class="headerlink" title="1.3、LC69 x 的平方根"></a>1.3、LC69 x 的平方根</h3><p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。</p>
<p>由于返回类型是整数，结果只保留 <strong>整数部分</strong> ，小数部分将被 <strong>舍去 。</strong></p>
<p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p>
<p>利用二分法的思路，在0~x-1中搜索出他的平方根，排除特例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找</span></span><br><span class="line"><span class="comment">     * [left,right)</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">//因为定义的区间为左闭右开，对于x，当x &lt; 2的时候，x才会取0 or x 即 0 1</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> x;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (mid &gt; x / mid) &#123;</span><br><span class="line">            <span class="comment">//mid &gt; x / mid防止溢出</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &lt; x / mid) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4、LC367-有效的完全平方数"><a href="#1-4、LC367-有效的完全平方数" class="headerlink" title="1.4、LC367 有效的完全平方数"></a>1.4、LC367 有效的完全平方数</h3><p>给定一个 <strong>正整数</strong> <code>num</code> ，编写一个函数，如果 <code>num</code> 是一个完全平方数，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p><strong>进阶：不要</strong> 使用任何内置的库函数，如 <code>sqrt</code> 。</p>
<p>防止越界，用long表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 二分法</span></span><br><span class="line"><span class="comment">* [left,right]左闭右闭</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> num;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) / <span class="number">2</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">square</span> <span class="operator">=</span> (<span class="type">long</span>) mid * mid;</span><br><span class="line">        <span class="keyword">if</span> (square &gt; num) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (square &lt; num) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、双指针法"><a href="#二、双指针法" class="headerlink" title="二、双指针法"></a>二、双指针法</h2><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>
<p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p>
<h3 id="2-1、移除数组元素"><a href="#2-1、移除数组元素" class="headerlink" title="2.1、移除数组元素"></a>2.1、移除数组元素</h3><p>定义快慢指针</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tva1.sinaimg.cn/large/008eGmZEly1gntrds6r59g30du09mnpd.gif" alt="27.移除元素-双指针法"></p>
<h3 id="2-2、LC11-盛最多水的容器"><a href="#2-2、LC11-盛最多水的容器" class="headerlink" title="2.2、LC11. 盛最多水的容器"></a>2.2、LC11. 盛最多水的容器</h3><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p><strong>说明：</strong>你不能倾斜容器。</p>
<p><strong>示例 1：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>面积：高*宽 min(height[left], height[right]) * (right - left)</p>
<ol>
<li><p>初始化两个指针指向两个边，这个时候宽是最大的。</p>
</li>
<li><p>当两个边向内缩小的时候,如果高是增大的话，才有可能会增大，如果高是减小的就不能增大。</p>
</li>
<li><p>因此在缩小的时候，让高尽可能变大，即缩小高小的一边。相等的话，任意。（有可能存在山峰的形状）</p>
</li>
<li><p>这样保证了在每一次选择时都是选择最大的，在遍历过程中用result记录最大值返回。</p>
</li>
</ol>
<p>只进行了一次遍历。<br>时间复杂度O(N)<br>空间复杂度O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双指针</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (Math.min(height[left], height[right]) * (right - left));</span><br><span class="line">            result = Math.max(sum, result);</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3、LC141-环形链表"><a href="#2-3、LC141-环形链表" class="headerlink" title="2.3、LC141. 环形链表"></a>2.3、LC141. 环形链表</h3><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p>
<p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 104]</code></li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>
</ul>
<p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p>
<p>判断链表有没有环</p>
<ol>
<li>定义快慢指针，快指针每次走两步，慢指针每次走一步。</li>
<li>如果快指针先到达了null证明没有环。</li>
<li>如果慢指针追上快指针，则说明有环。</li>
<li>当快慢指针相遇后，让快指针开始每次走一步，慢指针回到原点，再次让他们相遇就是环的入口节</li>
<li><ol start="5">
<li>数学证明</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双指针</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4、LC142-环形链表II"><a href="#2-4、LC142-环形链表II" class="headerlink" title="2.4、LC142. 环形链表II"></a>2.4、LC142. 环形链表II</h3><p>给定一个链表的头节点 <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210181732061.png" alt="image-20221018173023802" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123; <span class="comment">//有环</span></span><br><span class="line">            slow = head;</span><br><span class="line">            <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5、剑指-Offer-18-删除链表的节点"><a href="#2-5、剑指-Offer-18-删除链表的节点" class="headerlink" title="2.5、剑指 Offer 18. 删除链表的节点"></a>2.5、剑指 Offer 18. 删除链表的节点</h3><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p><strong>注意：</strong>此题对比原题有改动</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], val = 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [4,5,1,9], val = 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong></p>
<ul>
<li>题目保证链表中节点的值互不相同</li>
<li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li>
</ul>
<p>Related Topics</p>
<p>链表</p>
<p>👍 268</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>本题删除值为 val 的节点分需为两步：定位节点、修改引用。</p>
<ol>
<li>定位节点： 遍历链表，直到 head.val &#x3D;&#x3D; val 时跳出，即可定位目标节点。</li>
<li>修改引用： 设节点 cur 的前驱节点为 pre ，后继节点为 cur.next ；则执行 pre.next &#x3D; cur.next ，即可实现删除 cur 节点。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1613757478-NBOvjn-Picture1.png" alt="Picture1.png"></p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>特例处理： 当应删除头节点 head 时，直接返回 head.next 即可。</li>
<li>初始化： pre &#x3D; head , cur &#x3D; head.next 。</li>
<li>定位节点： 当 cur 为空 或 cur 节点值等于 val 时跳出。<ol>
<li>保存当前节点索引，即 pre &#x3D; cur 。</li>
<li>遍历下一节点，即 cur &#x3D; cur.next 。</li>
</ol>
</li>
<li>删除节点： 若 cur 指向某节点，则执行 pre.next &#x3D; cur.next ；若 cur 指向 null ，代表链表中不包含值为 val 的节点。</li>
<li>返回值： 返回链表头部节点 head 即可。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599417705-nRNZwN-Picture5.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 只能删除一个节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span>(head.val == val) <span class="keyword">return</span> head.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head, cur = head.next;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span> &amp;&amp; cur.val != val) &#123;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur != <span class="literal">null</span>) pre.next = cur.next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 可以删多个节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.val == val) &#123; <span class="comment">// 处理头节点</span></span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        <span class="keyword">if</span> (next.val == val) &#123;</span><br><span class="line">            cur.next = next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N) ： N 为链表长度，删除操作平均需循环 N&#x2F;2 次，最差 N 次。</li>
<li>空间复杂度 O(1) ： cur, pre 占用常数大小额外空间。</li>
</ul>
<h3 id="2-6、剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#2-6、剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="2.6、剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a>2.6、剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= nums.length &lt;= 50000</code></li>
<li><code>0 &lt;= nums[i] &lt;= 10000</code></li>
</ol>
<p>Related Topics</p>
<p>数组</p>
<p>双指针</p>
<p>排序</p>
<p>👍 268</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>考虑定义双指针 i , j 分列数组左右两端，循环执行：</p>
<ol>
<li>指针 i 从左向右寻找偶数；</li>
<li>指针 j 从右向左寻找奇数；</li>
<li>将 偶数 nums[i] 和 奇数 nums[j] 交换。</li>
</ol>
<p>可始终保证： 指针 i 左边都是奇数，指针 j 右边都是偶数 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/43e965485da89efa688947bc108232f10b65b5ba5c0dbd6a68227a82c7e451e4-Picture1.png" alt="Picture1.png"></p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>初始化： i , j 双指针，分别指向数组 nums 左右两端；</li>
<li>循环交换： 当 i &#x3D; j 时跳出；<ol>
<li>指针 i 遇到奇数则执行 i &#x3D; i + 1 跳过，直到找到偶数；</li>
<li>指针 j 遇到偶数则执行 j &#x3D; j - 1 跳过，直到找到奇数；</li>
<li>交换 nums[i] 和 nums[j] 值；</li>
</ol>
</li>
<li>返回值： 返回已修改的 nums 数组。</li>
</ol>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N ： N 为数组 nums 长度，双指针 i, j 共同遍历整个数组。</li>
<li>空间复杂度 O(1) ： 双指针 i, j 使用常数大小的额外空间。</li>
</ul>
<p><em>x</em>&amp;1 位运算 等价于 x*%2 取余运算，即皆可用于判断数字奇偶性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>, tmp;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; (nums[i] &amp; <span class="number">1</span>) == <span class="number">1</span>) i++; <span class="comment">// 找不是奇数</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; (nums[j] &amp; <span class="number">1</span>) == <span class="number">0</span>) j--; <span class="comment">// 找不是偶数</span></span><br><span class="line">            tmp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-7、剑指-Offer-22-链表中倒数第-k-个节点"><a href="#2-7、剑指-Offer-22-链表中倒数第-k-个节点" class="headerlink" title="2.7、剑指 Offer 22. 链表中倒数第 k 个节点"></a>2.7、剑指 Offer 22. 链表中倒数第 k 个节点</h3><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>
<p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<p>Related Topics</p>
<p>链表</p>
<p>双指针</p>
<p>👍 418</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：<br>第一时间想到的解法：</p>
<ol>
<li>先遍历统计链表长度，记为 len ；</li>
<li>设置一个指针走 (len-k) 步，即可找到链表倒数第 k 个节点；</li>
</ol>
<p>使用双指针则可以不用统计链表长度。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1600794523-AAMvoP-Picture1.png" alt="Picture1.png"></p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>初始化： 前指针 former 、后指针 latter ，双指针都指向头节点 head 。</li>
<li>构建双指针距离： 前指针 former 先向前走 k 步（结束后，双指针 former 和 latter 间相距 k 步）。</li>
<li>双指针共同移动： 循环中，双指针 former 和 latter 每轮都向前走一步，直至 former 走过链表 尾节点 时跳出（跳出后， latter 与尾节点距离为 k-1，即 latter 指向倒数第 k 个节点）。</li>
<li>返回值： 返回 latter 即可。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1600794523-NHOoqg-Picture8.png" alt="img"></p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N) ： N 为链表长度；总体看， former 走了 N 步， latter 走了 (N-k) 步。</li>
<li>空间复杂度 O(1) ： 双指针 former , latter 使用常数大小的额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">former</span> <span class="operator">=</span> head, latter = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            <span class="keyword">if</span>(former == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            former = former.next;</span><br><span class="line">        <span class="keyword">while</span>(former != <span class="literal">null</span>) &#123;</span><br><span class="line">            former = former.next;</span><br><span class="line">            latter = latter.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> latter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>code2:先统计链表长度，再遍历一次返回倒数第k个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">// 统计长度</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    len = len - k;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span> (len != <span class="number">0</span>) &#123;</span><br><span class="line">        len--;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-8、LC206-反转链表"><a href="#2-8、LC206-反转链表" class="headerlink" title="2.8、LC206. 反转链表"></a>2.8、LC206. 反转链表</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/rev1ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/rev1ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<p>Related Topics</p>
<p>递归</p>
<p>链表</p>
<p>👍 2890</p>
<p>👎 0</p>
<h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><ul>
<li>我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的。</li>
<li>第二个指针 cur 指向 head，然后不断遍历 cur。</li>
<li>每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。</li>
<li>都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。<br>动画演示如下：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/7d8712af4fbb870537607b1dd95d66c248eb178db4319919c32d9304ee85b602-%E8%BF%AD%E4%BB%A3.gif" alt="迭代.gif"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>, cur = head, next;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        next = cur.next; <span class="comment">// 记录当前节点的下一个节点</span></span><br><span class="line">        cur.next = pre; <span class="comment">// 然后将当前节点指向pre</span></span><br><span class="line">        <span class="comment">// pre和cur节点都前进一位</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度O(N)</li>
<li>空间复杂度O(1)</li>
</ul>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归的两个条件：</p>
<p>终止条件是当前节点或者下一个节点&#x3D;&#x3D;null<br>在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head.next.next = head</span><br></pre></td></tr></table></figure>

<p>很不好理解，其实就是 head 的下一个节点指向head。</p>
<p>递归函数中每次返回的 cur 其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。</p>
<p>动画演示如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif" alt="递归.gif"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">//递归终止条件是当前为空，或者下一个节点为空</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的cur就是最后一个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">    <span class="comment">//这里请配合动画演示理解</span></span><br><span class="line">    <span class="comment">//如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span></span><br><span class="line">    <span class="comment">//而head是4，head的下一个是5，下下一个是空</span></span><br><span class="line">    <span class="comment">//所以head.next.next 就是5-&gt;4</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    <span class="comment">//防止链表循环，需要将head.next设置为空</span></span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、滑动窗口"><a href="#三、滑动窗口" class="headerlink" title="三、滑动窗口"></a>三、滑动窗口</h2><p>滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p>
<p>在遍历一个数组的过程中：</p>
<p>在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环完成了一个不断搜索区间的过程。</p>
<p>那么滑动窗口如何用一个for循环来完成这个操作呢。</p>
<p>首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。</p>
<p>如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？此时难免再次陷入 暴力解法的怪圈。</p>
<p>所以只用一个for循环，那么<strong>这个循环的索引，一定是表示滑动窗口的终止位置。</strong></p>
<p>那么问题来了， 滑动窗口的起始位置如何移动呢？</p>
<p>这里还是以<code>长度最小的子数组</code>中的示例来举例，s&#x3D;7， 数组是 2，3，1，2，4，3，来看一下查找的过程：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="209.长度最小的子数组"></p>
<p>最后找到 4，3 是最短距离。</p>
<p>其实从动画中可以发现<strong>滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</strong></p>
<p>实现滑动窗口，主要确定如下三点：</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
<p><strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。</strong></p>
<p>滑动窗口题目:</p>
<ol start="3">
<li><p>无重复字符的最长子串</p>
</li>
<li><p>串联所有单词的子串</p>
</li>
<li><p>最小覆盖子串</p>
</li>
<li><p>至多包含两个不同字符的最长子串</p>
</li>
<li><p>长度最小的子数组</p>
</li>
<li><p>滑动窗口最大值</p>
</li>
<li><p>字符串的排列</p>
</li>
<li><p>最小区间</p>
</li>
<li><p>最小窗口子序列</p>
</li>
</ol>
<h3 id="3-1、LC209-长度最小的子数组"><a href="#3-1、LC209-长度最小的子数组" class="headerlink" title="3.1、LC209. 长度最小的子数组"></a>3.1、LC209. 长度最小的子数组</h3><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p>
<p>找出该数组中满足其和 <code>≥ target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= target &lt;= 109</code></li>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li>
</ul>
<p>在本题中实现滑动窗口，主要确定如下三点：</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
<p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p>
<p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p>
<p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</p>
<p>解题的关键在于 窗口的起始位置如何移动，如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210312160441942.png" alt="leetcode_209"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 滑动窗口</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//滑动窗口 for i遍历的是结束的位置 j是起始的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//滑动窗口的大小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123; <span class="comment">//窗口的大小大于要求的值 起始位置向前 缩窗口</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">subLength</span> <span class="operator">=</span> i - j + <span class="number">1</span>;</span><br><span class="line">                res = Math.min(subLength, res);</span><br><span class="line">                sum -= nums[j++];<span class="comment">//就相当于之前的和减去了起始位置的值 起始位置++</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res == Integer.MAX_VALUE) &#123; <span class="comment">//数组中的和不大于target</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2、LC904-水果成篮"><a href="#3-2、LC904-水果成篮" class="headerlink" title="3.2、LC904. 水果成篮"></a>3.2、LC904. 水果成篮</h3><p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 <code>fruits</code> 表示，其中 <code>fruits[i]</code> 是第 <code>i</code> 棵树上的水果 <strong>种类</strong> 。</p>
<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>
<ul>
<li>你只有 <strong>两个</strong> 篮子，并且每个篮子只能装 <strong>单一类型</strong> 的水果。每个篮子能够装的水果总量没有限制。</li>
<li>你可以选择任意一棵树开始采摘，你必须从 <strong>每棵</strong> 树（包括开始采摘的树）上 <strong>恰好摘一个水果</strong> 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</li>
<li>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</li>
</ul>
<p>给你一个整数数组 <code>fruits</code> ，返回你可以收集的水果的 <strong>最大</strong> 数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：fruits = [1,2,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘全部 3 棵树。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：fruits = [0,1,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘 [1,2,2] 这三棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：fruits = [1,2,3,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：可以采摘 [2,3,2,2] 这四棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：可以采摘 [1,2,1,1,2] 这五棵树。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= fruits.length &lt;= 105</code></li>
<li><code>0 &lt;= fruits[i] &lt; fruits.length</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 滑动窗口 + hashmap</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//返回的最多收集个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//起始位置</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);<span class="comment">//篮子</span></span><br><span class="line">        <span class="comment">//遍历终止位置i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fruits.length; i++) &#123;</span><br><span class="line">            map.put(fruits[i], map.getOrDefault(fruits[i], <span class="number">0</span>) + <span class="number">1</span>);<span class="comment">//利用map不含重复元素</span></span><br><span class="line">            <span class="keyword">while</span> (map.size() &gt; <span class="number">2</span>) &#123;<span class="comment">//当篮子数大于2时，缩短窗口</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(fruits[j]) - <span class="number">1</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(fruits[j]);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(fruits[j], map.get(fruits[j]) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">subLength</span> <span class="operator">=</span> i - j + <span class="number">1</span>;</span><br><span class="line">            res = Math.max(res, subLength);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>宫水三叶（数组带替map）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fs)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fs.length, res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//cnts用来统计每种水果树的数量</span></span><br><span class="line">    <span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">10</span>];</span><br><span class="line">    <span class="comment">//i是窗口的右边，j是左边，tot表示当前篮子里水果的种类（至多有两种水果），也表示窗口中的水果种类数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, tot = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        cnts[fs[i]]++;</span><br><span class="line">        <span class="keyword">if</span> (cnts[fs[i]] == <span class="number">1</span>) tot++;<span class="comment">//第一次出现 篮子的种类++</span></span><br><span class="line">        <span class="comment">//当种类数量大于2时，使窗口左侧收缩，并且除去对应的水果种类在cnts中的数量</span></span><br><span class="line">        <span class="comment">//当为0时则彻底在窗口中除去该种水果</span></span><br><span class="line">        <span class="keyword">while</span> (tot &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            cnts[fs[j]]--;<span class="comment">//缩窗口</span></span><br><span class="line">            <span class="keyword">if</span> (cnts[fs[j]] == <span class="number">0</span>) tot--;<span class="comment">//篮子种类数--</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//即时比较判断窗口中水果树的数量，经过前两步窗口中的东西一定是满足题义的</span></span><br><span class="line">        res = Math.max(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3、LC76-最小覆盖字串"><a href="#3-3、LC76-最小覆盖字串" class="headerlink" title="3.3、LC76. 最小覆盖字串"></a>3.3、LC76. 最小覆盖字串</h3><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>
<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 105</code></li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
<p><strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？</p>
<p>Related Topics</p>
<p>哈希表</p>
<p>字符串</p>
<p>滑动窗口</p>
<p><strong>解法思路：</strong></p>
<ol>
<li>创建两个map，分别表示需要的字符sonMap及其个数和当前的字符(只统计子串含有的字符)matherMap及其个数。</li>
<li>利用滑动窗口的思想，遍历右指针。</li>
<li>右指针遍历过的字符如果有要匹配的字符，加到map中去。统计已经匹配字符的计数器。</li>
<li>如果已经匹配上了，更新匹配的字串，把左指针开始右移，窗口收缩，更新matherMap的数据。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="comment">//两个map,一个存放需要的字符，一个存放当前的字符</span></span><br><span class="line">    Map&lt;Character, Integer&gt; sonMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Character, Integer&gt; matherMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历匹配的字串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">cur</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">        sonMap.put(cur, sonMap.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//起始</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//终止</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">finishCount</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//计数器</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> s.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">cur</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        <span class="keyword">if</span> (sonMap.containsKey(cur)) &#123; <span class="comment">//字串中需要这个字符</span></span><br><span class="line">            matherMap.put(cur, matherMap.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 两个Integer对象比较时，不能使用 == ，要使用equals，如果使用 == ，在[-128,127]范围内正常，范围外不正常</span></span><br><span class="line">            <span class="keyword">if</span> (sonMap.get(cur).equals(matherMap.get(cur))) &#123; <span class="comment">//一项已经匹配了</span></span><br><span class="line">                finishCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">//计数器满足要求，缩小窗口</span></span><br><span class="line">        <span class="keyword">while</span> (finishCount == sonMap.size()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">leftCur</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">            <span class="keyword">if</span> (matherMap.containsKey(leftCur) &amp;&amp; matherMap.get(leftCur) &gt;= sonMap.get(leftCur)) &#123;</span><br><span class="line">                <span class="comment">//记录满足条件的最小字串</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> s.substring(left, right);</span><br><span class="line">                <span class="keyword">if</span> (temp.length() &lt;= minLen) &#123;</span><br><span class="line">                    res = temp;</span><br><span class="line">                    minLen = temp.length();</span><br><span class="line">                &#125;</span><br><span class="line">                matherMap.put(leftCur, matherMap.get(leftCur) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (sonMap.get(leftCur) &gt; matherMap.get(leftCur)) &#123;</span><br><span class="line">                    finishCount--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4、LC3-无重复字符的最长子串"><a href="#3-4、LC3-无重复字符的最长子串" class="headerlink" title="3.4、LC3. 无重复字符的最长子串"></a>3.4、LC3. 无重复字符的最长子串</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<p>Related Topics</p>
<p>哈希表</p>
<p>字符串</p>
<p>滑动窗口</p>
<p>👍 8536</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>因为要找到不重复的字符最大长度，在窗口进行伸缩的判断中，有可能窗口里的元素与要扩字符的值相同，因此采用哈希表进行记录。哈希表记录的是字符与下标的对应关系，当遍历到一个新字符，就把他加入到哈希表中；当遍历到一个存在的字符，就对窗口的左边界进行收缩，并且更新字符对应的下标位置。</p>
<p><strong>算法流程</strong>：</p>
<ol>
<li><p>首先，判断当前字符是否包含在map中，如果不包含，将该字符添加到map（字符，字符在数组下标）, 此时没有出现重复的字符，左指针不需要变化。此时不重复子串的长度为：i - left + 1，与原来的 maxLen 比较，取最大值；</p>
</li>
<li><p>如果当前字符 ch 包含在 map中，此时有2类情况：</p>
<ol>
<li>当前字符包含在当前有效的子段中，如：abca，当我们遍历到第二个a，当前有效最长子段是 abc，我们又遍历到a，那么此时更新 left 为 map.get(a)+1&#x3D;1，当前有效子段更新为 bca；</li>
<li>当前字符不包含在当前最长有效子段中，如：abba，我们先添加a,b进map，此时left&#x3D;0，我们再添加b，发现map中包含b，而且b包含在最长有效子段中，就是1）的情况，我们更新 left&#x3D;map.get(b)+1&#x3D;2，此时子段更新为 b，而且map中仍然包含a，map.get(a)&#x3D;0；随后，我们遍历到a，发现a包含在map中，且map.get(a)&#x3D;0，如果我们像1）一样处理，就会发现 left&#x3D;map.get(a)+1&#x3D;1，实际上，left此时应该不变，left始终为2，子段变成 ba才对。</li>
</ol>
</li>
</ol>
<p>为了处理以上2类情况，我们每次更新left，left&#x3D;Math.max(left , map.get(ch)+1).<br>另外，更新left后，不管原来的 s.charAt(i) 是否在最长子段中，我们都要将 s.charAt(i) 的位置更新为当前的i，<br>因此此时新的 s.charAt(i) 已经进入到 当前最长的子段中！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//用于记录最大不重复子串的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//滑动窗口左指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i))) &#123;</span><br><span class="line">                left = Math.max(left , map.get(s.charAt(i))+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不管是否更新left，都要更新 s.charAt(i) 的位置！</span></span><br><span class="line">            map.put(s.charAt(i) , i);</span><br><span class="line">            maxLen = Math.max(maxLen , i-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、模拟"><a href="#四、模拟" class="headerlink" title="四、模拟"></a>四、模拟</h2><p>循环不变量：在循环过程中保持不变的性质。</p>
<h3 id="4-1、LC54-螺旋矩阵"><a href="#4-1、LC54-螺旋矩阵" class="headerlink" title="4.1、LC54. 螺旋矩阵"></a>4.1、LC54. 螺旋矩阵</h3><p>从外部向内部逐层遍历打印矩阵，最外面一圈打印完，里面仍然是一个矩阵</p>
<p>统计矩阵的层数，每一层最多会占据两行或者两列，最少会占据一行或者一列元素，只有一层或者一列，也算一层，分层如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/6936cb00971072cf40e96462e782aa47563fa4b24831d72749699c8fd9af7255-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5.JPG" alt="螺旋矩阵.JPG"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210261749987.jpeg" alt="螺旋矩阵1.JPG"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> (Math.min(m, n)+<span class="number">1</span>)/<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>左闭右闭</strong></p>
<p>开始打印第 <code>i</code> 层的矩阵元素</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/a2e0022203893856ec9baa3fa3db6b0b1e6e49b4f3955e086f437852ec88a31d-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B52.JPG" alt="螺旋矩阵2.JPG"></p>
<p>如上图所示，再打印第i层的矩阵时，要经历4个循环：</p>
<p>第 1 个：从左向右</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int j = i; j &lt; n-i; j++) &#123;</span><br><span class="line">    list.add(matrix[i][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 2 个：从上往下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int j = i+1; j &lt; m-i; j++) &#123;</span><br><span class="line">    list.add(matrix[j][(n-1)-i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 3 个：从右往左，如果这一层只有1行，那么第一个循环已经将该行打印了，这里就不需要打印了，即 <code>（m-1-i ）!= i</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int j = (n-1)-(i+1); j &gt;= i &amp;&amp; (m-1-i != i); j--) &#123;</span><br><span class="line">    list.add(matrix[(m-1)-i][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第4个：从下往上，如果这一层只有1列，那么第2个循环已经将该列打印了，这里不需要打印，即<code>(n-1-i) != i</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int j = (m-1)-(i+1); j &gt;= i+1 &amp;&amp; (n-1-i) != i; j--) &#123;</span><br><span class="line">    list.add(matrix[j][i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="comment">//保持左闭右开</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//循环的次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">//统计矩阵从外向内的层数，如果矩阵非空，那么它的层数至少为1层</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> (Math.min(m, n)+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; count) &#123;</span><br><span class="line">        <span class="comment">//上侧 左.右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n - i; j++) &#123;</span><br><span class="line">            res.add(matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右侧 上.下</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; m - i; j++) &#123;</span><br><span class="line">            res.add(matrix[j][(n - <span class="number">1</span>) - i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下册 右.左</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (n - <span class="number">1</span>) - (i + <span class="number">1</span>); j &gt;= i &amp;&amp; (m - <span class="number">1</span> - i != i); j--) &#123;</span><br><span class="line">            res.add(matrix[(m - <span class="number">1</span>) - i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左侧 下.上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (m - <span class="number">1</span>) - (i + <span class="number">1</span>); j &gt;= i + <span class="number">1</span> &amp;&amp; (n - <span class="number">1</span> - i) != i; j--) &#123;</span><br><span class="line">            res.add(matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2、LC59-螺旋矩阵II"><a href="#4-2、LC59-螺旋矩阵II" class="headerlink" title="4.2、LC59. 螺旋矩阵II"></a>4.2、LC59. 螺旋矩阵II</h3><ul>
<li>填充上行从左到右</li>
<li>填充右列从上到下</li>
<li>填充下行从右到左</li>
<li>填充左列从下到上</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922102236.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//控制循环次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//每一次开始的点(start,start)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//填充的数字</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (loop++ &lt; n / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 模拟上侧从左到右</span></span><br><span class="line">        <span class="keyword">for</span> (j = start; j &lt; n - loop; j++) &#123;</span><br><span class="line">            res[start][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟右侧从上到下</span></span><br><span class="line">        <span class="keyword">for</span> (i = start; i &lt; n - loop; i++) &#123;</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟下侧从右到左</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= loop; j--) &#123;</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟左侧从下到上</span></span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= loop; i--) &#123;</span><br><span class="line">            res[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123; <span class="comment">//中间位置</span></span><br><span class="line">        res[start][start] = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3、剑指Offer29-顺时针打印矩阵"><a href="#4-3、剑指Offer29-顺时针打印矩阵" class="headerlink" title="4.3、剑指Offer29. 顺时针打印矩阵"></a>4.3、剑指Offer29. 顺时针打印矩阵</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= matrix.length &lt;= 100</code></li>
<li><code>0 &lt;= matrix[i].length &lt;= 100</code></li>
</ul>
<p>注意：本题与主站 54 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix/">https://leetcode-cn.com/problems/spiral-matrix/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] spiralOrder(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//控制循环圈数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> (Math.min(m, n) + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; loop) &#123;</span><br><span class="line">        <span class="comment">//上 从左到右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n - i; j++) &#123;</span><br><span class="line">            res.add(matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右 从上到下</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; m - i; j++) &#123;</span><br><span class="line">            res.add(matrix[j][(n - <span class="number">1</span>) - i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下 从右到左</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span> - i - <span class="number">1</span>; j &gt;= i &amp;&amp; m - <span class="number">1</span> - i != i; j--) &#123;</span><br><span class="line">            res.add(matrix[(m - <span class="number">1</span> - i)][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左 从下到上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m - <span class="number">1</span> - <span class="number">1</span> - i; j &gt;= i + <span class="number">1</span> &amp;&amp; n - <span class="number">1</span> - i != i; j--) &#123;</span><br><span class="line">            res.add(matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解题思路</strong>：</p>
<p>根据题目示例 matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]] 的对应输出 [1,2,3,6,9,8,7,4,5] 可以发现，顺时针打印矩阵的顺序是 “<strong>从左向右、从上向下、从右向左、从下向上</strong>” 循环。</p>
<p>因此，考虑设定矩阵的 “左、上、右、下” 四个边界，模拟以上矩阵遍历顺序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/7605d807782923e4ad3c7995dc2485f538f202ac326bb330fe997f449123a548-Picture1.png" alt="Picture1.png"></p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>空值处理： 当 matrix 为空时，直接返回空列表 [] 即可。</li>
<li>初始化： 矩阵 左、右、上、下 四个边界 l , r , t , b ，用于打印的结果列表 res 。</li>
<li>循环打印： “从左向右、从上向下、从右向左、从下向上” 四个方向循环打印；<ol>
<li>根据边界打印，即将元素按顺序添加至列表 res 尾部；</li>
<li>边界向内收缩 1 （代表已被打印）；</li>
<li>判断边界是否相遇（是否打印完毕），若打印完毕则跳出。</li>
</ol>
</li>
<li>返回值： 返回 res 即可。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221221141406885.png" alt="image-20221221141406885"></p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(MN) ： M, N 分别为矩阵行数和列数。</li>
<li>空间复杂度 O(1) ： 四个边界 l , r , t , b 使用常数大小的额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] spiralOrder(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[(r + <span class="number">1</span>) * (b + <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) res[x++] = matrix[t][i]; <span class="comment">// left to right</span></span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t; i &lt;= b; i++) res[x++] = matrix[i][r]; <span class="comment">// top to bottom</span></span><br><span class="line">            <span class="keyword">if</span>(l &gt; --r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r; i &gt;= l; i--) res[x++] = matrix[b][i]; <span class="comment">// right to left</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt; --b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b; i &gt;= t; i--) res[x++] = matrix[i][l]; <span class="comment">// bottom to top</span></span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4、剑指-Offer-31-栈的压入、弹出序列"><a href="#4-4、剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="4.4、剑指 Offer 31. 栈的压入、弹出序列"></a>4.4、剑指 Offer 31. 栈的压入、弹出序列</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li>
<li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li>
<li><code>pushed</code> 是 <code>popped</code> 的排列。</li>
</ol>
<p>注意：本题与主站 946 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-stack-sequences/">https://leetcode-cn.com/problems/validate-stack-sequences/</a></p>
<p>Related Topics</p>
<p>栈</p>
<p>数组</p>
<p>模拟</p>
<p>👍 395</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>如下图所示，给定一个压入序列 pushed 和弹出序列 popped ，则压入 &#x2F; 弹出操作的顺序（即排列）是 唯一确定 的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1188474dc6a377fc258004bca84e5a130b663eeb24bf22c4fa4eb998a0249f97-Picture1.png" alt="Picture1.png"></p>
<p>如下图所示，栈的数据操作具有 <strong>先入后出</strong> 的特性，因此某些弹出序列是无法实现的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/3f43b224553bf3a37f9758dbb41655e547795e293524a148380c6f335af315e4-Picture2.png" alt="Picture2.png"></p>
<p>考虑借用一个辅助栈 stack ，<strong>模拟</strong> 压入 &#x2F; 弹出操作的排列。根据是否模拟成功，即可得到结果。</p>
<ul>
<li>入栈操作： 按照压栈序列的顺序执行。</li>
<li>出栈操作： 每次入栈后，循环判断 “栈顶元素 &#x3D;&#x3D; 弹出序列的当前元素” 是否成立，将符合弹出序列顺序的栈顶元素全部弹出。</li>
</ul>
<blockquote>
<p>由于题目规定 栈的所有数字均不相等 ，因此在循环入栈中，每个元素出栈的位置的可能性是唯一的（若有重复数字，则具有多个可出栈的位置）。因而，在遇到 “栈顶元素 &#x3D;&#x3D; 弹出序列的当前元素” 就应立即执行出栈。</p>
</blockquote>
<p><strong>算法流程</strong>：</p>
<ol>
<li>初始化： 辅助栈 stack ，弹出序列的索引 i ；</li>
<li>遍历压栈序列： 各元素记为 num ；<ol>
<li>元素 num 入栈；</li>
<li>循环出栈：若 stack 的栈顶元素 &#x3D;&#x3D; 弹出序列元素 popped[i] ，则执行出栈与 i++ ；</li>
</ol>
</li>
<li>返回值： 若 stack 为空，则此弹出序列合法。</li>
</ol>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N) ： 其中 N 为列表 pushed 的长度；每个元素最多入栈与出栈一次，即最多共 2N 次出入栈操作。</li>
<li>空间复杂度 O(N) ： 辅助栈 stack 最多同时存储 N 个元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : pushed) &#123;</span><br><span class="line">        stack.push(num); <span class="comment">// 模拟入栈</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[i]) &#123; <span class="comment">// 循环判断 出栈</span></span><br><span class="line">            stack.pop();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="五、数据结构篇"><a href="#五、数据结构篇" class="headerlink" title="五、数据结构篇"></a>五、数据结构篇</h2><h3 id="5-1、剑指-Offer05-替换空格"><a href="#5-1、剑指-Offer05-替换空格" class="headerlink" title="5.1、剑指 Offer05. 替换空格"></a>5.1、剑指 Offer05. 替换空格</h3><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= s 的长度 &lt;= 10000</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">//StringBuilder 单线程使用，比较快</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2、剑指-Offer-06-从尾到头打印链表"><a href="#5-2、剑指-Offer-06-从尾到头打印链表" class="headerlink" title="5.2、剑指 Offer 06. 从尾到头打印链表"></a>5.2、剑指 Offer 06. 从尾到头打印链表</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 链表长度 &lt;= 10000</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        res[count--] = cur.val;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] reversePrint2(ListNode head) &#123;</span><br><span class="line">    Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack.push(temp);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        res[i] = stack.pop().val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3、剑指-Offer-09-用两个栈实现队列"><a href="#5-3、剑指-Offer-09-用两个栈实现队列" class="headerlink" title="5.3、剑指 Offer 09. 用两个栈实现队列"></a>5.3、剑指 Offer 09. 用两个栈实现队列</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[],[]]</span><br><span class="line">输出：[null,null,3,-1,-1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= values &lt;= 10000</code></li>
<li>最多会对<code>appendTail、deleteHead</code>进行<code> 10000</code> 次调用</li>
</ul>
<p>Related Topics</p>
<p>栈</p>
<p>设计</p>
<p>队列</p>
<h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>A栈用来保持原有数据，B栈用来输出数据时对栈逆序，在B中输出队头之后再放入A栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> stack1.pop();</span><br><span class="line">                stack2.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> stack2.pop();</span><br><span class="line">            <span class="keyword">while</span> (!stack2.isEmpty()) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> stack2.pop();</span><br><span class="line">                stack1.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1599286207-HnnMhX-Picture1.png" alt="Picture1.png"></p>
<p>对思路一进行优化，当B栈输出完对头时不再重新放入A栈，而是保留，因为是顺序加入的，他会保留原有的顺序。</p>
<p>题目要求实现 加入队尾appendTail() 和 删除队首deleteHead() 两个函数的正常工作。因此，可以设计栈 A 用于加入队尾操作，栈 B 用于将元素倒序，从而实现删除队首元素。</p>
<p>函数设计：</p>
<ol>
<li>加入队尾 appendTail() ： 将数字 val 加入栈 A 即可。</li>
<li>删除队首deleteHead() ： 有以下三种情况。<ul>
<li>当栈 B 不为空： B中仍有已完成倒序的元素，因此直接返回 B 的栈顶元素。</li>
<li>否则，当 A 为空： 即两个栈都为空，无元素，因此返回 -1 。</li>
<li>否则： 将栈 A 元素全部转移至栈 B 中，实现元素倒序，并返回栈 B 的栈顶元素。</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1599286207-iyRyBk-Picture2.png" alt="img"></p>
<p>复杂度分析：</p>
<blockquote>
<p>以下分析仅满足添加 N 个元素并删除 N 个元素，即栈初始和结束状态下都为空的情况。</p>
</blockquote>
<ul>
<li>时间复杂度： appendTail()函数为O(1) ；deleteHead() 函数在 N 次队首元素删除操作中总共需完成 N 个元素的倒序。</li>
<li>空间复杂度 O(N)O(N) ： 最差情况下，栈 A 和 B 共保存 NN 个元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stack2.isEmpty()) &#123; <span class="comment">// 情况一B栈不空</span></span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack1.isEmpty()) &#123; <span class="comment">// 情况二AB都为空</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 情况三A不为空 B为空</span></span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4、剑指-Offer-24-反转链表"><a href="#5-4、剑指-Offer-24-反转链表" class="headerlink" title="5.4、剑指 Offer 24. 反转链表"></a>5.4、剑指 Offer 24. 反转链表</h3><p>给定单链表的头节点 <code>head</code> ，请反转链表，并返回反转后的链表的头节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>双指针</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1604779288-jExDGV-Picture3.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代：双指针</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head, pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;<span class="comment">// 暂存后继节点 cur.next</span></span><br><span class="line">        cur.next = pre;<span class="comment">// 修改 next 引用指向</span></span><br><span class="line">        pre = cur;<span class="comment">// pre 暂存 cur</span></span><br><span class="line">        cur = temp; <span class="comment">// cur 访问下一节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代：利用栈</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (newHead != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack.push(newHead);</span><br><span class="line">        newHead = newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head = stack.pop();</span><br><span class="line">    newHead = head;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        newHead.next = stack.pop();</span><br><span class="line">        newHead = newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    newHead.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><p>考虑使用递归法遍历链表，当越过尾节点后终止递归，在回溯时修改各节点的 next 引用指向。</p>
<p><strong>recur(cur, pre) 递归函数：</strong></p>
<ol>
<li>终止条件：当 cur 为空，则返回尾节点 pre （即反转链表的头节点）；</li>
<li>递归后继节点，记录返回值（即反转链表的头节点）为 res ；</li>
<li>修改当前节点 cur 引用指向前驱节点 pre ；</li>
<li>返回反转链表的头节点 res ；</li>
</ol>
<p><strong>reverseList(head) 函数：</strong><br>调用并返回 recur(head, null) 。传入 null 是因为反转链表后， head 节点指向 null ；</p>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度 O(N)O(N) ： 遍历链表使用线性大小时间。</li>
<li>空间复杂度 O(N)O(N) ： 遍历链表的递归深度达到 NN ，系统使用 O(N)O(N) 大小额外空间。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1604779700-APVBqI-Picture24.png" alt="img"></p>
<h3 id="5-5、剑指-Offer-30-包含-min-函数的栈"><a href="#5-5、剑指-Offer-30-包含-min-函数的栈" class="headerlink" title="5.5、剑指 Offer 30. 包含 min 函数的栈"></a>5.5、剑指 Offer 30. 包含 min 函数的栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> recur(head,<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">recur</span><span class="params">(ListNode cur, ListNode pre)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123; <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> recur(cur.next, cur);<span class="comment">//递归后续节点</span></span><br><span class="line"></span><br><span class="line">    cur.next = pre;              <span class="comment">// 修改节点引用指向</span></span><br><span class="line">    <span class="keyword">return</span> res;                  <span class="comment">// 返回反转链表的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   -. 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      -. 返回 0.</span><br><span class="line">minStack.min();   -. 返回 -2.</span><br></pre></td></tr></table></figure>



<p><strong>解题思路:</strong><br>普通栈的 push() 和 pop() 函数的复杂度 O(1) ；而获取栈最小值 min() 函数需要遍历整个栈，复杂度为 O(N) 。</p>
<p><strong>本题难点：</strong> 将 min() 函数复杂度降为&#x3D;O(1) 。可借助辅助栈实现：</p>
<ul>
<li>数据栈 A ： 栈 A 用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常辑。</li>
<li>辅助栈 B ： 栈 B 中存储栈 A 中所有 非严格降序 元素的子序列，则栈 A 中的最小元素始终对应栈 B 的栈顶元素.此时， min() 函数只需返回栈 B 的栈顶元素即可。</li>
</ul>
<p>因此，只需设法维护好 栈 B 的元素，使其保持是栈 A 的非严格降序元素的子序列，即可实现 min() 函数的 O(1) 复杂度。</p>
<p><strong>函数设计：</strong><br>push(x) 函数： 重点为保持栈 B 的元素是 <strong>非严格降序</strong> 的；</p>
<ol>
<li>执行「元素 x 压入栈 A」 ；</li>
<li>若「栈 B 为空」或「x \leq≤ 栈 B 的栈顶元素」，则执行「元素 x 压入栈 B」 ；</li>
</ol>
<p>pop() 函数： 重点为保持栈 A , B 的 元素一致性 ；</p>
<ol>
<li>执行「栈 A 元素出栈」，将出栈元素记为 y ；</li>
<li>若 「y 等于栈 B 的栈顶元素」，则执行「栈 B 元素出栈」；</li>
</ol>
<p>top() 函数： 直接返回栈 A 的栈顶元素，即返回 A.peek() ；</p>
<p>min() 函数： 直接返回栈 B 的栈顶元素，即返回 B.peek() ；</p>
<p><strong>采用 “非严格” 降序原因</strong>：<br>在栈 A 具有 重复 最小值元素时，非严格降序可防止栈 B 提前弹出最小值元素，示例如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1600086305-BSfBJu-Picture2.png" alt="Picture2.png"></p>
<p><strong>复杂度分析：</strong><br>时间复杂度 O(1) ： push(), pop(), top(), min() 四个函数的时间复杂度均为常数级别。<br>空间复杂度 O(N) ： 当共有 N 个待入栈元素时，辅助栈 B 最差情况下存储 N 个元素，使用 O(N) 额外空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1;<span class="comment">//正常的栈序列</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2;<span class="comment">//对于A栈的元素，B栈保证数据从小到大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty() || stack2.peek() &gt;= x) &#123; <span class="comment">// 小于栈顶才入栈</span></span><br><span class="line">            stack2.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> stack1.pop();</span><br><span class="line">        <span class="keyword">if</span> (i.equals(stack2.peek())) &#123;</span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-6、剑指-Offer-35-复杂链表的复制"><a href="#5-6、剑指-Offer-35-复杂链表的复制" class="headerlink" title="5.6、剑指 Offer 35. 复杂链表的复制"></a>5.6、剑指 Offer 35. 复杂链表的复制</h3><p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p>
<p><strong>示例 1：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><strong><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" alt="img"></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure>

<h4 id="哈希表记录法"><a href="#哈希表记录法" class="headerlink" title="哈希表记录法"></a>哈希表记录法</h4><p>利用哈希表的查询特点，考虑构建 原链表节点 和 新链表对应节点 的键值对映射关系，再遍历构建新链表各节点的 next 和 random 引用指向即可。</p>
<p><strong>算法流程：</strong></p>
<ol>
<li><p>若头节点 head 为空节点，直接返回 null ；</p>
</li>
<li><p>初始化： 哈希表 set ， 节点 cur 指向头节点；</p>
</li>
<li><p>复制链表：</p>
<ol>
<li>建立新节点，并向 set 添加键值对 (原 cur 节点, 新 cur 节点） ；</li>
<li>cur 遍历至原链表下一节点；</li>
</ol>
</li>
<li><p>构建新链表的引用指向：</p>
<ol>
<li>构建新节点的 next 和 random 引用指向；</li>
<li>cur 遍历至原链表下一节点；</li>
</ol>
</li>
<li><p>返回值： 新链表的头节点 map.get(head) ；</p>
</li>
</ol>
<p><strong>复杂度分析：</strong><br>时间复杂度 O(N) ： 两轮遍历链表，使用 O(N) 时间。<br>空间复杂度 O(N) ： 哈希表 set 使用线性大小的额外空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList1</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123; <span class="comment">//构造节点</span></span><br><span class="line">        map.put(cur, <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val));</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123; <span class="comment">//复制引用 复制新节点的引用</span></span><br><span class="line">        map.get(cur).next = map.get(cur.next);</span><br><span class="line">        map.get(cur).random = map.get(cur.random);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拼接拆分"><a href="#拼接拆分" class="headerlink" title="拼接拆分"></a>拼接拆分</h4><p>考虑构建 原节点 1 . 新节点 1 . 原节点 2 . 新节点 2 . …… 的拼接链表，如此便可在访问原节点的 random 指向节点的同时找到新对应新节点的 random 指向节点。</p>
<p><strong>算法流程：</strong></p>
<ol>
<li><p>复制各节点，构建拼接链表:</p>
<ul>
<li>设原链表为 node1.node2.⋯ ，构建的拼接链表如下所示：<br>node1 .node1{new}.node2.node2{new}…..</li>
</ul>
</li>
<li><p>构建新链表各节点的 random 指向：</p>
<ul>
<li>当访问原节点 cur 的随机指向节点 cur.random 时，对应新节点 cur.next 的随机指向节点为cur.random.next。</li>
</ul>
</li>
<li><p>拆分原 &#x2F; 新链表：</p>
</li>
</ol>
<ul>
<li>设置 pre &#x2F; cur 分别指向原 &#x2F; 新链表头节点，遍历执行 pre.next &#x3D; pre.next.next 和 cur.next &#x3D; cur.next.next 将两链表拆分开。</li>
</ul>
<ol start="4">
<li>返回新链表的头节点 res 即可。</li>
</ol>
<p><strong>复杂度分析：</strong><br>时间复杂度 O(N)O(N) ： 三轮遍历链表，使用 O(N)O(N) 时间。<br>空间复杂度 O(1)O(1) ： 节点引用变量使用常数大小的额外空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1604747285-LidbfG-Picture16.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拼接 + 拆分</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">copyRandomList2</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制各节点，构建拼接链表</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val);</span><br><span class="line">        temp.next = cur.next;</span><br><span class="line">        cur.next = temp;</span><br><span class="line">        cur = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建新链表各节点的 random 指向</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.random != <span class="literal">null</span>)</span><br><span class="line">            cur.next.random = cur.random.next;</span><br><span class="line">        cur  = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拆分两链表</span></span><br><span class="line">    cur = head.next;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head, res = head.next;</span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-7、剑指-Offer-58-II-左旋转字符串"><a href="#5-7、剑指-Offer-58-II-左旋转字符串" class="headerlink" title="5.7、剑指 Offer 58 - II. 左旋转字符串"></a>5.7、剑指 Offer 58 - II. 左旋转字符串</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;lrloseumgh&quot;, k = 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= k &lt; s.length &lt;= 10000</code></li>
</ul>
<p>Related Topics</p>
<p>数学</p>
<p>双指针</p>
<p>字符串</p>
<h4 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h4><blockquote>
<p>应用字符串切片函数，可方便实现左旋转字符串。</p>
</blockquote>
<p>获取字符串 s[n:] 切片和 s[:n] 切片，使用 “+” 运算符拼接并返回即可。</p>
<p><strong>复杂度分析：</strong><br>时间复杂度 O(N)： 其中 NN 为字符串 s 的长度，字符串切片函数为线性时间复杂度（参考资料）。<br>空间复杂度 O(N)： 两个字符串切片的总长度为 N。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1600793170-eyvDTJ-Picture1.png" alt="Picture1.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.substring(n, s.length()) + s.substring(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="列表遍历拼接"><a href="#列表遍历拼接" class="headerlink" title="列表遍历拼接"></a>列表遍历拼接</h4><blockquote>
<p>若面试规定不允许使用 切片函数 ，则使用此方法。</p>
</blockquote>
<p><strong>算法流程：</strong></p>
<ol>
<li>新建一个 StringBuilder，记为 res ；</li>
<li>先向 res 添加 “第 n+1 位至末位的字符” ；</li>
<li>再向 res 添加 “首位至第 n 位的字符” ；</li>
<li>将 res 转化为字符串并返回；</li>
</ol>
<p><strong>复杂度分析：</strong><br>时间复杂度 O(N)O(N) ： 线性遍历 s 并添加，使用线性时间。<br>空间复杂度 O(N)O(N) ： 新建的辅助 res 使用 O(N)O(N) 大小的额外空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1600793170-ViWBNV-Picture2.png" alt="Picture2.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; s.length(); i++)</span><br><span class="line">            res.append(s.charAt(i));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            res.append(s.charAt(i));</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求余运算加速</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; n + s.length(); i++)</span><br><span class="line">            res.append(s.charAt(i % s.length()));</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符串遍历拼接"><a href="#字符串遍历拼接" class="headerlink" title="字符串遍历拼接"></a>字符串遍历拼接</h4><blockquote>
<p>若规定 Java 只能用 String ，则使用此方法。</p>
</blockquote>
<p>此方法与 方法二 思路一致，区别是使用字符串代替列表。</p>
<p><strong>复杂度分析：</strong><br>时间复杂度 O(N)： 线性遍历 s 并添加，使用线性时间。<br>空间复杂度 O(N) ： 假设循环过程中内存会被及时回收，内存中至少同时存在长度为 N 和 N−1 的两个字符串（新建长度为 N 的 res 需要使用前一个长度 N−1 的 res ），因此至少使用 O(N) 的额外空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1600793170-uasqXO-Picture3.png" alt="Picture3.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; s.length(); i++)</span><br><span class="line">            res += s.charAt(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            res += s.charAt(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求余运算加速</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; n + s.length(); i++)</span><br><span class="line">            res += s.charAt(i % s.length());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-8、剑指-Offer-59-I-滑动窗口的最大值"><a href="#5-8、剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="5.8、剑指 Offer 59 - I. 滑动窗口的最大值"></a>5.8、剑指 Offer 59 - I. 滑动窗口的最大值</h3><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<p>你可以假设 <em>k</em> 总是有效的，在输入数组 <strong>不为空</strong> 的情况下，<code>1 ≤ k ≤ nums.length</code>。</p>
<p>队列</p>
<p>滑动窗口</p>
<p>单调队列</p>
<p>堆（优先队列）</p>
<hr>
<p><strong>解题思路：</strong><br>设窗口区间为 [i, j] ，最大值为 x j 。当窗口向前移动一格，则区间变为 [i+1,j+1]，即添加了 nums[j + 1] ，删除了nums[i] 。</p>
<p>若只向窗口 [i, j]右边添加数字 nums[j + 1]，则新窗口最大值可以 通过一次对比 使用O(1) 时间得到，即：<code>x&#123;j+1&#125; = max(x&#123;j&#125;, nums[j + 1])</code>而由于删除的 nums[i]可能恰好是窗口内唯一的最大值 x j，因此不能通过以上方法计算 x j+1，而必须使用O(j−i) 时间， 遍历整个窗口区间 获取最大值，即：x{j+1} &#x3D; max(nums(i+1),……. , num(j+1))</p>
<p>根据以上分析，可得 暴力法 的时间复杂度为 O((n-k+1)k)≈O(nk) 。</p>
<ul>
<li>设数组 nums的长度为 nn ，则共有 (n-k+1)个窗口；</li>
<li>获取每个窗口最大值需线性遍历，时间复杂度为 O(k)。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1600878237-pBiBdf-Picture1.png" alt="Picture1.png"></p>
<blockquote>
<p><strong>本题难点：</strong> 如何在每次窗口滑动后，将 “获取窗口内最大值” 的时间复杂度从 O(k) 降低至 O(1)。</p>
</blockquote>
<p>回忆 剑指Offer 30. 包含 min 函数的栈 ，其使用 <strong>单调栈</strong> 实现了随意入栈、出栈情况下的 O(1)时间获取 “栈内最小值” 。本题同理，不同点在于 “出栈操作” 删除的是 “列表尾部元素” ，而 “窗口滑动” 删除的是 “列表首部元素”。</p>
<p>窗口对应的数据结构为 <strong>双端队列</strong> ，本题使用 <strong>单调队列</strong> 即可解决以上问题。遍历数组时，每轮保证单调队列 deque：</p>
<ol>
<li>deque 内 <strong>仅包含窗口内的元素</strong> ⇒ 每轮窗口滑动移除了元素nums[i−1] ，需将 deque内的对应元素一起删除。</li>
<li>deque 内的元素 <strong>非严格递减</strong> ⇒ 每轮窗口滑动添加了元素 nums[j + 1]，需将 deque内所有 &lt; nums[j + 1]的元素删除。</li>
</ol>
<p><strong>算法流程：</strong></p>
<ol>
<li>初始化： 双端队列 deque ，结果列表 res ，数组长度 n ；</li>
<li>滑动窗口： 左边界范围i∈[1−k,n−k] ，右边界范围 j∈[0,n−1] ；<ol>
<li>若 i &gt; 0 且 队首元素 deque[0] &#x3D;&#x3D; 被删除元素 nums[i−1] ：则队首元素出队；</li>
<li>删除 deque 内所有 &lt;nums[j] 的元素，以保持 deque 递减；</li>
<li>将 nums[j]添加至deque 尾部；</li>
<li>若已形成窗口（即 i≥0 ）：将窗口最大值（即队首元素 deque[0] ）添加至列表 res ；</li>
</ol>
</li>
<li>返回值： 返回结果列表 resres ；</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1600878237-YoQeRX-Picture4.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1600878237-cFWnrv-Picture5.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1600878237-jrguEx-Picture6.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1600878237-KPnHbt-Picture8.png" alt="img"></p>
<p><strong>复杂度分析：</strong><br>时间复杂度 O(n) ： 其中 nn 为数组 nums 长度；线性遍历nums 占用O(n) ；每个元素最多仅入队和出队一次，因此单调队列 deque占用 O(2n) 。<br>空间复杂度 O(k)： 双端队列deque 中最多同时存储 k个元素（即窗口大小）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow2(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">1</span> - k; j &lt; nums.length; i++, j++) &#123;</span><br><span class="line">        <span class="comment">// 删除 deque 中对应的 nums[i-1]</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; deque.peekFirst() == nums[i - <span class="number">1</span>])</span><br><span class="line">            deque.removeFirst();</span><br><span class="line">        <span class="comment">// 保持 deque 递减</span></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j])</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        deque.addLast(nums[j]);</span><br><span class="line">        <span class="comment">// 记录窗口最大值</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)</span><br><span class="line">            res[i] = deque.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-9、剑指-Offer-59-II-队列的最大值"><a href="#5-9、剑指-Offer-59-II-队列的最大值" class="headerlink" title="5.9、剑指 Offer 59 - II. 队列的最大值"></a>5.9、剑指 Offer 59 - II. 队列的最大值</h3><p>请定义一个队列并实现函数 <code>max_value</code> 得到队列里的最大值，要求函数<code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code> 的<strong>均摊</strong>时间复杂度都是O(1)。</p>
<p>若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 -1</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</code></li>
<li><code>1 &lt;= value &lt;= 10^5</code></li>
</ul>
<p>Related Topics</p>
<p>设计</p>
<p>队列</p>
<p>单调队列</p>
<hr>
<p><strong>解题思路：</strong></p>
<p>考虑利用 数据结构 来实现，即经常使用的 “空间换时间” 。如下图所示，考虑构建一个递减列表来保存队列 所有递减的元素 ，递减链表随着入队和出队操作实时更新，这样队列最大元素就始终对应递减列表的首元素，实现了获取最大值O(1) 时间复杂度。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1609261470-gMTEAf-Picture2.png" alt="Picture2.png"></p>
<p>为了实现此递减列表，需要使用 <strong>双向队列</strong> ，假设队列已经有若干元素：</p>
<ol>
<li>当执行入队 push_back() 时： 若入队一个比队列某些元素更大的数字 x ，则为了保持此列表递减，需要将双向队列 尾部所有小于 x 的元素 弹出。</li>
<li>当执行出队 pop_front() 时： 若出队的元素是最大元素，则 双向队列 需要同时 <strong>将首元素出队</strong> ，以保持队列和双向队列的元素一致性。</li>
</ol>
<blockquote>
<p>使用双向队列原因：维护递减列表需要元素队首弹出、队尾插入、队尾弹出操作皆为O(1) 时间复杂度。</p>
</blockquote>
<p><strong>函数设计：</strong></p>
<p>初始化队列 queue ，双向队列 deque ；</p>
<p><strong>最大值 max_value() ：</strong></p>
<ul>
<li>当双向队列 deque 为空，则返回−1 ；</li>
<li>否则，返回 deque 首元素；</li>
</ul>
<p><strong>入队 push_back() ：</strong></p>
<ul>
<li>将元素 value 入队 queue ；</li>
<li>将双向队列中队尾 所有 小于 value 的元素弹出（以保持 deque 非单调递减），并将元素 value 入队 deque ；</li>
</ul>
<p><strong>出队 pop_front() ：</strong></p>
<ul>
<li>若队列 queue 为空，则直接返回 -1−1 ；</li>
<li>否则，将 queue 首元素出队；</li>
<li>若 deque 首元素和 queue 首元素 相等 ，则将 deque 首元素出队（以保持两队列 元素一致 ） ；</li>
</ul>
<blockquote>
<p>设计双向队列为 非单调递减 的原因：若队列 queue 中存在两个 值相同的最大元素 ，此时 queue 和 deque 同时弹出一个最大元素，而 queue 中还有一个此最大元素；即采用单调递减将导致两队列中的元素不一致。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    Deque&lt;Integer&gt; deque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max_value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deque.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> deque.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        queue.add(value);</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; value)</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        deque.offerLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop_front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(queue.peek(), deque.peekFirst()))</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            <span class="keyword">return</span> queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-10、剑指-Offer-67-把字符串转换成整数"><a href="#5-10、剑指-Offer-67-把字符串转换成整数" class="headerlink" title="5.10、剑指 Offer 67. 把字符串转换成整数"></a>5.10、剑指 Offer 67. 把字符串转换成整数</h3><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p><strong>说明：</strong></p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#x27;-&#x27;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#x27;3&#x27; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &#x27;w&#x27;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br></pre></td></tr></table></figure>

<p><strong>示例 5:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure>

<p>Related Topics</p>
<p>字符串</p>
<hr>
<p><strong>解题思路：</strong><br>根据题意，有以下四种字符需要考虑：</p>
<ol>
<li><p>首部空格： 删除之即可；</p>
</li>
<li><p>符号位： 三种情况，即 ‘’++’’ , ‘’-−’’ , ‘’无符号” ；新建一个变量保存符号位，返回前判断正负即可；</p>
</li>
<li><p>非数字字符： 遇到首个非数字的字符时，应立即返回；</p>
</li>
<li><p>数字字符：</p>
<ol>
<li><p>字符转数字： “此数字的 ASCII 码” 与 “ 00 的 ASCII 码” 相减即可；</p>
</li>
<li><p>数字拼接： 若从左向右遍历数字，设当前位字符为 cc ，当前位数字为 xx ，数字结果为 resres ，则数字拼接公式为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210291215534.png" alt="image-20221029121552410"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1600793383-jCgsGU-Picture1.png" alt="Picture1.png"></p>
</li>
</ol>
</li>
</ol>
<p><strong>数字越界处理：</strong></p>
<blockquote>
<p>题目要求返回的数值范围应在[−2^31 ,2^31 −1] ，因此需要考虑数字越界问题。而由于题目指出 环境只能存储 32 位大小的有符号整数 ，因此判断数字越界时，要始终保持 res 在 int 类型的取值范围内。</p>
</blockquote>
<p>在每轮数字拼接前，判断res 在此轮拼接后是否超过 2147483647，若超过则加上符号位直接返回。<br>设数字拼接边界 bndry &#x3D; 2147483647 &#x2F;&#x2F; 10 &#x3D; 214748364，则以下两种情况越界：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210291218048.png" alt="image-20221029121808981"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1600793383-JZRYip-Picture2.png" alt="Picture2.png"></p>
<p><strong>复杂度分析：</strong><br>时间复杂度 O(N) ： 其中 N 为字符串长度，线性遍历字符串占用 O(N) 时间。<br>空间复杂度 O(N) ： 删除首尾空格后需建立新字符串，最差情况下占用 O(N) 额外空间。</p>
<p>若不使用 <code>trim() / strip()</code> 删除首部空格，而采取遍历跳过空格的方式，则可以将空间复杂度降低至 O(1) ，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strToInt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, <span class="comment">// 返回值</span></span><br><span class="line">        bndry = Integer.MAX_VALUE / <span class="number">10</span>; <span class="comment">// 越界标志</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, <span class="comment">// 遍历</span></span><br><span class="line">        sign = <span class="number">1</span>, <span class="comment">// 正负标志位</span></span><br><span class="line">        length = str.length();</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">// 跳过空格</span></span><br><span class="line">        <span class="keyword">if</span> (++i == length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27;-&#x27;</span>) sign = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27;+&#x27;</span> || str.charAt(i) == <span class="string">&#x27;-&#x27;</span>) i++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(j) &lt; <span class="string">&#x27;0&#x27;</span> || str.charAt(j) &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; bndry || res == bndry &amp;&amp; str.charAt(j) &gt; <span class="string">&#x27;7&#x27;</span>) <span class="comment">// 越界</span></span><br><span class="line">            <span class="keyword">return</span> sign == <span class="number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">        res = res * <span class="number">10</span> + (str.charAt(j) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res * sign;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-11、LC2-两数之和"><a href="#5-11、LC2-两数之和" class="headerlink" title="5.11、LC2. 两数之和"></a>5.11、LC2. 两数之和</h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例 1：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<p>Related Topics</p>
<p>递归</p>
<p>链表</p>
<p>数学</p>
<h4 id="构造新链表"><a href="#构造新链表" class="headerlink" title="构造新链表"></a>构造新链表</h4><p>通过计算两个链表的和构造一个新链表。</p>
<p>时间复杂度O(N)</p>
<p>空间复杂度O(N)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 构建新链表</span></span><br><span class="line"><span class="comment">     * 时间复杂度O(n)</span></span><br><span class="line"><span class="comment">     * 空间复杂度O(1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers1</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">out</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录进位</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> l1;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur2</span> <span class="operator">=</span> l2;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur1 != <span class="literal">null</span> || cur2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (cur1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            cur.next.val = cur2.val + out;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            cur.next.val = cur1.val + out;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next.val = cur1.val + cur2.val + out;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.next.val &gt; <span class="number">9</span>) &#123; <span class="comment">// 2 位数</span></span><br><span class="line">            cur.next.val = cur.next.val % <span class="number">10</span>;</span><br><span class="line">            out = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (out == <span class="number">1</span>) &#123; <span class="comment">//如果有进位 填上进位</span></span><br><span class="line">        cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在原链表上操作"><a href="#在原链表上操作" class="headerlink" title="在原链表上操作"></a>在原链表上操作</h4><p>如果链表1没有链表2长的话，就把链表2的后续接在链表1上。处理后续有点麻烦。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在原链表上改值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> l1;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur2</span> <span class="operator">=</span> l2;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> l1;</span><br><span class="line">    <span class="type">int</span> <span class="variable">out</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur1 != <span class="literal">null</span> &amp;&amp; cur2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur1.next == <span class="literal">null</span>) &#123; <span class="comment">//cur1 小拼接</span></span><br><span class="line">            cur1.next = cur2.next;</span><br><span class="line">            cur2.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1.val = cur1.val + cur2.val + out;</span><br><span class="line">        out = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur1.val &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            cur1.val = cur1.val % <span class="number">10</span>;</span><br><span class="line">            out = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur1;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">        cur2 = cur2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur1 == <span class="literal">null</span> &amp;&amp; out == <span class="number">1</span>) &#123; <span class="comment">//位数相同 有一个进位</span></span><br><span class="line">        pre.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur1 != <span class="literal">null</span>) &#123; <span class="comment">//如果存在拼接的情况，则可能存在进位未加的情况</span></span><br><span class="line">        cur1.val += out;</span><br><span class="line">        out = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur1.val &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            cur1.val = cur1.val % <span class="number">10</span>;</span><br><span class="line">            out = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur1.next == <span class="literal">null</span> &amp;&amp; out == <span class="number">1</span>) &#123;</span><br><span class="line">            cur1.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">            out = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1 = cur1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、有限状态自动机（FSM）"><a href="#六、有限状态自动机（FSM）" class="headerlink" title="六、有限状态自动机（FSM）"></a>六、有限状态自动机（FSM）</h2><p> 有限状态机（Finite State Machine, FSM），又称有限状态自动机，简称状态机，是指在有限个状态之间按照一定规律转换的时序电路。</p>
<p>什么是有限状态自动机<br>是一种具有离散输入&#x2F;输出系统的数学模型，简称 有限自动机。这一系统具有任意有限数量的内部“状态”。</p>
<p>状态:一个标识，能区分自动机在不同时刻的状况。有限状态系统具有任意有限数目的内部“状态”</p>
<p>自动机接受一定的输入，执行一定的动作，产生一定的结果。</p>
<p>自动机的本质:根据状态、输入和规则决定下一个状态</p>
<p>状态 +输入(激励)+规则 . 状态迁移</p>
<p>可能的状态、运行的规则都是事先确定的。一旦开始运行，就按照实现确定的规则工作，因此叫”自动机”。使用状态迁移描述整个工作过程</p>
<p>有限自动机示意图:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/10b29ca6d5e0a9923a58c59041235ab0.png" alt="image-20220409152351649"></p>
<h3 id="6-1、应用有限自动机解题步骤"><a href="#6-1、应用有限自动机解题步骤" class="headerlink" title="6.1、应用有限自动机解题步骤"></a>6.1、应用有限自动机解题步骤</h3><p><strong>1、确定输入集</strong></p>
<p><strong>2、绘制状态迁移图（确定状态，在每一个状态下对输入进行分类，针对每一类输入，确定下一个状态）</strong></p>
<p><strong>3、确定状态转移函数（在某状态下，接收到某一字符后，自动机要执行的操作，以及迁移到的下一状态）</strong></p>
<h3 id="6-2、剑指-Offer-20-表示数值的字符串"><a href="#6-2、剑指-Offer-20-表示数值的字符串" class="headerlink" title="6.2、剑指 Offer 20. 表示数值的字符串"></a>6.2、剑指 Offer 20. 表示数值的字符串</h3><p>请实现一个函数用来判断字符串是否表示<strong>数值</strong>（包括整数和小数）。</p>
<p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>若干空格</li>
<li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li>
<li>（可选）一个 <code>&#39;e&#39;</code> 或 <code>&#39;E&#39;</code> ，后面跟着一个 <strong>整数</strong></li>
<li>若干空格</li>
</ol>
<p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li>
<li>下述格式之一：<ol>
<li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code></li>
<li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code> ，后面再跟着至少一位数字</li>
<li>一个点 <code>&#39;.&#39;</code> ，后面跟着至少一位数字</li>
</ol>
</li>
</ol>
<p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li>
<li>至少一位数字</li>
</ol>
<p>部分<strong>数值</strong>列举如下：</p>
<ul>
<li><code>[&quot;+100&quot;, &quot;5e2&quot;, &quot;-123&quot;, &quot;3.1416&quot;, &quot;-1E-16&quot;, &quot;0123&quot;]</code></li>
</ul>
<p>部分<strong>非数值</strong>列举如下：</p>
<ul>
<li><code>[&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;]</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;0&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;e&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;.&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;    .1  &quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20</code></li>
<li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>&#39;+&#39;</code> ，减号 <code>&#39;-&#39;</code> ，空格 <code>&#39; &#39;</code> 或者点 <code>&#39;.&#39;</code> 。</li>
</ul>
<p>Related Topics</p>
<p>字符串</p>
<hr>
<p>解题思路：<br>本题使用有限状态自动机。根据字符类型和合法数值的特点，先定义状态，再画出状态转移图，最后编写代码即可。</p>
<p><strong>字符类型</strong>：</p>
<p>空格 「 」、数字「 0—9」 、正负号 「 +, -」 、小数点 「 . 」 、幂符号 「 e, E 」 。</p>
<p><strong>状态定义</strong>：</p>
<p>按照字符串从左到右的顺序，定义以下 9 种状态。</p>
<ol start="0">
<li>开始的空格</li>
<li>幂符号前的正负号</li>
<li>小数点前的数字</li>
<li>小数点、小数点后的数字</li>
<li>当小数点前为空格时，小数点、小数点后的数字</li>
<li>幂符号</li>
<li>幂符号后的正负号</li>
<li>幂符号后的数字</li>
<li>结尾的空格</li>
</ol>
<p><strong>结束状态：</strong></p>
<p>合法的结束状态有 2, 3, 7, 8 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1599283151-YmPMis-Picture1.png" alt="Picture1.png"></p>
<p><strong>算法流程：</strong></p>
<ol>
<li><strong>初始化：</strong><ol>
<li>状态转移表 states ： 设 states[i] ，其中 i 为所处状态， states[i] 使用哈希表存储可转移至的状态。键值对 (key, value) 含义：输入字符 key ，则从状态 i 转移至状态 value 。</li>
<li>当前状态 p ： 起始状态初始化为 p &#x3D; 0 。</li>
</ol>
</li>
<li>状态转移循环： 遍历字符串 s 的每个字符 c 。<ol>
<li>记录字符类型 t ： 分为四种情况。<ul>
<li>当 c 为正负号时，执行 t &#x3D; ‘s’ ;</li>
<li>当 c 为数字时，执行 t &#x3D; ‘d’ ;</li>
<li>当 c 为 e 或 E 时，执行 t &#x3D; ‘e’ ;</li>
<li>当 c 为 . 或 空格 时，执行 t &#x3D; c （即用字符本身表示字符类型）;</li>
<li>否则，执行 t &#x3D; ‘?’ ，代表为不属于判断范围的非法字符，后续直接返回 falsefalse 。</li>
</ul>
</li>
<li>终止条件： 若字符类型 t 不在哈希表 states[p] 中，说明无法转移至下一状态，因此直接返回 false 。</li>
<li>状态转移： 状态 p 转移至 states[p] [t] 。</li>
</ol>
</li>
<li>返回值： 跳出循环后，若状态 p \in {2, 3, 7, 8}∈2,3,7,8 ，说明结尾合法，返回 truetrue ，否则返回 false 。</li>
</ol>
<p><strong>复杂度分析：</strong><br>时间复杂度 O(N) ： 其中 N 为字符串 s 的长度，判断需遍历字符串，每轮状态转移的使用O(1) 时间。<br>空间复杂度 O(1) ： states 和 p 使用常数大小的额外空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1599283163-NYRJuG-Picture2.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map[] states = &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27; &#x27;</span>, <span class="number">0</span>); put(<span class="string">&#x27;s&#x27;</span>, <span class="number">1</span>); put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>); &#125;&#125;, <span class="comment">// 0.</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>); &#125;&#125;,                           <span class="comment">// 1.</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">2</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">3</span>); put(<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;, <span class="comment">// 2.</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>); put(<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;,              <span class="comment">// 3.</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>); &#125;&#125;,                                        <span class="comment">// 4.</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;s&#x27;</span>, <span class="number">6</span>); put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>); &#125;&#125;,                           <span class="comment">// 5.</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>); &#125;&#125;,                                        <span class="comment">// 6.</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;,                           <span class="comment">// 7.</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#123; put(<span class="string">&#x27; &#x27;</span>, <span class="number">8</span>); &#125;&#125;                                         <span class="comment">// 8.</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) t = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) t = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;E&#x27;</span>) t = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;.&#x27;</span> || c == <span class="string">&#x27; &#x27;</span>) t = c;</span><br><span class="line">            <span class="keyword">else</span> t = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!states[p].containsKey(t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = (<span class="type">int</span>)states[p].get(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p == <span class="number">2</span> || p == <span class="number">3</span> || p == <span class="number">7</span> || p == <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、动态规划"><a href="#七、动态规划" class="headerlink" title="七、动态规划"></a>七、动态规划</h2><h3 id="7-1、动态规划理论"><a href="#7-1、动态规划理论" class="headerlink" title="7.1、动态规划理论"></a>7.1、动态规划理论</h3><p><strong>内容</strong></p>
<ol>
<li>动态规划问题特点，动态规划和分治算法的联系与区别；</li>
<li>借助例题介绍重叠子问题和最优子结构分别是什么，以及动态规划是如何解决它们的；</li>
<li>动态规划的解题框架总结；</li>
<li>动态规划的练习例题，从易到难排序；</li>
</ol>
<p><strong>动态规划特点</strong></p>
<p><code>「分治」</code>是算法中的一种基本思想，其通过将原问题分解为子问题，不断递归地将子问题分解为更小的子问题，并通过<code>组合子问题的解</code>来得到原问题的解。</p>
<p>类似于分治算法，<code>「动态规划」</code>也通过组合子问题的解得到原问题的解。不同的是，适合用动态规划解决的问题具有<code>「重叠子问题」</code>和<code>「最优子结构」</code>两大特性。</p>
<p><strong>重叠子问题</strong><br>动态规划的子问题是有重叠的，即<code>各个子问题中包含重复的更小子问题</code>。若使用暴力法穷举，求解这些相同子问题会产生大量的重复计算，效率低下。</p>
<p>动态规划在第一次求解某子问题时，会<code>将子问题的解保存</code>；后续遇到重叠子问题时，则直接通过<code>查表获取</code>解，保证<code>每个独立子问题只被计算一次</code>，从而降低算法的时间复杂度。</p>
<p><strong>最优子结构</strong><br>如果一个问题的<code>最优解可以由其子问题的最优解组合</code>构成，并且这些子问题可以独立求解，那么称此问题具有最优子结构。</p>
<p>动态规划从基础问题的解开始，不断迭代<code>组合、选择子问题的最优解</code>，最终得到原问题最优解。</p>
<h3 id="7-2、重叠子问题例题：斐波那契数列"><a href="#7-2、重叠子问题例题：斐波那契数列" class="headerlink" title="7.2、重叠子问题例题：斐波那契数列"></a>7.2、重叠子问题例题：斐波那契数列</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210311145007.png" alt="image-20221031114521821"></p>
<h4 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h4><p>设斐波那契数列第 nn 个数字为 f(n)f(n) 。根据数列定义，可得 f(n)&#x3D;f(n−1)+f(n−2) ，且第 0 , 1 个斐波那契数分别为 f(0)&#x3D;0 , f(1) &#x3D; 1。</p>
<p>我们很容易联想到使用分治思想来求取 f(n)，即将求原问题f(n) 分解为求子问题f(n−1) 和f(n−2) ，向下递归直至已知的 f(0) 和 f(1) ，最终组合这些子问题求取原问题 f(n) 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求第 n 个斐波那契数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回 f(0)</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回 f(1)</span></span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>); <span class="comment">// 分解为两个子问题求解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1635075778-GADtbi-Picture1.png" alt="Picture1.png"></p>
<p>如上图所示，为暴力递归求斐波那契数 f(5)形成的二叉树，树中的每个节点代表着执行了一次 fibonacci() 函数，且有：</p>
<ul>
<li>执行一次 fibonacci() 函数的时间复杂度为 O(1) ；</li>
<li>二叉树节点数为指数级 O(2^n)</li>
</ul>
<p>因此，暴力递归的总体时间复杂度为 O(2^n)此方法效率低下，随着 n 的增长产生指数级爆炸。</p>
<h4 id="记忆化递归"><a href="#记忆化递归" class="headerlink" title="记忆化递归"></a>记忆化递归</h4><p>观察发现，暴力递归中的子问题多数都是<strong>重叠子问题</strong>，即：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210311150060.png" alt="image-20221031115046286"></p>
<p>这些重叠子问题产生了大量的递归树节点，其<code>不应被重复计算</code>。实际上，可以在递归中第一次求解子问题时，就将它们<code>保存</code>；后续递归中再次遇到相同子问题时，直接访问内存赋值即可。记忆化递归的代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] dp)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;           <span class="comment">// 返回 f(0)</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;           <span class="comment">// 返回 f(1)</span></span><br><span class="line">    <span class="keyword">if</span> (dp[n] != <span class="number">0</span>) <span class="keyword">return</span> dp[n];   <span class="comment">// 若 f(n) 以前已经计算过，则直接返回记录的解</span></span><br><span class="line">    dp[n] = fibonacci(n - <span class="number">1</span>, dp) + fibonacci(n - <span class="number">2</span>, dp); <span class="comment">// 将 f(n) 则记录至 dp</span></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求第 n 个斐波那契数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fibonacciMemorized</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>]; <span class="comment">// 用于保存 f(0) 至 f(n) 问题的解</span></span><br><span class="line">    <span class="keyword">return</span> fibonacci(n, dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下图所示，应用记忆化递归方法后，递归树中绝大部分节点被剪枝。此时，fibonacci() 函数的调用次数从 O(2^n)指数级别降低至 O(n)线性级别，时间复杂度大大降低。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1635075778-pJXkPc-Picture2.png" alt="Picture2.png"></p>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>递归本质上是基于分治思想的从顶至底的解法。借助记忆化递归思想，可应用动态规划从底至顶求取 f(n) ，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求第 n 个斐波那契数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;          <span class="comment">// 若求 f(0) 则直接返回 0</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];     <span class="comment">// 初始化 dp 列表</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;                     <span class="comment">// 初始化 f(0), f(1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123; <span class="comment">// 状态转移求取 f(2), f(3), ..., f(n) </span></span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];                  <span class="comment">// 返回 f(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下图所示，为动态规划求解 f(5)的迭代流程，其是转移方程 <code>f(n) = f(n - 1) + f(n - 2)</code>的体现。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1635075778-EeBEoS-Picture3.png" alt="Picture3.png"></p>
<p>上述动态规划解法借助了一个 dp 数组保存子问题的解，其空间复杂度为O(N) 。而由于f(n) 只与f(n−1) 和 f(n−2) 有关，因此我们可以仅使用两个变量 a , b 交替前进计算即可。此时动态规划的空间复杂度降低至 O(1)，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求第 n 个斐波那契数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;           <span class="comment">// 若求 f(0) 则直接返回 0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">1</span>;               <span class="comment">// 初始化 f(0), f(1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;  <span class="comment">// 状态转移求取 f(2), f(3), ..., f(n) </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;                       <span class="comment">// 返回 f(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例小结"><a href="#示例小结" class="headerlink" title="示例小结"></a>示例小结</h4><p>记忆化递归和动态规划的本质思想是一致的，是对斐波那契数列定义的不同表现形式：</p>
<ul>
<li>记忆化递归 — 从顶至低： 求 f(n)需要 f(n - 1)和 f(n - 2);⋯ ；求 f(2) 需要 f(1) 和 f(0) ；而 f(1) 和 f(0) 已知；</li>
<li>动态规划 — 从底至顶： 将已知 f(0) 和f(1) 组合得到f(2) ；⋯ ；将 f(n−2) 和 f(n−1) 组合得到 (n) ；</li>
</ul>
<p>斐波那契数列问题不包含「最优子结构」，只需计算每个子问题的解，避免重复计算即可，并不需要从子问题组合中选择最优组合。接下来，本文借助「最高蛋糕售价方案」，介绍动态规划的最优子结构概念。</p>
<h3 id="7-3、最优子结构例题：蛋糕售价"><a href="#7-3、最优子结构例题：蛋糕售价" class="headerlink" title="7.3、最优子结构例题：蛋糕售价"></a>7.3、最优子结构例题：蛋糕售价</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210311159196.png" alt="image-20221031115902124"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210311159705.png" alt="image-20221031115959610"></p>
<h4 id="暴力递归-1"><a href="#暴力递归-1" class="headerlink" title="暴力递归"></a>暴力递归</h4><p>暴力递归解法的代码如下，其时间复杂度为指数级 O(2^n） 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入蛋糕价格列表 priceList ，求重量为 n 蛋糕的最高售价</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxCakePrice</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] priceList)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> priceList[n]; <span class="comment">// 蛋糕重量 &lt;= 1 时直接返回</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">f_n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)      <span class="comment">// 从 n 种组合种选择最高售价的组合作为 f(n)</span></span><br><span class="line">        f_n = Math.max(f_n, maxCakePrice(i, priceList) + priceList[n - i]);</span><br><span class="line">    <span class="keyword">return</span> f_n;                      <span class="comment">// 返回 f(n)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1635075778-AljQEJ-Picture4.png" alt="Picture4.png"></p>
<h4 id="记忆化递归-1"><a href="#记忆化递归-1" class="headerlink" title="记忆化递归"></a>记忆化递归</h4><p>观察发现，递归树中存在大量<strong>重叠子问题</strong>，可通过记忆化处理避免重复计算。记忆化递归的算法的时间复杂度为 O(n^2)，包括：</p>
<ul>
<li>f(2) 至f(n) 共 n−1 个待计算子问题，使用O(n) 时间；</li>
<li>计算某f(i) 需遍历 i−1 种子问题组合，使用 O(n) 时间；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入蛋糕价格列表 priceList ，求重量为 n 蛋糕的最高售价</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxCakePrice</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] priceList, <span class="type">int</span>[] dp)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> priceList[n]; <span class="comment">// 蛋糕重量 &lt;= 1 时直接返回</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">f_n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;    <span class="comment">// 从 n 种组合种选择最高售价的组合作为 f(n)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">f_i</span> <span class="operator">=</span> dp[i] != <span class="number">0</span> ? dp[i] : maxCakePrice(i, priceList, dp);</span><br><span class="line">        f_n = Math.max(f_n, f_i + priceList[n - i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[n] = f_n;                     <span class="comment">// 记录 f(n) 至 dp 数组</span></span><br><span class="line">    <span class="keyword">return</span> f_n;                      <span class="comment">// 返回 f(n)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxCakePriceMemorized</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] priceList)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> maxCakePrice(n, priceList, dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1635075778-tsDBrs-Picture5.png" alt="Picture5.png"></p>
<h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h4><p>相较于记忆化递归的从顶至底方法，易得动态规划的从底至顶方法，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入蛋糕价格列表 priceList ，求重量为 n 蛋糕的最高售价</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxCakePrice</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] priceList)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> priceList[n];  <span class="comment">// 蛋糕重量 &lt;= 1 时直接返回</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];        <span class="comment">// 初始化 dp 列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;    <span class="comment">// 按顺序计算 f(1), f(2), ..., f(n)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++)   <span class="comment">// 从 j 种组合种选择最高售价的组合作为 f(j)</span></span><br><span class="line">            dp[j] = Math.max(dp[j], dp[i] + priceList[j - i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1635075778-PBtyyB-Picture6.png" alt="Picture6.png"></p>
<h3 id="7-4、01背包问题"><a href="#7-4、01背包问题" class="headerlink" title="7.4、01背包问题"></a>7.4、01背包问题</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/20210117171307407.png" alt="416.分割等和子集1"></p>
<p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<blockquote>
<p>暴力解法：回溯法O(2^N)</p>
</blockquote>
<p>案例：</p>
<p>背包最大重量为4。</p>
<p>物品为：</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p>问背包能背的物品最大价值是多少？</p>
<h4 id="二维dp"><a href="#二维dp" class="headerlink" title="二维dp"></a>二维dp</h4><ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/20210110103003361.png" alt="动态规划-背包问题1"></p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>再回顾一下dp[i] [j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p>
<p>那么可以有两个方向推出来dp[i] [j]，</p>
<ul>
<li><strong>不放物品i</strong>：由dp[i - 1] [j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i] [j]就是dp[i - 1] [j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)</li>
<li><strong>放物品i</strong>：由dp[i - 1] [j - weight[i]]推出，dp[i - 1] [j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1] [j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li>
</ul>
<p>所以递归公式： dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p><strong>首先从dp[i] [j]的定义出发</strong>，如果背包容量j为0的话，即dp[i] [0]，无论是选取哪些物品，背包价值总和一定为0。如图：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/2021011010304192-16696851911264.png" alt="动态规划-背包问题2"></p>
<p>状态转移方程 dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p>
<p>dp[0] [j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p>
<ul>
<li><p>那么很明显当 j &lt; weight[0]的时候，dp[0] [j] 应该是 0，因为背包容量比编号0的物品重量还小。</p>
</li>
<li><p>当j &gt;&#x3D; weight[0]时，dp[0] [j] 应该是value[0]，因为背包容量放足够放编号0物品。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/20210110103109140.png" alt="动态规划-背包问题7"></p>
</li>
</ul>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>在如下图中，可以看出，有两个遍历的维度：物品与背包重量<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/2021011010314055.png" alt="动态规划-背包问题3"></p>
<p>那么问题来了，<strong>先遍历 物品还是先遍历背包重量呢？其实都可以！！ 但是先遍历物品更好理解</strong>。</p>
<p>为什么也是可以的呢？</p>
<p><strong>要理解递归的本质和递推的方向</strong>。</p>
<p>dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 递归公式中可以看出dp[i] [j]是靠dp[i-1] [j]和dp[i - 1] [j - weight[i]]推导出来的。</p>
<p>dp[i-1] [j]和dp[i - 1] [j - weight[i]] 都在dp[i] [j]的左上角方向（包括正上方向），那么先遍历物品，再遍历背包的过程如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/202101101032124.png" alt="动态规划-背包问题5"></p>
<p>再来看看先遍历背包，再遍历物品呢，如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/20210110103244701.png" alt="动态规划-背包问题6"></p>
<p><strong>大家可以看出，虽然两个for循环遍历的次序不同，但是dp[i] [j]所需要的数据就是左上角，根本不影响dp[i] [j]公式的推导！</strong></p>
<p>但先遍历物品再遍历背包这个顺序更好理解。</p>
<p><strong>其实背包问题里，两个for循环的先后循序是非常有讲究的，理解遍历顺序其实比理解推导公式难多了</strong>。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>来看一下对应的dp数组的数值，如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/20210118163425129.jpg" alt="动态规划-背包问题4"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bagProblem2</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] values, <span class="type">int</span> bagSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. dp[i][j]表示背包容量为j装0-i物品时的最大价值</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[weight.length][bagSize + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 2. 初始化 dp[0][j]表示重量为j时装第一个物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> weight[<span class="number">0</span>]; i &lt;= bagSize; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = values[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp[i][0] 背包容量为0，那么装不了任何物品 dp[i][0]=0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; weight.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= bagSize; j++) &#123;</span><br><span class="line">            <span class="comment">// 3. 状态转移方程，装或者不装第i个物品</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[weight.length - <span class="number">1</span>][bagSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] values = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    System.out.println(bagProblem2(weight, values, <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="一维dp（滚动数组）"><a href="#一维dp（滚动数组）" class="headerlink" title="一维dp（滚动数组）"></a>一维dp（滚动数组）</h4><p>对于背包问题其实状态都是可以压缩的。</p>
<p>在使用二维数组的时候，递推公式：dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);</p>
<p><strong>其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i] [j] &#x3D; max(dp[i] [j], dp[i] [j - weight[i]] + value[i]);</strong></p>
<p><strong>与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了</strong>，只用dp[j]（一维数组，也可以理解是一个滚动数组）。</p>
<p>这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。</p>
<p><strong>dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p>
<hr>
<ol>
<li>确定dp数组的定义</li>
</ol>
<p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p>
<ol start="2">
<li>一维dp数组的递推公式</li>
</ol>
<p>dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？</p>
<p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p>
<p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p>
<p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1] [j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，<code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</code></p>
<ol start="3">
<li>一维dp数组如何初始化</li>
</ol>
<p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p>
<p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p>
<p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p>
<p>看一下递归公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p>
<p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p>
<p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p>
<ol start="4">
<li>一维dp数组遍历顺序</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！</strong></p>
<p>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。为什么呢？</p>
<p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p>
<p>举一个例子：物品0的重量weight[0] &#x3D; 1，价值value[0] &#x3D; 15</p>
<p>如果正序遍历</p>
<p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p>
<p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 30</p>
<p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p>
<p>为什么倒序遍历，就可以保证物品只放入一次呢？</p>
<p>倒序就是先算dp[2]</p>
<p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 15 （dp数组已经都初始化为0）</p>
<p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p>
<p>所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</p>
<p><strong>那么问题又来了，为什么二维dp数组历的时候不用倒序呢？</strong></p>
<p>因为对于二维dp，dp[i] [j]都是通过上一层即dp[i - 1] [j]计算而来，本层的dp[i] [j]并不会被覆盖！</p>
<p>（如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！）</p>
<p><strong>再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？</strong></p>
<p>不可以！</p>
<p>因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</p>
<p>倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。</p>
<p>（这里如果读不懂，就在回想一下dp[j]的定义，或者就把两个for循环顺序颠倒一下试试！）</p>
<p><strong>所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！</strong>，这一点大家一定要注意。</p>
<ol start="5">
<li>举例推导dp数组<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/20210110103614769-166968836378612.png" alt="动态规划-背包问题9"></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bagProblem1</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] values, <span class="type">int</span> bagSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. dp[j]表示背包容量为j时的最大价值</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[bagSize + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 初始化 dp[0]=0 容量为0的背包装不了物品</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 遍历顺序 一定是先物品再背包 ，</span></span><br><span class="line">    <span class="comment">// 一维dp是从二维的优化，本质上还是从左上角来推， 但是因为背包容量要倒序遍历，防止放入多个商品，所以一定要先遍历物品。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagSize; j &gt;= weight[i]; j--) &#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - weight[i]] + values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[bagSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] values = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    System.out.println(bagProblem2(weight, values, <span class="number">4</span>));</span><br><span class="line">    System.out.println(bagProblem1(weight, values, <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几个注意点：</p>
<ol>
<li>背包容量是倒序遍历的，防止放入多个商品，重复。</li>
<li>遍历的顺序不能改变，因为要从左上角往右下推。</li>
<li>遍历时有个小细节 j &gt;&#x3D; weight[i]终止循环，防止越界，省去了if判断。</li>
<li>和二维dp相比，一维dp是把dp[i-1] [j]的选项通过遍历合并到了dp[j]。</li>
</ol>
<h3 id="7-5、完全背包问题"><a href="#7-5、完全背包问题" class="headerlink" title="7.5、完全背包问题"></a>7.5、完全背包问题</h3><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件.</strong></p>
<p>案例：</p>
<p>背包最大重量为4。</p>
<p>物品为：</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p>01背包和完全背包唯一不同就是体现在遍历顺序上。</p>
<p>01背包的核心代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。</p>
<p>而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dp状态图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/20210126104510106.jpg" alt="动态规划-完全背包"></p>
<p><strong>为什么遍历物品在外层循环，遍历背包容量在内层循环？</strong></p>
<p>01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。</p>
<p><strong>在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！</strong></p>
<p>因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。</p>
<p>遍历物品在外层循环，遍历背包容量在内层循环，状态如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/20210126104529605.jpg" alt="动态规划-完全背包1"></p>
<p>遍历背包容量在外层循环，遍历物品在内层循环，状态如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/20210729234011.png" alt="动态规划-完全背包2"></p>
<p>看了这两个图，大家就会理解，完全背包中，两个for循环的先后循序，都不影响计算dp[j]所需要的值（这个值就是下标j之前所对应的dp[j]）。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完全背包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bagProblem3</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] values, <span class="type">int</span> bagSize)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. dp[j]表示背包容量为j时的最大价值</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[bagSize + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 2. 初始化 dp[0]=0 容量为0的背包装不了物品</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 对于完全背包先遍历物品或者背包都可以，而且遍历容量时是从前往后的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> weight[i]; j &lt;= bagSize; j++) &#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - weight[i]] + values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[bagSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-6、动态规划解题框架"><a href="#7-6、动态规划解题框架" class="headerlink" title="7.6、动态规划解题框架"></a>7.6、动态规划解题框架</h3><p>若确定给定问题具有重叠子问题和最优子结构，那么就可以使用动态规划求解。总体上看，求解可分为四步：</p>
<ol>
<li>状态定义： 构建问题最优解模型，包括问题最优解的定义、有哪些计算解的自变量；</li>
<li>初始状态： 确定基础子问题的解（即已知解），原问题和子问题的解都是以基础子问题的解为起始点，在迭代计算中得到的；</li>
<li>转移方程： 确定原问题的解与子问题的解之间的关系是什么，以及使用何种选择规则从子问题最优解组合中选出原问题最优解；</li>
<li>返回值： 确定应返回的问题的解是什么，即动态规划在何处停止迭代；</li>
</ol>
<p>完成以上步骤后，便容易写出对应的解题代码。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202210311209375.png" alt="image-20221031120901274"></p>
<h3 id="7-5、剑指-Offer-10-I-斐波那契数列"><a href="#7-5、剑指-Offer-10-I-斐波那契数列" class="headerlink" title="7.5、剑指 Offer 10- I. 斐波那契数列"></a>7.5、剑指 Offer 10- I. 斐波那契数列</h3><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>

<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 100</code></li>
</ul>
<p>Related Topics</p>
<p>记忆化搜索</p>
<p>数学</p>
<p>动态规划</p>
<blockquote>
<p>相比于一般的fib加了取余数的过程</p>
</blockquote>
<h4 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记忆化搜索</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];<span class="comment">//记录之前搜索的数据</span></span><br><span class="line">        <span class="keyword">return</span> fibonacci(n, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] dp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[n] != <span class="number">0</span>) <span class="keyword">return</span> dp[n];<span class="comment">//如果之前有记录 直接返回</span></span><br><span class="line">        <span class="keyword">else</span> dp[n] = (fibonacci(n - <span class="number">1</span>, dp) + fibonacci(n - <span class="number">2</span>, dp)) % <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h4><h3 id="7-6、剑指-Offer-19-正则表达式匹配"><a href="#7-6、剑指-Offer-19-正则表达式匹配" class="headerlink" title="7.6、剑指 Offer 19. 正则表达式匹配"></a>7.6、剑指 Offer 19. 正则表达式匹配</h3><p>请实现一个函数用来匹配包含<code>&#39;. &#39;</code>和<code>&#39;*&#39;</code>的正则表达式。模式中的字符<code>&#39;.&#39;</code>表示任意一个字符，而<code>&#39;*&#39;</code>表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<code>&quot;aaa&quot;</code>与模式<code>&quot;a.a&quot;</code>和<code>&quot;ab*ac*a&quot;</code>匹配，但与<code>&quot;aa.a&quot;</code>和<code>&quot;ab*a&quot;</code>均不匹配。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#x27;*&#x27; 表示零个或多个，这里 &#x27;c&#x27; 为 0 个, &#x27;a&#x27; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 5:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母以及字符 <code>.</code> 和 <code>*</code>，无连续的 <code>&#39;*&#39;</code>。</li>
</ul>
<hr>
<p><strong>解题思路</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211011104013.png" alt="image-20221101110409896"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1614516402-HyzAil-Picture1.png" alt="Picture1.png"></p>
<p>因此，本题的状态共有 m×n 种，应定义状态矩阵 dp ，dp[i] [j]代表 s[:i] 与 p[:j] 是否可以匹配。</p>
<p>做好状态定义，接下来就是根据 「普通字符」 , 「.」 , 「*」三种字符的功能定义，分析出动态规划的转移方程。</p>
<p><strong>动态规划解析：</strong></p>
<ul>
<li><p><strong>状态定义：</strong> 设动态规划矩阵 dp ， dp[i] [j] 代表字符串 s 的前 i 个字符和 p 的前 j 个字符能否匹配。</p>
</li>
<li><p><strong>转移方程：</strong> 需要注意，由于 dp[0] [0] 代表的是空字符的状态， 因此 dp[i] [j] 对应的添加字符是 s[i - 1] 和 p[j - 1] 。</p>
<ul>
<li>当 p[j - 1] &#x3D; ‘*’ 时， dp[i] [j] 在当以下任一情况为 true 时等于 true ：<ul>
<li>dp[i] [j - 2]： 即将字符组合 p[j - 2] * 看作出现 0 次时，能否匹配；</li>
<li>dp[i - 1] [j] 且 s[i - 1] &#x3D; p[j - 2] : 即让字符 p[j - 2] 多出现 1 次时，能否匹配；</li>
<li>dp[i - 1] [j] 且 p[j - 2] &#x3D; ‘.’ : 即让字符 ‘.’ 多出现 1 次时，能否匹配；</li>
</ul>
</li>
<li>当 p[j - 1] !&#x3D; ‘*’ 时， dp[i] [j] 在当以下任一情况为 true 时等于 true ：<ul>
<li>dp[i - 1] [j - 1] 且 s[i - 1] &#x3D; p[j - 1]： 即让字符 p[j - 1] 多出现一次时，能否匹配；</li>
<li>dp[i - 1] [j - 1] 且 p[j - 1] &#x3D; ‘.’： 即将字符 . 看作字符 s[i - 1] 时，能否匹配；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>初始化：</strong> 需要先初始化 dp 矩阵首行，以避免状态转移时索引越界。</p>
<ul>
<li>dp[0] [0] &#x3D; true： 代表两个空字符串能够匹配。<br>dp[0] [j] &#x3D; dp[0] [j - 2] 且 p[j - 1] &#x3D; ‘*’： 首行 s 为空字符串，因此当 p 的偶数位为 * 时才能够匹配（即让 p 的奇数位出现 0 次，保持 p 是空字符串）。因此，循环遍历字符串 p ，步长为 2（即只看偶数位）。<br>返回值： dp 矩阵右下角字符，代表字符串 s 和 p 能否匹配。</li>
</ul>
</li>
<li><p><strong>返回值：</strong> <code>dp</code> 矩阵右下角字符，代表字符串 <code>s</code> 和 <code>p</code> 能否匹配。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1614516402-MacqQq-Picture4.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1614516402-ATFWBt-Picture6.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1614516402-HHmdNJ-Picture12.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1614516402-bBdFaG-Picture13.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.leetcode-cn.com/1614516402-ibjjpB-Picture18.png" alt="img"></p>
<p><strong>复杂度分析：</strong><br>时间复杂度 O(MN)： 其中 M, N分别为 s 和 p 的长度，状态转移需遍历整个 dp 矩阵。<br>空间复杂度 O(MN)： 状态矩阵 dp 使用 O(MN)的额外空间。</p>
<h3 id="7-7、剑指-Offer-46-把数字翻译成字符串"><a href="#7-7、剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="7.7、剑指 Offer 46. 把数字翻译成字符串"></a>7.7、剑指 Offer 46. 把数字翻译成字符串</h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>dp[0] [i] i个数字对应最多的翻译(i不参加翻译）</li>
<li>dp[1] [i] i个数字对应最多的翻译(i参加翻译）</li>
</ul>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= num &lt; 231</code></li>
</ul>
<p>Related Topics</p>
<p>字符串</p>
<p>动态规划0</p>
<p><strong>解题思路：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211161709589.png" alt="Picture1.png"></p>
<ul>
<li>确定dp[i]的含义：dp[i] 代表以 xi 为结尾的数字的翻译方案数量。</li>
<li>确定状态转移方程为</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211161716249.png" alt="image-20221116171600192"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当xi-1和xi能一起翻译时，dp[i] = dp[i - 1] + dp[i - 2]；</span><br><span class="line">因为可以选择xi和xi-1按顺序翻译dp[i-1]，也可以选择xi和xi-1一起翻译dp[i-2].</span><br><span class="line">当xi-1和xi不能一起翻译时，dp[i] = dp[i - 1]；</span><br><span class="line">因为只能按顺序翻译，dp[i-1]</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化dp[0]&#x3D;1(为了第二个位置准备),dp[1]&#x3D;1</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> num + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// dp[0] [i] 第i个数字对应最多的翻译</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据状态转移方程遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">2</span>) &lt; <span class="string">&#x27;2&#x27;</span> &amp;&amp; s.charAt(i - <span class="number">2</span>) &gt; <span class="string">&#x27;0&#x27;</span> || (s.charAt(i - <span class="number">2</span>) == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) &lt;= <span class="string">&#x27;5&#x27;</span>)) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(N)</p>
<p>空间复杂度O(N)</p>
<ul>
<li>可以用循环不变量让时间复杂度降为O(1)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> num + <span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="comment">// 初始化</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//dp[i-2]</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//dp[i-1]</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//根据状态转移方程遍历</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; s.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (s.charAt(i - <span class="number">2</span>) &lt; <span class="string">&#x27;2&#x27;</span> &amp;&amp; s.charAt(i - <span class="number">2</span>) &gt; <span class="string">&#x27;0&#x27;</span> || (s.charAt(i - <span class="number">2</span>) == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s.charAt(i - <span class="number">1</span>) &lt;= <span class="string">&#x27;5&#x27;</span>)) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">               a = b;</span><br><span class="line">               b = c;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           	a = b;</span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不是用字符串，直接使用数字来取余，省去字符串的O(N)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//dp[i - 2]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//dp[i - 1]</span></span><br><span class="line">        <span class="type">int</span> x;<span class="comment">//</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> num % <span class="number">10</span>;<span class="comment">//最后一位</span></span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">            x = num % <span class="number">10</span>;<span class="comment">//倒数第二位</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">10</span> * x + y;<span class="comment">//算值</span></span><br><span class="line">            <span class="keyword">if</span> (tmp &gt;= <span class="number">10</span> &amp;&amp; tmp &lt;= <span class="number">25</span>) &#123;<span class="comment">//可以两位一起算</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">                a = b;</span><br><span class="line">                b = c;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	a = b;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-8、剑指-Offer-47-礼物的最大价值"><a href="#7-8、剑指-Offer-47-礼物的最大价值" class="headerlink" title="7.8、剑指 Offer 47. 礼物的最大价值"></a>7.8、剑指 Offer 47. 礼物的最大价值</h3><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>0 &lt; grid.length &lt;= 200</code></li>
<li><code>0 &lt; grid[0].length &lt;= 200</code></li>
</ul>
<p>Related Topics</p>
<p>数组</p>
<p>动态规划</p>
<p>矩阵</p>
<p><strong>解题思路：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211161855965.png" alt="Picture1.png"></p>
<ul>
<li><p>dp数组的含义：直接在原grid[] []上进行修改，表示从起到到grid[i] [j]的最大价值</p>
</li>
<li><p>确定状态转移公式</p>
<p>对于两个边grid[0] [j]是从起点来进行累加<code>grid[0] [j] = grid[0] [j - 1] + grid[0] [j]</code>；</p>
<p>和grid[i] [0]是从起点来进行累加<code>grid[i] [0] = grid[i - 1] [0] + grid[i] [0]</code>;</p>
<p>对于其他的位置<code>grid[i] [j] = max(grid[i - 1] [j], grid[i] [j - 1]) + grid[i] [j];</code></p>
</li>
<li><p>初始化：不用初始化</p>
</li>
<li><p>确定遍历顺序：一行一行遍历就行，依赖的位置是上方和左边。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                grid[i][j] += Math.max(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.length - <span class="number">1</span>][grid[<span class="number">0</span>].length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(M*N)</p>
<p>空间复杂度O(1)</p>
<h3 id="7-9、剑指-Offer-48-最长不含重复字符的子字符串"><a href="#7-9、剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="7.9、剑指 Offer 48. 最长不含重复字符的子字符串"></a>7.9、剑指 Offer 48. 最长不含重复字符的子字符串</h3><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>



<p>提示：</p>
<ul>
<li><code>s.length &lt;= 40000</code></li>
</ul>
<p>Related Topics</p>
<p>哈希表</p>
<p>字符串</p>
<p>滑动窗口</p>
<p><strong>解题思路</strong>：</p>
<hr>
<p><strong>确定dp数组的含义</strong>：dp[i]表示以s[i]结尾的最长不重复字符的字符串长度。</p>
<p><strong>确定递推公式</strong>：</p>
<p>用一个哈希表记录上一个字符对应的下标位置，之后如果再遇到该字符就更新下标。</p>
<p>当map没有该字符的记录时（该字符第一次出现）<code>dp[i] = dp[i - 1] + 1;</code></p>
<p>当map中有该记录，那么有两种可能:</p>
<ul>
<li>两个字符间的字符串没有出现重复<code>dp[i] = i - index;</code></li>
<li>字符间的字符存在重复<code>dp[i] = dp[i - 1] + 1;</code></li>
</ul>
<p>两者取最小值，故<code>dp[i] = Math.min(i - index, dp[i - 1] + 1);</code></p>
<hr>
<p>状态转移的优化，利用i - index来和dp[j-i]判断，map记录字符的前一个下标位置。这样可以合并状态转移方程。、</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211170935479.png" alt="image-20221117093534354"></p>
<p><strong>初始化</strong>：</p>
<p>因为状态转移方程用到了dp[i - 1]所以对dp[0]进行初始化，dp[0]表示第一个字符的最长不含重复字符的长度，故为1。并把下标加入map中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(s, <span class="string">&quot;&quot;</span>) || s == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp[i]表示以s[i]结尾的最长不重复字符的字符串长度</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    map.put(s.charAt(<span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (map.getOrDefault(c, -<span class="number">1</span>) == -<span class="number">1</span>) &#123; <span class="comment">//表中没存记录</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在表中有记录</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(c);<span class="comment">//拿到他的位置</span></span><br><span class="line">            dp[i] = Math.min(i - index, dp[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(c, i);<span class="comment">// 存入map or 理解为更新map的值</span></span><br><span class="line">        res = Math.max(dp[i], res);<span class="comment">// res取最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(N)</p>
<p>空间上的优化，利用临时变量tmp记录，每个过程只更新最大的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, tmp = <span class="number">0</span>, len = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> set.getOrDefault(s.charAt(j), -<span class="number">1</span>); <span class="comment">// 获取索引 i</span></span><br><span class="line">            set.put(s.charAt(j), j); <span class="comment">// 更新哈希表</span></span><br><span class="line">            tmp = tmp &lt; j - i ? tmp + <span class="number">1</span> : j - i; <span class="comment">// dp[j - 1] . dp[j]</span></span><br><span class="line">            res = Math.max(res, tmp); <span class="comment">// max(dp[j - 1], dp[j])</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="剑指 Offer 49. 丑数"></a>剑指 Offer 49. 丑数</h3><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li><code>1</code> 是丑数。</li>
<li><code>n</code> <strong>不超过</strong>1690。</li>
</ol>
<p>注意：本题与主站 264 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ugly-number-ii/">https://leetcode-cn.com/problems/ugly-number-ii/</a></p>
<p>Related Topics</p>
<p>哈希表</p>
<p>数学</p>
<p>动态规划</p>
<p>堆（优先队列）</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>丑数的递推性质： 丑数只包含因子 2, 3, 5 ，因此有 “丑数 &#x3D;&#x3D; 某较小丑数 \times× 某因子” （例如10&#x3D;5×2）。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211170958398.png" alt="image-20221117095848322"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211170959923.png" alt="Picture1.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xa是第一个×2大于xn的丑数</span><br><span class="line">xb是第一个×3大于xn的丑数</span><br><span class="line">xc是第一个×5大于xn的丑数</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211171001480.png" alt="image-20221117100102405"></p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N)O(N) ： 其中N&#x3D;n ，动态规划需遍历计算 dp 列表。</li>
<li>空间复杂度 O(N)O(N) ： 长度为N 的dp 列表使用 O(N) 的额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> dp[a] * <span class="number">2</span>, n3 = dp[b] * <span class="number">3</span>, n5 = dp[c] * <span class="number">5</span>;</span><br><span class="line">        dp[i] = Math.min(Math.min(n2, n3), n5);</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == n2) a++;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == n3) b++;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == n5) c++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-10、剑指-Offer-60-n-个骰子的点数"><a href="#7-10、剑指-Offer-60-n-个骰子的点数" class="headerlink" title="7.10、剑指 Offer 60. n 个骰子的点数"></a>7.10、剑指 Offer 60. n 个骰子的点数</h3><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
<p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= n &lt;= 11</span><br></pre></td></tr></table></figure>

<p>Related Topics</p>
<p>数学</p>
<p>动态规划</p>
<p>概率与统计</p>
<p>👍 496</p>
<p>👎 0</p>
<h4 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211181001768.png" alt="image-20221118100112673"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211181001882.png" alt="Picture1.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211181001271.png" alt="image-20221118100149197"></p>
<h4 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h4><blockquote>
<p>设输入 n 个骰子的解（即概率列表）为 f(n) ，其中「点数和」 x的概率为 f(n, x) 。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211181004718.png" alt="image-20221118100410639"></p>
<blockquote>
<p>如下图所示，为 n &#x3D; 2, x &#x3D; 7的递推计算示例。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211181018233.png" alt="Picture2.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211181023640.png" alt="image-20221118102304571"></p>
<blockquote>
<p>如下图所示，以上递推公式是 “逆向” 的，即为了计算f(n,x) ，将所有与之有关的情况求和；而倘若改换为 “正向” 的递推公式，便可解决越界问题。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211181025269.png" alt="Picture3.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211181027924.png" alt="image-20221118102715860"></p>
<blockquote>
<p>将 f(i) 记为动态规划列表形式 dp[i]，则 i &#x3D; 1, 2, …, n 的状态转移过程如下图所示。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211181028153.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211181029199.png" alt="image-20221118102956132"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span>[] setesProbability(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">double</span>[] dp = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">6</span>];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1.0</span> / <span class="number">6.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123; <span class="comment">//遍历次数</span></span><br><span class="line">        <span class="type">double</span>[] tmp = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">5</span> * i + <span class="number">1</span>];<span class="comment">// 6 * n - n + 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; dp.length; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">6</span>; k++) &#123;</span><br><span class="line">                tmp[j + k] += dp[j] / <span class="number">6.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-11、剑指-Offer-63-股票的最大利润"><a href="#7-11、剑指-Offer-63-股票的最大利润" class="headerlink" title="7.11、剑指 Offer 63. 股票的最大利润"></a>7.11、剑指 Offer 63. 股票的最大利润</h3><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 数组长度 &lt;= 10^5</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong>本题与主站 121 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p>
<p>Related Topics</p>
<p>数组</p>
<p>动态规划</p>
<p><strong>解题思路：</strong></p>
<ol>
<li><p>确定dp数组</p>
<p>dp[i] [0]:表示第i天不持有股票的最大收益</p>
<p>dp[i] [1]:表示第i天持有股票的最大收益</p>
</li>
<li><p>确定状态转移方程</p>
<p>第i天不持有股票，说明他在第i天买了，或者在之前的天买过。如果之前的天数买过，那么<code>dp[i] [0] = dp[i - 1] [0]</code>。如果第i天才买股票，<code>dp[i] [0] = dp[i - 1] [1] + prices[i]</code>。</p>
<p>故状态转移方程为<code>dp[i] [0] = max(dp[i - 1] [0], dp[i - 1] [1] + prices[i])</code></p>
<p>第i天持有股票的话，说明他在之前买了股票没卖，或者今天才买股票。<code>dp[i] [1] = dp[i - 1] [1];</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[i] [0]:表示第i天不持有股票的最大收益</span></span><br><span class="line">    <span class="comment">//dp[i] [1]:表示第i天持有股票的最大收益</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        dp[i] [<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>] [<span class="number">0</span>], dp[i - <span class="number">1</span>] [<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i] [<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另一种解法：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211181056360.png" alt="image-20221118105652244"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211181057095.png" alt="Picture1.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211181100550.png" alt="image-20221118110003462"></p>
<p><strong>优化空间为O(1)</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211181100800.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> Integer.MAX_VALUE, profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> price : prices) &#123;</span><br><span class="line">            cost = Math.min(cost, price);</span><br><span class="line">            profit = Math.max(profit, price - cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、搜索与回溯算法"><a href="#八、搜索与回溯算法" class="headerlink" title="八、搜索与回溯算法"></a>八、搜索与回溯算法</h2><h3 id="8-1、剑指-Offer-12-矩阵中的路径"><a href="#8-1、剑指-Offer-12-矩阵中的路径" class="headerlink" title="8.1、剑指 Offer 12. 矩阵中的路径"></a>8.1、剑指 Offer 12. 矩阵中的路径</h3><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>解题思路：</strong><br>本问题是典型的矩阵搜索问题，可使用 深度优先搜索（DFS）+ 剪枝 解决。</p>
<ul>
<li><strong>深度优先搜索：</strong> 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li>
<li><strong>剪枝：</strong> 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。</li>
</ul>
<p><strong>DFS 解析：</strong></p>
<ul>
<li>递归参数： 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。</li>
<li>终止条件：<ol>
<li>返回 false： (1) 行或列索引越界 或 (2) 当前矩阵元素与目标字符不同 或 (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ） 。</li>
<li>返回 true ： k &#x3D; len(word) - 1 ，即字符串 word 已全部匹配。</li>
</ol>
</li>
<li>递推工作：<ol>
<li>标记当前矩阵元素： 将 board[i] [j] 修改为 空字符 ‘ ‘，代表此元素已访问过，防止之后搜索时重复访问。</li>
<li>搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 res 。</li>
<li>还原当前矩阵元素： 将 board[i] [j] 元素还原至初始值，即 word[k] 。</li>
</ol>
</li>
<li>返回值： 返回布尔量 res ，代表是否搜索到目标字符串。</li>
</ul>
<p><strong>复杂度分析：</strong><br>M,N 分别为矩阵行列大小， K 为字符串 word 长度。</p>
<ul>
<li>时间复杂度 O(3^KMN)： 最差情况下，需要遍历矩阵中长度为 K 字符串的所有方案，时间复杂度为 O(3^K)；矩阵中共有 MN个起点，时间复杂度为O(MN) 。<ul>
<li>方案数计算： 设字符串长度为 K ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 3 种选择，因此方案数的复杂度为 O(3^K)</li>
</ul>
</li>
<li>空间复杂度 O(K) ： 搜索过程中的递归深度不超过 K ，因此系统因函数调用累计使用的栈空间占用 O(K) （因为函数返回后，系统调用的栈空间会释放）。最坏情况下 K &#x3D; MN，递归深度为 MN，此时系统栈使用 O(MN) 的额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, words, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">char</span>[] word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= board.length || i &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || j &lt; <span class="number">0</span> || board[i][j] != word[k]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == word.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> dfs(board, word, i + <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(board, word, i - <span class="number">1</span>, j, k + <span class="number">1</span>) || </span><br><span class="line">                      dfs(board, word, i, j + <span class="number">1</span>, k + <span class="number">1</span>) || dfs(board, word, i , j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        board[i][j] = word[k];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2、剑指-Offer-13-机器人的运动范围"><a href="#8-2、剑指-Offer-13-机器人的运动范围" class="headerlink" title="8.2、剑指 Offer 13. 机器人的运动范围"></a>8.2、剑指 Offer 13. 机器人的运动范围</h3><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0] </code>的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 2, n = 3, k = 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 1, k = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n,m &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= 20</code></li>
</ul>
<p>Related Topics</p>
<p>深度优先搜索</p>
<p>广度优先搜索</p>
<p>动态规划</p>
<p><strong>解题思路：</strong></p>
<ol>
<li>确定DFS深度优先搜索。</li>
<li>用vist数组记录，用来剪枝。</li>
<li>向上下左右四个方向搜索。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 记录[i,j]位置有没有访问过，true访问过，false没访问过</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="type">boolean</span>[][] visit = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">return</span> backtarcking(visit, <span class="number">0</span>, <span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">backtarcking</span><span class="params">(<span class="type">boolean</span>[][] visit, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || col &lt; <span class="number">0</span> || row &gt; visit.length || col &gt; visit[<span class="number">0</span>].length || (row % <span class="number">10</span> + row / <span class="number">10</span> + col % <span class="number">10</span> + col / <span class="number">10</span>) &gt; k || visit[row][col]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visit[row][col] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//向四个方向搜索</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> backtarcking(visit, row - <span class="number">1</span>, col, k);<span class="comment">//上</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> backtarcking(visit, row + <span class="number">1</span>, col, k);<span class="comment">//下</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> backtarcking(visit, row, col - <span class="number">1</span>, k);<span class="comment">//左</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> backtarcking(visit, row, col + <span class="number">1</span>, k);<span class="comment">//右</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + a + b + c + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211191155225.png" alt="image-20221119115452914"></p>
<p>复杂度分析：<br>设矩阵行列数分别为 M, N。</p>
<p>时间复杂度 O(MN)： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN)。<br>空间复杂度 O(MN) ： 最差情况下，Set visited 内存储矩阵所有单元格的索引，使用 O(MN)的额外空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211191157599.png" alt="image-20221119115705308"></p>
<p>复杂度分析：<br>设矩阵行列数分别为 M, N。</p>
<p>时间复杂度 O(MN)： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN)。<br>空间复杂度 O(MN) ： 最差情况下，Set visited 内存储矩阵所有单元格的索引，使用 O(MN)的额外空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue= <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span>[] x = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x[<span class="number">0</span>], j = x[<span class="number">1</span>], si = x[<span class="number">2</span>], sj = x[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; si + sj || visited[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">            res ++;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i + <span class="number">1</span>, j, (i + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? si + <span class="number">1</span> : si - <span class="number">8</span>, sj &#125;);</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j + <span class="number">1</span>, si, (j + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? sj + <span class="number">1</span> : sj - <span class="number">8</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3、剑指-Offer-26-树的子结构"><a href="#8-3、剑指-Offer-26-树的子结构" class="headerlink" title="8.3、剑指 Offer 26. 树的子结构"></a>8.3、剑指 Offer 26. 树的子结构</h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,2,3], B = [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [3,4,5,1,2], B = [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 节点个数 &lt;= 10000</span><br></pre></td></tr></table></figure>

<p>Related Topics</p>
<p>树</p>
<p>深度优先搜索</p>
<p>二叉树</p>
<p><strong>解题思路：</strong><br>若树 B 是树 A 的子结构，则子结构的根节点可能为树 A 的任意一个节点。因此，判断树 B 是否是树 A 的子结构，需完成以下两步工作：</p>
<ol>
<li>先序遍历树 A 中的每个节点 nA（对应函数 isSubStructure(A, B)）</li>
<li>判断树 A 中 以 nA 为根节点的子树 是否包含树 B 。（对应函数 recur(A, B)）</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211191500296.png" alt="Picture1.png"></p>
<p><strong>算法流程：</strong></p>
<blockquote>
<p>本文名词规定：树 A 的根节点记作 节点 A ，树 B 的根节点称为 节点 B 。</p>
</blockquote>
<p><code>recur(A, B)</code> 函数：</p>
<ol>
<li>终止条件：<ol>
<li>当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true ；</li>
<li>当节点 A 为空：说明已经越过树 A 的叶节点，即匹配失败，返回 false ；</li>
<li>当节点 A 和 B 的值不同：说明匹配失败，返回 false ；</li>
</ol>
</li>
<li>返回值：<ol>
<li>判断 A 和 B 的 左子节点 是否相等，即 recur(A.left, B.left) ；</li>
<li>判断 A 和 B 的 右子节点 是否相等，即 recur(A.right, B.right) ；</li>
</ol>
</li>
</ol>
<p><code>isSubStructure(A, B)</code> 函数：</p>
<ol>
<li>特例处理： 当 树 A 为空 或 树 B 为空 时，直接返回 false ；</li>
<li>返回值： 若树 B 是树 A 的子结构，则必满足以下三种情况之一，因此用或 || 连接；<ol>
<li>以 节点 A 为根节点的子树 包含树 B ，对应 recur(A, B)；</li>
<li>树 B 是 树 A 左子树 的子结构，对应 isSubStructure(A.left, B)；</li>
<li>树 B 是 树 A 右子树 的子结构，对应 isSubStructure(A.right, B)；</li>
</ol>
</li>
</ol>
<blockquote>
<p>以上 2. 3. 实质上是在对树 A 做 先序遍历 。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211191503691.png" alt="img"></p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(MN) ： 其中 M, N分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 O(M) ，每次调用 recur(A, B) 判断占用 O(N)。</li>
<li>空间复杂度 O(M) ： 当树 A 和树 B 都退化为链表时，递归调用深度最大。当 M≤N 时，遍历树 A 与递归判断的总递归深度为 M ；当 M&gt;N 时，最差情况为遍历至树 A 的叶节点，此时总递归深度为 M。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (A != <span class="literal">null</span> &amp;&amp; B != <span class="literal">null</span>) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (B == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4、剑指-Offer-27-二叉树的镜像"><a href="#8-4、剑指-Offer-27-二叉树的镜像" class="headerlink" title="8.4、剑指 Offer 27. 二叉树的镜像"></a>8.4、剑指 Offer 27. 二叉树的镜像</h3><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
<p><code>     4    /   \   2     7  / \   / \ 1   3 6   9</code><br>镜像输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4    /   \   7     2  / \   / \ 9   6 3   1</span><br></pre></td></tr></table></figure>



<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 节点个数 &lt;= 1000</span><br></pre></td></tr></table></figure>

<p>注意：本题与主站 226 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">https://leetcode-cn.com/problems/invert-binary-tree/</a></p>
<p>Related Topics</p>
<p>树</p>
<p>深度优先搜索</p>
<p>广度优先搜索</p>
<p>二叉树</p>
<p>👍 320</p>
<p>👎 0</p>
<p><strong>解题思路：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tva1.sinaimg.cn/large/008eGmZEly1gnakm26jtog30e409s4qp.gif" alt="翻转二叉树"></p>
<p>递归三部曲：</p>
<ol>
<li>确定递归函数的参数和返回值</li>
</ol>
<p>参数就是要传入节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归的逻辑中发现还需要其他参数的时候，随时补充。</p>
<p>返回值的话其实也不需要，但是题目中给出的要返回root节点的指针，可以直接使用题目定义好的函数，所以就函数的返回类型为<code>TreeNode*</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>确定终止条件</li>
</ol>
<p>当前节点为空的时候，就返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>确定单层递归的逻辑</li>
</ol>
<p>因为是先前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(root.left, root.right);</span><br><span class="line"><span class="built_in">invertTree</span>(root.left);</span><br><span class="line"><span class="built_in">invertTree</span>(root.right);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> recur(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">recur</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    recur(root.left);</span><br><span class="line">    recur(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-5、剑指-Offer-28-对称的二叉树"><a href="#8-5、剑指-Offer-28-对称的二叉树" class="headerlink" title="8.5、剑指 Offer 28. 对称的二叉树"></a>8.5、剑指 Offer 28. 对称的二叉树</h3><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<p><code>    1    / \   2   2  / \ / \ 3  4 4  3</code><br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1    / \   2   2    \   \    3    3</span><br></pre></td></tr></table></figure>



<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 节点个数 &lt;= 1000</span><br></pre></td></tr></table></figure>

<p>注意：本题与主站 101 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">https://leetcode-cn.com/problems/symmetric-tree/</a></p>
<p>Related Topics</p>
<p>树</p>
<p>深度优先搜索</p>
<p>广度优先搜索</p>
<p>二叉树</p>
<p>👍 397</p>
<p>👎 0</p>
<p>首先想清楚，要比较的可不是左右节点！对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的,其实我们要比较的是两个树（这两个树是根节点的左右子树），所以在递归遍历的过程中，也是要同时遍历两棵树。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211201040962.png" alt="101. 对称二叉树1"></p>
<p>那么遍历的顺序应该是什么样的呢？</p>
<p>本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。</p>
<p><strong>正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</strong></p>
<p>但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。</p>
<hr>
<p><strong>递归三部曲</strong></p>
<ol>
<li>确定递归函数的参数和返回值</li>
</ol>
<p>因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。</p>
<p>返回值自然是bool类型。</p>
<p>代码如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool compare(TreeNode* left, TreeNode* right)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>确定终止条件</li>
</ol>
<p>要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。</p>
<p>节点为空的情况有：（<strong>注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点</strong>）</p>
<ul>
<li>左节点为空，右节点不为空，不对称，return false</li>
<li>左不为空，右为空，不对称 return false</li>
<li>左右都为空，对称，返回true</li>
</ul>
<p>此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：</p>
<ul>
<li>左右都不为空，比较节点数值，不相同就return false</li>
</ul>
<p>此时左右节点不为空，且数值也不相同的情况我们也处理了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 注意这里我没有使用else</span></span><br></pre></td></tr></table></figure>

<p>注意上面最后一种情况，我没有使用else，而是else if， 因为我们把以上情况都排除之后，剩下的就是 左右节点都不为空，且数值相同的情况。</p>
<ol start="3">
<li>确定单层递归的逻辑</li>
</ol>
<p>此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。</p>
<ul>
<li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li>
<li>比较内测是否对称，传入左节点的右孩子，右节点的左孩子。</li>
<li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> outside = <span class="built_in">compare</span>(left.left, right.right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line"><span class="type">bool</span> inside = <span class="built_in">compare</span>(left.right, right.left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line"><span class="type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中（逻辑处理）</span></span><br><span class="line"><span class="keyword">return</span> isSame;</span><br></pre></td></tr></table></figure>

<p>上代码中，我们可以看出使用的遍历方式，左子树左右中，右子树右左中，所以我把这个遍历顺序也称之为“后序遍历”（尽管不是严格的后序遍历）。</p>
<p><strong>递归：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> compare(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) || (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left.val != right.val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> compare(left.left , right.right) &amp;&amp; compare(left.right , right.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211201106248.gif" alt="101.对称二叉树"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//左右孩子入队</span></span><br><span class="line">        queue.offer(root.left);</span><br><span class="line">        queue.offer(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">//左右孩子为空</span></span><br><span class="line">            <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左右孩子一个不为空 或者都不为空 但值不一样</span></span><br><span class="line">            <span class="keyword">if</span> ((left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) || (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) || (left.val != right.val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//子节点比较</span></span><br><span class="line">            queue.offer(left.left);<span class="comment">//左左</span></span><br><span class="line">            queue.offer(right.right);<span class="comment">//右右</span></span><br><span class="line">            queue.offer(left.right);<span class="comment">//左右</span></span><br><span class="line">            queue.offer(right.left);<span class="comment">//右左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-6、剑指-Offer-32-I-从上到下打印二叉树"><a href="#8-6、剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="8.6、剑指 Offer 32 - I. 从上到下打印二叉树"></a>8.6、剑指 Offer 32 - I. 从上到下打印二叉树</h3><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3,9,20,15,7]</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ol>
<li><code>节点总数 &lt;= 1000</code></li>
</ol>
<p>Related Topics</p>
<p>树</p>
<p>广度优先搜索</p>
<p>二叉树</p>
<p>👍 236</p>
<p>👎 0</p>
<p><strong>解题思路：</strong></p>
<p>题目要求的二叉树的 从上至下 打印（即按层打印），又称为二叉树的 广度优先搜索（BFS）。<br>BFS 通常借助 队列 的先入先出特性来实现。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211201153247.png" alt="Picture1.png"></p>
<p>算法流程：</p>
<ol>
<li>特例处理： 当树的根节点为空，则直接返回空列表 [] ；</li>
<li>初始化： 打印结果列表 res &#x3D; [] ，包含根节点的队列 queue &#x3D; [root] ；</li>
<li>BFS 循环： 当队列 queue 为空时跳出；</li>
<li>出队： 队首元素出队，记为 node；</li>
<li>打印： 将 node.val 添加至列表 tmp 尾部；</li>
<li>添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；</li>
<li>返回值： 返回打印结果列表 res 即可。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span>  queue.poll();</span><br><span class="line">            res.add(tmp.val);</span><br><span class="line">            <span class="keyword">if</span> (tmp.left != <span class="literal">null</span>) queue.add(tmp.left);</span><br><span class="line">            <span class="keyword">if</span> (tmp.right != <span class="literal">null</span>) queue.add(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-7、剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#8-7、剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="8.7、剑指 Offer 32 - II. 从上到下打印二叉树 II"></a>8.7、剑指 Offer 32 - II. 从上到下打印二叉树 II</h3><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ol>
<li><code>节点总数 &lt;= 1000</code></li>
</ol>
<p>注意：本题与主站 102 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p>
<p>Related Topics</p>
<p>树</p>
<p>广度优先搜索</p>
<p>二叉树</p>
<p>👍 256</p>
<p>👎 0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();<span class="comment">//size :目的就是为了遍历每一层</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            list.add(tmp.val);</span><br><span class="line">            <span class="keyword">if</span> (tmp.left != <span class="literal">null</span>) queue.add(tmp.left);</span><br><span class="line">            <span class="keyword">if</span> (tmp.right != <span class="literal">null</span>) queue.add(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(list);<span class="comment">//加入该层遍历的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-8、剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#8-8、剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="8.8、剑指 Offer 32 - III. 从上到下打印二叉树 III"></a>8.8、剑指 Offer 32 - III. 从上到下打印二叉树 III</h3><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ol>
<li><code>节点总数 &lt;= 1000</code></li>
</ol>
<p>Related Topics</p>
<p>树</p>
<p>广度优先搜索</p>
<p>二叉树</p>
<p>👍 259</p>
<p>👎 0</p>
<p><strong>解题思路：</strong></p>
<p><strong>方法一：层序遍历 + 链表（双端队列）</strong></p>
<p>利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列） tmp ，并规定：</p>
<ul>
<li>奇数层 则添加至 tmp 尾部 ，</li>
<li>偶数层 则添加至 tmp 头部 。</li>
</ul>
<p><strong>算法流程</strong>：</p>
<ol>
<li>特例处理： 当树的根节点为空，则直接返回空列表 [] ；</li>
<li>初始化： 打印结果空列表 res ，包含根节点的双端队列 deque ；</li>
<li>BFS 循环： 当 deque 为空时跳出；<ol>
<li>新建列表 tmp ，用于临时存储当前层打印结果；</li>
<li>当前层打印循环： 循环次数为当前层节点数（即 deque 长度）；<ol>
<li>出队： 队首元素出队，记为 node；</li>
<li>打印： 若为奇数层，将 node.val 添加至 tmp 尾部；否则，添加至 tmp 头部；</li>
<li>添加子节点： 若 node 的左（右）子节点不为空，则加入 deque ；</li>
</ol>
</li>
<li>将当前层结果 tmp 转化为 list 并添加入 res ；</li>
</ol>
</li>
<li>返回值： 返回打印结果列表 res 即可；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//记录当前是否反转</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">0</span>) list.addLast(tmp.val);<span class="comment">//正序</span></span><br><span class="line">            <span class="keyword">else</span> list.addFirst(tmp.val);<span class="comment">//逆序</span></span><br><span class="line">            <span class="keyword">if</span> (tmp.left != <span class="literal">null</span>) queue.add(tmp.left);</span><br><span class="line">            <span class="keyword">if</span> (tmp.right != <span class="literal">null</span>) queue.add(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：<br>时间复杂度 O(N) ： NN 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) ；双端队列的队首和队尾的添加和删除操作的时间复杂度均为 O(1) 。<br>空间复杂度 O(N) ： 最差情况下，即当树为满二叉树时，最多有 N&#x2F;2 个树节点 同时 在 deque 中，使用 O(N) 大小的额外空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211201233874.png" alt="image-20221120123322773"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) deque.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 打印奇数层</span></span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> deque.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">// 从左向右打印</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.removeFirst();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="comment">// 先左后右加入下层节点</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) deque.addLast(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) deque.addLast(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">            <span class="keyword">if</span>(deque.isEmpty()) <span class="keyword">break</span>; <span class="comment">// 若为空则提前跳出</span></span><br><span class="line">            <span class="comment">// 打印偶数层</span></span><br><span class="line">            tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> deque.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">// 从右向左打印</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.removeLast();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="comment">// 先右后左加入下层节点</span></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) deque.addFirst(node.right);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) deque.addFirst(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211201235563.png" alt="image-20221120123516475"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res.size() % <span class="number">2</span> == <span class="number">1</span>) Collections.reverse(tmp);</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-9、剑指-Offer-34-二叉树中和为某一值的路径"><a href="#8-9、剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="8.9、剑指 Offer 34. 二叉树中和为某一值的路径"></a>8.9、剑指 Offer 34. 二叉树中和为某一值的路径</h3><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211211507250.jpeg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], targetSum = 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>树中节点总数在范围 <code>[0, 5000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<p>注意：本题与主站 113 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/">https://leetcode-cn.com/problems/path-sum-ii/</a></p>
<p>Related Topics</p>
<p>树</p>
<p>深度优先搜索</p>
<p>回溯</p>
<p>二叉树</p>
<p>👍 381</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<ol>
<li>确定递归函数的参数和返回类型</li>
</ol>
<p>参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。</p>
<p>再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：</p>
<ul>
<li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）</li>
<li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">236. 二叉树的最近公共祖先 (opens new window)</a>中介绍）</li>
<li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）</li>
</ul>
<p>而本题我们要找一条符合条件的路径，所以递归函数需要返回值，及时返回，那么返回类型是什么呢？</p>
<p>如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/messi-study-java/pic_go/raw/master/img/202211211524855.png" alt="113.路径总和ii"></p>
<p>图中可以看出，遍历的路线，并不要遍历整棵树，所以递归函数需要返回值，可以用bool类型表示。</p>
<p>所以代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode root, <span class="type">int</span> count)</span>   <span class="comment">// 注意函数的返回类型</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>确定终止条件</li>
</ol>
<p>首先计数器如何统计这一条路径的和呢？</p>
<p>不要去累加然后判断是否等于目标和，那么代码比较麻烦，可以用递减，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。</p>
<p>如果最后count &#x3D;&#x3D; 0，同时到了叶子节点的话，说明找到了目标和。</p>
<p>如果遍历到了叶子节点，count不为0，就是没找到。</p>
<p>递归终止条件代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left == null &amp;&amp; root.right == null &amp;&amp; count == <span class="number">0</span>) &#123; <span class="comment">//到叶子节点，并且找到了合适的路径</span></span><br><span class="line">    res.<span class="built_in">add</span>(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root.left == null &amp;&amp; root.right == null) &#123; <span class="comment">//到叶子节点，没有合适路径</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>确定单层递归的逻辑</li>
</ol>
<p>因为终止条件是判断叶子节点，所以递归的过程中就不要让空节点进入递归了。</p>
<p>递归函数是有返回值的，如果递归函数返回true，说明找到了合适的路径，应该立刻返回。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left != null) &#123; <span class="comment">//左孩子不为空 搜索左子树</span></span><br><span class="line">    path.<span class="built_in">add</span>(root.left.val);</span><br><span class="line">    <span class="built_in">traversal</span>(root.left, <span class="built_in">traversal</span>(root.right, count - root.right.val););</span><br><span class="line">    path.<span class="built_in">removeLast</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root.right != null) &#123; <span class="comment">//右孩子不为空 搜索右子树</span></span><br><span class="line">    path.<span class="built_in">add</span>(root.right.val);</span><br><span class="line">    <span class="built_in">traversal</span>(root.right, count - root.right.val);</span><br><span class="line">    path.<span class="built_in">removeLast</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码中是包含着回溯的，没有回溯，如何后撤重新找另一条路径呢。</p>
<p>回溯隐藏在<code>traversal(root.right, count - root.right.val);</code>这里， 因为把<code>root.right.val</code> 直接作为参数传进去，函数结束，count的数值没有改变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">LinkedList&lt;Integer&gt; path;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    path.add(root.val);</span><br><span class="line">    traversal(root, target - root.val);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode root, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; count == <span class="number">0</span>) &#123; <span class="comment">//到叶子节点，并且找到了合适的路径</span></span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123; <span class="comment">//到叶子节点，没有合适路径</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123; <span class="comment">//左孩子不为空 搜索左子树</span></span><br><span class="line">        path.add(root.left.val);</span><br><span class="line">        traversal(root.left, count - root.left.val);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123; <span class="comment">//右孩子不为空 搜索右子树</span></span><br><span class="line">        path.add(root.right.val);</span><br><span class="line">        traversal(root.right, count - root.right.val);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-10、剑指-Offer-36-二叉搜索树与双向链表"><a href="#8-10、剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="8.10、剑指 Offer 36. 二叉搜索树与双向链表"></a>8.10、剑指 Offer 36. 二叉搜索树与双向链表</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/bstdlloriginalbst.png" alt="img"></p>
<p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p>
<p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/bstdllreturndll.png" alt="img"></p>
<p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p>
<p><strong>注意：</strong>本题与主站 426 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/">https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/</a></p>
<p><strong>注意：</strong>此题对比原题有改动。</p>
<p>Related Topics</p>
<p>栈</p>
<p>树</p>
<p>深度优先搜索</p>
<p>二叉搜索树</p>
<p>链表</p>
<p>二叉树</p>
<p>双向链表</p>
<p>👍 604</p>
<p>👎 0</p>
<p><strong>解题思路：</strong></p>
<blockquote>
<p>二叉搜索树的中序遍历可以转化为递增序列。</p>
</blockquote>
<p>三个步骤：</p>
<ol>
<li>排序链表： 节点应从小到大排序，因此应使用 中序遍历 “从小到大”访问树的节点。</li>
<li>双向链表： 在构建相邻节点的引用关系时，设前驱节点 pre 和当前节点 cur ，不仅应构建 pre.right &#x3D; cur ，也应构建 cur.left &#x3D; pre 。</li>
<li>循环链表： 设链表头节点 head 和尾节点 tail ，则应构建 head.left &#x3D; tail 和 tail.right &#x3D; head</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599401091-PKIjds-Picture1.png" alt="Picture1.png"></p>
<p>java中序遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印中序遍历</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs(root.left); <span class="comment">// 左</span></span><br><span class="line">    System.out.println(root.val); <span class="comment">// 根</span></span><br><span class="line">    dfs(root.right); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再遍历到中间节点，加上处理节点间的指向关系，即构建当前节点cur和前驱节点pre的引用，在中序遍历完成时，构建头节点head和尾节点tail的关系。中序遍历完后,pre就是尾节点。</p>
<p><strong>算法流程：</strong><br><code>dfs(cur):</code> 递归法中序遍历；</p>
<ol>
<li>终止条件： 当节点 cur 为空，代表越过叶节点，直接返回；</li>
<li>递归左子树，即 dfs(cur.left) ；</li>
<li>构建链表：<ul>
<li>当 pre 为空时： 代表正在访问链表头节点，记为 head ；</li>
<li>当 pre 不为空时： 修改双向节点引用，即 pre.right &#x3D; cur ， cur.left &#x3D; pre ；</li>
<li>保存 cur ： 更新 pre &#x3D; cur ，即节点 cur 是后继节点的 pre ；</li>
</ul>
</li>
<li>递归右子树，即 dfs(cur.right) ；</li>
</ol>
<p><code>treeToDoublyList(root)</code>：</p>
<ol>
<li>特例处理： 若节点 root 为空，则直接返回；</li>
<li>初始化： 空节点 pre ；</li>
<li>转化为双向链表： 调用 dfs(root) ；</li>
<li>构建循环链表： 中序遍历完成后，head 指向头节点， pre 指向尾节点，因此修改 head 和 pre 的双向节点引用即可；</li>
<li>返回值： 返回链表的头节点 head 即可；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Node pre, head;</span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">treeToDoublyList</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//特殊 返回</span></span><br><span class="line">    dfs(root);<span class="comment">//中序遍历 构建链表</span></span><br><span class="line">    <span class="comment">// 中序遍历完后，处理头节点和尾节点</span></span><br><span class="line">    head.left = pre;</span><br><span class="line">    pre.right = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node cur)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123; <span class="comment">//空节点 不处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(cur.left); <span class="comment">//左子树</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//中间处理逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">null</span>) &#123; <span class="comment">//其他节点</span></span><br><span class="line">        pre.right = cur;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// pre == null 头节点</span></span><br><span class="line">        head = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.left = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line"></span><br><span class="line">    dfs(cur.right);<span class="comment">//右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N) ： N 为二叉树的节点数，中序遍历需要访问所有节点。</li>
<li>空间复杂度 O(N) ： 最差情况下，即树退化为链表时，递归深度达到 N，系统使用O(N) 栈空间。</li>
</ul>
<h3 id="8-11、剑指-Offer-37-序列化二叉树"><a href="#8-11、剑指-Offer-37-序列化二叉树" class="headerlink" title="8.11、剑指 Offer 37. 序列化二叉树"></a>8.11、剑指 Offer 37. 序列化二叉树</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p><strong>提示：</strong>输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a target="_blank" rel="noopener" href="https://support.leetcode-cn.com/hc/kb/article/1567641/">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p><strong>示例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/serdeser.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,null,null,4,5]</span><br><span class="line">输出：[1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure>



<p>注意：本题与主站 297 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/</a></p>
<p>Related Topics</p>
<p>树</p>
<p>深度优先搜索</p>
<p>广度优先搜索</p>
<p>设计</p>
<p>字符串</p>
<p>二叉树</p>
<p>👍 360</p>
<p>👎 0</p>
<p><strong>对序列化的理解</strong>：</p>
<p>通常使用的前序、中序、后序、层序遍历记录的二叉树的信息不完整，一种输出序列可能对应着多种二叉树可能性。题目要求的 序列化 和 反序列化 是 可逆操作 。因此，序列化的字符串应携带 完整的二叉树信息 。</p>
<p><strong>解题思路</strong>：</p>
<p>观察题目示例，序列化的字符串实际上是二叉树的 “层序遍历”（BFS）结果，只不过把null值也输出了。</p>
<p>为完整表示二叉树，考虑将叶节点下的 null 也记录。在此基础上，对于列表中任意某节点 node ，其左子节点 node.left 和右子节点 node.right 在序列中的位置都是 唯一确定 的。如下图所示：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1603117385-ehAGsP-Picture1.png" alt="Picture1.png"></p>
<p>规律如下表所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221122100451955-16690827032166.png" alt="image-20221122100451955"></p>
<p><strong>区别于完全二叉树的索引规则，null节点不在向下记录索引，所以索引的规律如下所示</strong>：</p>
<p>设 m为列表区间 [0, n]中的 <code>null</code> 节点个数，则可总结出根节点、左子节点、右子节点的列表索引的递推公式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221122100713320.png" alt="image-20221122100713320"></p>
<p>序列化 使用层序遍历实现。反序列化 通过以上递推公式反推各节点在序列中的索引，进而实现。</p>
<p><code>序列化 Serialize </code>：<br>借助队列，对二叉树做层序遍历，并将越过叶节点的 null 也打印出来。</p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>特例处理： 若 root 为空，则直接返回空列表 “[]” ；</li>
<li>初始化： 队列 queue （包含根节点 root ）；序列化列表 res ；</li>
<li>层序遍历： 当 queue 为空时跳出；<ol>
<li>节点出队，记为 node ；</li>
<li>若 node 不为空：① 打印字符串 node.val ，② 将左、右子节点加入 queue ；</li>
<li>否则（若 node 为空）：打印字符串 “null” ；</li>
</ol>
</li>
<li>返回值： 拼接列表，用 ‘,’ 隔开，首尾添加中括号；</li>
</ol>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N)： N 为二叉树的节点数，层序遍历需要访问所有节点，最差情况下需要访问 N + 1 个 null ，总体复杂度为 O(2N + 1) &#x3D; O(N)</li>
<li>空间复杂度 O(N)： 最差情况下，队列 queue 同时存储 N+1&#x2F;2个节点（或 N+1个 null ），使用 O(N)；列表 res 使用 O(N)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1603117385-ZrhoFK-Picture5.png" alt="img"></p>
<p><code>反序列化 Deserialize</code> ：<br>基于本文开始推出的 node , node.left , node.right 在序列化列表中的位置关系，可实现反序列化。</p>
<p>利用队列按层构建二叉树，借助一个指针 i 指向节点 node 的左、右子节点，每构建一个 node 的左、右子节点，指针 i 就向右移动 1 位。</p>
<p><strong>算法流程：</strong></p>
<ol>
<li>特例处理： 若 data 为空，直接返回 null ；</li>
<li>初始化： 序列化列表 vals （先去掉首尾中括号，再用逗号隔开），指针 i &#x3D; 1 ，根节点 root （值为 vals[0] ），队列 queue（包含 root ）；</li>
<li>按层构建： 当 queue 为空时跳出；<ol>
<li>节点出队，记为 node ；</li>
<li>构建 node 的左子节点：node.left 的值为 vals[i] ，并将 node.left 入队；</li>
<li>执行 i +&#x3D; 1 ；</li>
<li>构建 node 的右子节点：node.right 的值为 vals[i] ，并将 node.right 入队；</li>
<li>执行 i +&#x3D; 1 ；</li>
</ol>
</li>
<li>返回值： 返回根节点 root 即可；</li>
</ol>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N) ： N 为二叉树的节点数，按层构建二叉树需要遍历整个vals ，其长度最大为 2N+1 。</li>
<li>空间复杂度 O(N) ： 最差情况下，队列 queue 同时存储 n+1&#x2F;2个节点，因此使用 O(N) 额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line"><span class="comment">// 序列化二叉树</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);<span class="comment">// 加入头节点</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (tmp != <span class="literal">null</span>) &#123;</span><br><span class="line">                res.append(tmp.val).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="comment">// 之前BFS是跳过空节点的</span></span><br><span class="line">                queue.add(tmp.left);</span><br><span class="line">                queue.add(tmp.right);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.deleteCharAt(res.length() - <span class="number">1</span>);<span class="comment">// 删除最后一个&quot;,&quot;</span></span><br><span class="line">    res.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data.equals(<span class="string">&quot;[]&quot;</span>)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    String[] vals = data.substring(<span class="number">1</span>, data.length() - <span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>); <span class="comment">// 切掉[] 和,</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(vals[<span class="number">0</span>]));</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 不强调分层的话 可以不用size遍历</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (!vals[i].equals(<span class="string">&quot;null&quot;</span>)) &#123; <span class="comment">// 处理左节点</span></span><br><span class="line">            tmp.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(vals[i]));</span><br><span class="line">            queue.add(tmp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (!vals[i].equals(<span class="string">&quot;null&quot;</span>)) &#123; <span class="comment">// 处理右节点</span></span><br><span class="line">            tmp.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(vals[i]));</span><br><span class="line">            queue.add(tmp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-12、剑指-Offer-38-字符串的排列"><a href="#8-12、剑指-Offer-38-字符串的排列" class="headerlink" title="8.12、剑指 Offer 38. 字符串的排列"></a>8.12、剑指 Offer 38. 字符串的排列</h3><p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s 的长度 &lt;= 8</span><br></pre></td></tr></table></figure>

<p>Related Topics</p>
<p>字符串</p>
<p>回溯</p>
<p>👍 617</p>
<p>👎 0</p>
<p>解题思路：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221123155128395.png" alt="image-20221123155128395"></p>
<p>整体上是把它看成一个完全二叉树来规定该字符选还是不选。整体的结构是一个排列树（结果与顺序有关），所以遍历时要从头遍历，遍历过程中用used数组进行记录。因为有可能会有重复结果，这里用HashSet进行去重。</p>
<ol>
<li>当搜索到叶子节点就进行记录。找到了一个结果，加入到set中。</li>
<li>遍历时，通过used数组进行剪枝。</li>
</ol>
<p>code:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; res; <span class="comment">// 记录结果集 顺便用HashSet去重</span></span><br><span class="line">StringBuilder path; <span class="comment">// 路径 用StringBuilder</span></span><br><span class="line"><span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    res = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    path = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()];<span class="comment">// 记录有没有遍历过</span></span><br><span class="line">    backtracking(chars, used);</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">char</span>[] chars, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length() == chars.length) &#123; <span class="comment">// 已经搜索到根了，记录</span></span><br><span class="line">        res.add(path.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">            path.append(chars[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            backtracking(chars, used);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-13、剑指-Offer-54-二叉搜索树的第-k-大节点"><a href="#8-13、剑指-Offer-54-二叉搜索树的第-k-大节点" class="headerlink" title="8.13、剑指 Offer 54. 二叉搜索树的第 k 大节点"></a>8.13、剑指 Offer 54. 二叉搜索树的第 k 大节点</h3><p>给定一棵二叉搜索树，请找出其中第 <code>k</code> 大的节点的值。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<ul>
<li>1 ≤ k ≤ 二叉搜索树元素个数</li>
</ul>
<p>Related Topics</p>
<p>树</p>
<p>深度优先搜索</p>
<p>二叉搜索树</p>
<p>二叉树</p>
<p>👍 344</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>要知道二叉搜索树的性质，即中序遍历是一个有序的集合,顺序是升序的，降序的话就是逆向的中序遍历。</p>
<ol>
<li>遍历顺序：采用逆向中序遍历。在中间节点让记录当前的遍历次数count–</li>
<li>终止条件：count&#x3D;0，即找到了当前第k大的数，返回</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    count = k;</span><br><span class="line">    recur(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    recur(root.right); <span class="comment">// 右</span></span><br><span class="line">    <span class="keyword">if</span> (--count == <span class="number">0</span>) &#123;</span><br><span class="line">        res = root.val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="comment">// 中</span></span><br><span class="line">    recur(root.left); <span class="comment">// 左</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-14、剑指-Offer-55-I-二叉树的深度"><a href="#8-14、剑指-Offer-55-I-二叉树的深度" class="headerlink" title="8.14、剑指 Offer 55 - I. 二叉树的深度"></a>8.14、剑指 Offer 55 - I. 二叉树的深度</h3><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<p><strong>提示：</strong></p>
<ol>
<li><code>节点总数 &lt;= 10000</code></li>
</ol>
<p>注意：本题与主站 104 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p>
<p>Related Topics</p>
<p>树</p>
<p>深度优先搜索</p>
<p>广度优先搜索</p>
<p>二叉树</p>
<p>👍 218</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<ol>
<li><p>确定遍历顺序。</p>
<p>这道题使用DFS和BFS都是可以解决的。</p>
</li>
<li><p>DFS时，从下往上回溯，后序遍历。</p>
</li>
<li><p>BFS时，正好能通过size来记录每一排的个数。</p>
</li>
</ol>
<p>深度优先遍历（后序）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1603024336-lXVRDd-Picture1.png" alt="Picture1.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123; <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftH</span> <span class="operator">=</span> maxDepth(root.left);<span class="comment">// 左树高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rightH</span> <span class="operator">=</span> maxDepth(root.right);<span class="comment">// 右树高度</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(leftH, rightH) + <span class="number">1</span>;<span class="comment">//两棵树的最大高度 + 当前节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：	</p>
<p>时间复杂度 O(N) ： N 为树的节点数量，计算树的深度需要遍历所有节点。<br>空间复杂度 O(N) ： 最差情况下（当树退化为链表时），递归深度可达到 N 。</p>
<hr>
<p>层序遍历：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1603024336-EXcbJg-Picture15.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth2</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (tmp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(tmp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(tmp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：<br>时间复杂度 O(N) ： N 为树的节点数量，计算树的深度需要遍历所有节点。<br>空间复杂度 O(N) ： 最差情况下（当树平衡时），队列 queue 同时存储 N&#x2F;2 个节点。</p>
<h3 id="8-15、剑指-Offer-55-II-平衡二叉树"><a href="#8-15、剑指-Offer-55-II-平衡二叉树" class="headerlink" title="8.15、剑指 Offer 55 - II. 平衡二叉树"></a>8.15、剑指 Offer 55 - II. 平衡二叉树</h3><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<p><strong>示例 1:</strong></p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回 <code>true</code> 。</p>
<p><strong>示例 2:</strong></p>
<p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>

<p>返回 <code>false</code> 。</p>
<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= 树的结点个数 &lt;= 10000</code></li>
</ul>
<p>注意：本题与主站 110 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p>
<p>Related Topics</p>
<p>树</p>
<p>深度优先搜索</p>
<p>二叉树</p>
<p>👍 322</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>平衡二叉树的性质：如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<hr>
<p>先序遍历 + 判断深度 （从顶至底):</p>
<p>可以对每一个节点都用计算二叉树高度，如果左右子树深度差超过1，就返回false.</p>
<ol>
<li>确定遍历顺序：先序遍历</li>
<li>对中的节点的左右孩子求深度，判断深度差是否满足要求。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftH</span> <span class="operator">=</span> maxDepth(root.left);<span class="comment">// 左子树高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rightH</span> <span class="operator">=</span> maxDepth(root.right);<span class="comment">// 右子树高度</span></span><br><span class="line">    <span class="keyword">if</span> (Math.abs(leftH - rightH) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag1</span> <span class="operator">=</span> isBalanced(root.left);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag2</span> <span class="operator">=</span> isBalanced(root.right);</span><br><span class="line">        <span class="keyword">return</span> flag1 &amp;&amp; flag2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123; <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftH</span> <span class="operator">=</span> maxDepth(root.left);<span class="comment">// 左树高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rightH</span> <span class="operator">=</span> maxDepth(root.right);<span class="comment">// 右树高度</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(leftH, rightH) + <span class="number">1</span>;<span class="comment">//两棵树的最大高度 + 当前节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1603024695-uuegMD-Picture17.png" alt="img"></p>
<p>后序遍历 + 剪枝 （从底至顶）:</p>
<blockquote>
<p>此方法为本题的最优解法，但剪枝的方法不易第一时间想到。</p>
</blockquote>
<p>思路是对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。</p>
<p>recur(root) 函数：</p>
<ol>
<li>返回值：<ol>
<li>当节点root 左 &#x2F; 右子树的深度差≤1 ：则返回当前子树的深度，即节点 root 的左 &#x2F; 右子树的深度最大值 +1（ max(left, right) + 1 ）；</li>
<li>当节点root 左 &#x2F; 右子树的深度差 &gt;1 ：则返回 −1 ，代表 此子树不是平衡树 。</li>
</ol>
</li>
<li>终止条件：<ol>
<li>当 root 为空：说明越过叶节点，因此返回高度 0 ；</li>
<li>当左（右）子树深度为 −1 ：代表此树的 左（右）子树 不是平衡树，因此剪枝，直接返回 −1 ；</li>
</ol>
</li>
</ol>
<p>isBalanced(root) 函数：</p>
<ol>
<li>返回值： 若 recur(root) !&#x3D; -1 ，则说明此树平衡，返回 truetrue ； 否则返回 falsefalse 。</li>
</ol>
<p>复杂度分析：<br>时间复杂度 O(N)： N 为树的节点数；最差情况下，需要递归遍历树的所有节点。<br>空间复杂度 O(N)： 最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> recur(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">recur</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> recur(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> recur(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &lt; <span class="number">2</span> ? Math.max(left, right) + <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1603024695-Jqbiev-Picture12.png" alt="img"></p>
<h3 id="8-16、剑指-Offer-64-求-1-2-…-n"><a href="#8-16、剑指-Offer-64-求-1-2-…-n" class="headerlink" title="8.16、剑指 Offer 64. 求 1 + 2 + … + n"></a>8.16、剑指 Offer 64. 求 1 + 2 + … + n</h3><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 3</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 9</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10000</code></li>
</ul>
<p>Related Topics</p>
<p>位运算</p>
<p>递归</p>
<p>脑筋急转弯</p>
<p>👍 551</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>递归求解，需要用到if，如何消去if</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span>  n + sumNums(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1603023621-WFZwzS-Picture1.png" alt="Picture1.png"></p>
<p>逻辑运算符的短路效应：<br>常见的逻辑运算符有三种，即 “与 &amp;&amp;”，“或 || ”，“非 ! ” ；而其有重要的短路效应，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(A &amp;&amp; B)  // 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A &amp;&amp; B 为 false</span><br><span class="line">if(A || B) // 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true</span><br></pre></td></tr></table></figure>

<p>本题需要实现 “当 n &#x3D; 1 时终止递归” 的需求，可通过短路效应实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &gt; 1 &amp;&amp; sumNums(n - 1) // 当 n = 1 时 n &gt; 1 不成立 ，此时 “短路” ，终止后续递归</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(n) ： 计算 n + (n-1) + … + 2 + 1 需要开启 nn个递归函数。</li>
<li>空间复杂度 O(n) ： 递归深度达到 nn ，系统使用 O(n)大小的额外空间。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1603023621-nIAzSV-Picture10.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">//        if (n == 1) return 1;</span></span><br><span class="line">    <span class="comment">//        else return  n + sumNums(n - 1);</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> n &gt; <span class="number">1</span> &amp;&amp; sumNums(n - <span class="number">1</span>) &gt;<span class="number">0</span>;</span><br><span class="line">    res += n;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-17、剑指-Offer-68-II-二叉搜索树的最近公共祖先"><a href="#8-17、剑指-Offer-68-II-二叉搜索树的最近公共祖先" class="headerlink" title="8.17、剑指 Offer 68 - II. 二叉搜索树的最近公共祖先"></a>8.17、剑指 Offer 68 - II. 二叉搜索树的最近公共祖先</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉搜索树: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/binarysearchtree_improved.png" alt="img"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>



<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<p>注意：本题与主站 235 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p>
<p>Related Topics</p>
<p>树</p>
<p>深度优先搜索</p>
<p>二叉搜索树</p>
<p>二叉树</p>
<p>👍 272</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>本题求解的是二叉搜索树的最近公共祖先，二叉搜索树是有序的，从上往下进行搜索，如果节点在[p.val,q.val]中那么一定是p,q的公共祖先，而且是<strong>最小公共祖先</strong>。再往下搜索，不管往左、往右都会剪掉一个子树，这样就漏掉了一个节点。因此只要找到位于该区间的节点就行。遍历顺序无关。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/20220926164214.png" alt="235.二叉搜索树的最近公共祖先"></p>
<h4 id="递归法："><a href="#递归法：" class="headerlink" title="递归法："></a>递归法：</h4><ol>
<li><p>确定函数的返回值以及参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">traversal</span><span class="params">(TreeNode cur, TreeNode p, TreeNode q)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>确定终止条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> cur;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定单层递归的逻辑</p>
<ul>
<li>如果 cur.val 大于 p.val，同时 cur.val 大于q.val，那么就应该向左遍历（说明目标区间在左子树上）。</li>
<li>如果 cur.val 小于 p.val，同时 cur.val 小于q.val，那么就应该向右遍历（说明目标区间在右子树上）。</li>
<li>cur节点在区间（p.val &lt;&#x3D; cur.val &amp;&amp; cur.val &lt;&#x3D; q.val）或者 （q.val &lt;&#x3D; cur.val &amp;&amp; cur.val &lt;&#x3D; p.val）中，那么cur就是最近公共祖先了，直接返回cur。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> traversal(root, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">traversal</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123; <span class="comment">// 左</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> traversal(root.left, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123; <span class="comment">// 右</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> traversal(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123; <span class="comment">//左</span></span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123; <span class="comment">//右</span></span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-18、剑指-Offer-68-II-二叉树的最近公共祖"><a href="#8-18、剑指-Offer-68-II-二叉树的最近公共祖" class="headerlink" title="8.18、剑指 Offer 68 - II. 二叉树的最近公共祖"></a>8.18、剑指 Offer 68 - II. 二叉树的最近公共祖</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉树: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/binarytree.png" alt="img"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>



<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<p>注意：本题与主站 236 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
<p>Related Topics</p>
<p>树</p>
<p>深度优先搜索</p>
<p>二叉树</p>
<p>👍 495</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<ol>
<li><p>确定递归顺序，后序遍历，后序遍历的顺序为左右中，正好可以从下向上来回溯搜索。</p>
</li>
<li><p>确定递归函数返回值以及参数，我们需要返回找到的最近公共祖先，没找到返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>确定终止条件，如果我们找到了节点p或q就返回，直到根节点为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == q || root == p || root == NULL) <span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确定单层递归逻辑，本题应该是搜索整棵树，因为要对后序节点的left、right进行逻辑处理。</p>
</li>
<li><p>在向上返回的过程中，如果left、right都有返回值，则返回root，其中一个有值就返回这个值，两个都为null，返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4 5步代码</span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line"><span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">else</span>  &#123; <span class="comment">//  (left == null &amp;&amp; right == null)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体的流程图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/202102041512582.png" alt="236.二叉树的最近公共祖先2"></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q); <span class="comment">// 左</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q); <span class="comment">// 右</span></span><br><span class="line">    <span class="comment">// 中</span></span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九、分治算法"><a href="#九、分治算法" class="headerlink" title="九、分治算法"></a>九、分治算法</h2><h3 id="9-1、剑指-Offer-07-重建二叉树"><a href="#9-1、剑指-Offer-07-重建二叉树" class="headerlink" title="9.1、剑指 Offer 07. 重建二叉树"></a>9.1、剑指 Offer 07. 重建二叉树</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p>
<p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p><strong>示例 1:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/tree.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [-1], inorder = [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 节点个数 &lt;= 5000</span><br></pre></td></tr></table></figure>



<p><strong>注意</strong>：本题与主站 105 题重复：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
<p>Related Topics</p>
<p>树</p>
<p>数组</p>
<p>哈希表</p>
<p>分治</p>
<p>二叉树</p>
<p>👍 941</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<ul>
<li>第一步：如果数组大小为零的话，说明是空节点了。</li>
<li>第二步：如果不为空，那么取前序数组第一个元素作为节点元素。</li>
<li>第三步：找到前序数组第一个元素在中序数组的位置，作为切割点</li>
<li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</li>
<li>第五步：切割前序数组，切成前序左数组和前序右数组</li>
<li>第六步：递归处理左区间和右区间</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221126100453967.png" alt="image-20221126100453967"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map;<span class="comment">// 方便根据数值查找位置</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123; <span class="comment">// 用map保存中序序列的数值对应位置</span></span><br><span class="line">        map.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> findNode(preorder, <span class="number">0</span>, preorder.length, inorder, <span class="number">0</span>, inorder.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">findNode</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preBegin, <span class="type">int</span> preEnd, <span class="type">int</span>[] inorder, <span class="type">int</span> inBegin, <span class="type">int</span> inEnd)</span> &#123;</span><br><span class="line">    <span class="comment">// 保证区间是左闭右开的[)</span></span><br><span class="line">    <span class="keyword">if</span> (preBegin &gt;= preEnd || inBegin &gt;= inEnd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> map.get(preorder[preBegin]);<span class="comment">// 找到前序遍历的第一个元素在中序遍历中的位置</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preBegin]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">lenOfLeft</span> <span class="operator">=</span> rootIndex - inBegin; <span class="comment">// 保存中序左子树个数，用来确定前序数列的个数</span></span><br><span class="line">    root.left = findNode(preorder, preBegin + <span class="number">1</span>, preBegin + <span class="number">1</span> + lenOfLeft,</span><br><span class="line">                        inorder, inBegin, rootIndex);</span><br><span class="line">    root.right = findNode(preorder, preBegin + <span class="number">1</span> + lenOfLeft, preEnd,</span><br><span class="line">                        inorder, rootIndex + <span class="number">1</span>, inEnd);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-2、106-从中序与后序遍历序列构造二叉树"><a href="#9-2、106-从中序与后序遍历序列构造二叉树" class="headerlink" title="9.2、106.从中序与后序遍历序列构造二叉树"></a>9.2、106.从中序与后序遍历序列构造二叉树</h3><p>解题思路：</p>
<ul>
<li>第一步：如果数组大小为零的话，说明是空节点了。</li>
<li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li>
<li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</li>
<li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</li>
<li>第五步：切割后序数组，切成后序左数组和后序右数组</li>
<li>第六步：递归处理左区间和右区间</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221126100223163.png" alt="image-20221126100223163"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map;  <span class="comment">// 方便根据数值查找位置</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123; <span class="comment">// 用map保存中序序列的数值对应位置</span></span><br><span class="line">        map.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> findNode(inorder,  <span class="number">0</span>, inorder.length, postorder,<span class="number">0</span>, postorder.length);  <span class="comment">// 前闭后开</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">findNode</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inBegin, <span class="type">int</span> inEnd, <span class="type">int</span>[] postorder, <span class="type">int</span> postBegin, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数里的范围都是前闭后开</span></span><br><span class="line">    <span class="keyword">if</span> (inBegin &gt;= inEnd || postBegin &gt;= postEnd) &#123;  <span class="comment">// 不满足左闭右开，说明没有元素，返回空树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> map.get(postorder[postEnd - <span class="number">1</span>]);  <span class="comment">// 找到后序遍历的最后一个元素在中序遍历中的位置</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inorder[rootIndex]);  <span class="comment">// 构造结点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lenOfLeft</span> <span class="operator">=</span> rootIndex - inBegin;  <span class="comment">// 保存中序左子树个数，用来确定后序数列的个数</span></span><br><span class="line">    root.left = findNode(inorder, inBegin, rootIndex,</span><br><span class="line">                         postorder, postBegin, postBegin + lenOfLeft);</span><br><span class="line">    root.right = findNode(inorder, rootIndex + <span class="number">1</span>, inEnd,</span><br><span class="line">                          postorder, postBegin + lenOfLeft, postEnd - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3、剑指-Offer-16-数值的整数次方"><a href="#9-3、剑指-Offer-16-数值的整数次方" class="headerlink" title="9.3、剑指 Offer 16. 数值的整数次方"></a>9.3、剑指 Offer 16. 数值的整数次方</h3><p>实现 <a target="_blank" rel="noopener" href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数（即，x^n）。不得使用库函数，同时不需要考虑大数问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 2.00000, n = 10</span><br><span class="line">输出：1024.00000</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 2.10000, n = 3</span><br><span class="line">输出：9.26100</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 2.00000, n = -2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>-100.0 &lt; x &lt; 100.0</code></li>
<li><code>-231 &lt;= n &lt;= 231-1</code></li>
<li><code>-104 &lt;= xn &lt;= 104</code></li>
</ul>
<p>注意：本题与主站 50 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/powx-n/">https://leetcode-cn.com/problems/powx-n/</a></p>
<p>Related Topics</p>
<p>递归</p>
<p>数学</p>
<p>👍 365</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><p>求 x^n，最简单的方法是通过循环将 nn 个 xx 乘起来，依次求 x^1, x^2, …, x^{n-1}, x^n 时间复杂度为 O(n)。</p>
<h4 id="快速幂解析（分治法角度）"><a href="#快速幂解析（分治法角度）" class="headerlink" title="快速幂解析（分治法角度）"></a>快速幂解析（分治法角度）</h4><blockquote>
<p>快速幂实际上是分治思想的一种应用。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221126103110506.png" alt="image-20221126103110506"></p>
<blockquote>
<p>观察发现，当 n为奇数时，二分后会多出一项 x 。</p>
</blockquote>
<p>幂结果获取：</p>
<ul>
<li>根据推导，可通过循环 x &#x3D; x^2,每次把幂从 n 降至 n&#x2F;&#x2F;2，直至将幂降为0 ；</li>
<li>设 res&#x3D;1，则初始状态 x^n &#x3D; x^n ×res 。在循环二分时，每当 n 为奇数时，将多出的一项 x 乘入 res，则最终可化至 x^n &#x3D; x^0 ×res&#x3D;res ，返回 res 即可。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599885604-YzlkAN-Picture2.png" alt="Picture2.png"></li>
</ul>
<p>转化为位运算：</p>
<ul>
<li>向下整除 n&#x2F;&#x2F;2 等价于 右移一位 n&gt;&gt;1 ；</li>
<li>取余数 n%2 等价于 判断二进制最右位 n&amp;1 ；</li>
</ul>
<h4 id="快速幂解析（二进制角度）"><a href="#快速幂解析（二进制角度）" class="headerlink" title="快速幂解析（二进制角度）"></a>快速幂解析（二进制角度）</h4><blockquote>
<p>利用十进制数字 n的二进制表示，可对快速幂进行数学化解释。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221126104107284.png" alt="image-20221126104107284"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599885604-yDzVYK-Picture1.png" alt="Picture1.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221126104208372.png" alt="image-20221126104208372"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0.0f</span>) <span class="keyword">return</span> <span class="number">0.0d</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>) res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-4、剑指-Offer-17-打印从-1-到最大的-n-位数"><a href="#9-4、剑指-Offer-17-打印从-1-到最大的-n-位数" class="headerlink" title="9.4、剑指 Offer 17. 打印从 1 到最大的 n 位数"></a>9.4、剑指 Offer 17. 打印从 1 到最大的 n 位数</h3><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure>



<p>说明：</p>
<ul>
<li>用返回一个整数列表来代替打印</li>
<li>n 为正整数</li>
</ul>
<p>Related Topics</p>
<p>数组</p>
<p>数学</p>
<p>👍 265</p>
<p>👎 0</p>
<p>解题思路：<br>题目要求打印 “从 1 至最大的 n 位数的列表” ，因此需考虑以下两个问题：</p>
<ol>
<li>最大的 n 位数（记为 end ）和位数 n 的关系： 例如最大的 1 位数是 9 ，最大的 2 位数是 99 ，最大的 3 位数是 999。则可推出公式：end &#x3D; 10^n - 1</li>
<li>大数越界问题： 当 n 较大时，end 会超出 int32 整型的取值范围，超出取值范围的数字无法正常存储。但由于本题要求返回 int 类型数组，相当于默认所有数字都在 int32 整型取值范围内，因此不考虑大数越界问题。</li>
</ol>
<p>因此，只需定义区间 [1, 10^n - 1]和步长 1 ，通过 for 循环生成结果列表 res 并返回即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] printNumbers(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[(<span class="type">int</span>) Math.pow(<span class="number">10</span>, n) - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">        res[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<ul>
<li>时间复杂度 O(10^n)： 生成长度为 10^n的列表需使用 O(10^n)时间。</li>
<li>空间复杂度 O(1)： 建立列表需使用 O(1) 大小的额外空间（ 列表作为返回结果，不计入额外空间 ）。</li>
</ul>
<hr>
<h4 id="大数打印解法："><a href="#大数打印解法：" class="headerlink" title="大数打印解法："></a>大数打印解法：</h4><p>实际上，本题的主要考点是大数越界情况下的打印。需要解决以下三个问题：</p>
<ol>
<li>表示大数的变量类型：<br>无论是 short &#x2F; int &#x2F; long … 任意变量类型，数字的取值范围都是有限的。因此，大数的表示应用字符串 String 类型。</li>
<li>生成数字的字符串集：<br>使用 int 类型时，每轮可通过 +1+1 生成下个数字，而此方法无法应用至 String 类型。并且， String 类型的数字的进位操作效率较低，例如 “9999” 至 “10000” 需要从个位到千位循环判断，进位 4 次。</li>
</ol>
<p>观察可知，生成的列表实际上是 nn 位 00 - 99 的 全排列 ，因此可避开进位操作，通过递归生成数字的 String 列表。</p>
<ol start="3">
<li>递归生成全排列：<br>基于分治算法的思想，先固定高位，向低位递归，当个位已被固定时，添加数字的字符串。例如当 n &#x3D; 2n&#x3D;2 时（数字范围 1 - 991−99 ），固定十位为 00 - 99 ，按顺序依次开启递归，固定个位 00 - 99 ，终止递归并添加数字字符串。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/83f4b5930ddc1d42b05c724ea2950ee7f00427b11150c86b45bd88405f8c7c87-Picture1.png" alt="Picture1.png"></p>
<p>初步编写全排列代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    StringBuilder res;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, n;</span><br><span class="line">    <span class="type">char</span>[] num, loop = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">printNumbers</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// 数字字符串集</span></span><br><span class="line">        num = <span class="keyword">new</span> <span class="title class_">char</span>[n]; <span class="comment">// 定义长度为 n 的字符列表</span></span><br><span class="line">        dfs(<span class="number">0</span>); <span class="comment">// 开启全排列递归</span></span><br><span class="line">        res.deleteCharAt(res.length() - <span class="number">1</span>); <span class="comment">// 删除最后多余的逗号</span></span><br><span class="line">        <span class="keyword">return</span> res.toString(); <span class="comment">// 转化为字符串并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == n) &#123; <span class="comment">// 终止条件：已固定完所有位</span></span><br><span class="line">            res.append(String.valueOf(num) + <span class="string">&quot;,&quot;</span>); <span class="comment">// 拼接 num 并添加至 res 尾部，使用逗号隔开</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> i : loop) &#123; <span class="comment">// 遍历 ‘0‘ - ’9‘</span></span><br><span class="line">            num[x] = i; <span class="comment">// 固定第 x 位为 i</span></span><br><span class="line">            dfs(x + <span class="number">1</span>); <span class="comment">// 开启固定第 x + 1 位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此方法下，各数字字符串被逗号隔开，共同组成长字符串。返回的数字集字符串如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：&quot;0,1,2,3,4,5,6,7,8,9&quot;</span><br><span class="line"></span><br><span class="line">输入：n = 2</span><br><span class="line">输出：&quot;00,01,02,...,10,11,12,...,97,98,99&quot;</span><br><span class="line"></span><br><span class="line">输入：n = 3</span><br><span class="line">输出：&quot;000,001,002,...,100,101,102,...,997,998,999&quot;</span><br></pre></td></tr></table></figure>


<p>观察可知，当前的生成方法仍有以下问题：</p>
<ol>
<li>诸如 00, 01, 02,⋯ 应显示为 0, 1, 2, ⋯ ，即应 删除高位多余的 0 ;</li>
<li>此方法从 00 开始生成，而题目要求 列表从 11 开始 ；</li>
</ol>
<p>以上两个问题的解决方法如下：</p>
<ol>
<li>删除高位多余的 0 ：</li>
</ol>
<ul>
<li><p>字符串左边界定义： 声明变量 start 规定字符串的左边界，以保证添加的数字字符串 num[start:] 中无高位多余的 0 。例如当 n &#x3D; 2 时， 1 - 9 时 start &#x3D; 1 ， 10 - 99 时 start &#x3D; 0s 。</p>
</li>
<li><p>左边界 start 变化规律： 观察可知，当输出数字的所有位都是 9 时，则下个数字需要向更高位进 1 ，此时左边界 start 需要减 1 （即高位多余的 0 减少一个）。例如当 n &#x3D; 3 （数字范围 1 - 999 ）时，左边界 start 需要减 1 的情况有： “009” 进位至 “010” ， “099” 进位至 “100” 。设数字各位中 9 的数量为 nine，所有位都为 9 的判断条件可用以下公式表示：</p>
</li>
</ul>
<p>​																						n - start &#x3D; nine</p>
<p>​		- 统计 nine 的方法： 固定第 xx 位时，当 i&#x3D;9 则执行 nine &#x3D; nine + 1 ，并在回溯前恢复 nine &#x3D; nine - 1。</p>
<ol start="2">
<li>列表从 1 开始：</li>
</ol>
<ul>
<li>在以上方法的基础上，添加数字字符串前判断其是否为 “0” ，若为 “0” 则直接跳过。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/98054fcc5e43d84baba54224be52c5cd35b23fcc8dca3594e1068e6095f7b79a-Picture10.png" alt="img"></p>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度 O(10^n)： 递归的生成的排列的数量为 10^n - 1</li>
<li>空间复杂度 O(10^n)： 结果列表 resres 的长度为 10^n - 1 ，各数字字符串的长度为 1, 2, …, n，因此占用 O(10^n) 大小的额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    StringBuilder res;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nine</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>, start, n;</span><br><span class="line">    <span class="type">char</span>[] num, loop = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">printNumbers</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        num = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">        start = n - <span class="number">1</span>;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        res.deleteCharAt(res.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == n) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(num).substring(start);</span><br><span class="line">            <span class="keyword">if</span>(!s.equals(<span class="string">&quot;0&quot;</span>)) res.append(s + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(n - start == nine) start--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> i : loop) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="string">&#x27;9&#x27;</span>) nine++;</span><br><span class="line">            num[x] = i;</span><br><span class="line">            dfs(x + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        nine--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回数组格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] res;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nine</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">0</span>, start, n;</span><br><span class="line">    <span class="type">char</span>[] num, loop = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] printNumbers(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">int</span>[(<span class="type">int</span>)Math.pow(<span class="number">10</span>, n) - <span class="number">1</span>];</span><br><span class="line">        num = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">        start = n - <span class="number">1</span>;</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == n) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(num).substring(start);<span class="comment">//取掉前边多余的0</span></span><br><span class="line">            <span class="keyword">if</span>(!s.equals(<span class="string">&quot;0&quot;</span>)) res[count++] = Integer.parseInt(s);<span class="comment">//从1开始</span></span><br><span class="line">            <span class="keyword">if</span>(n - start == nine) start--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> i : loop) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="string">&#x27;9&#x27;</span>) nine++;</span><br><span class="line">            num[x] = i;</span><br><span class="line">            dfs(x + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        nine--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-5、剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#9-5、剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="9.5、剑指 Offer 33. 二叉搜索树的后序遍历序列"></a>9.5、剑指 Offer 33. 二叉搜索树的后序遍历序列</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
<p>参考以下这颗二叉搜索树：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>

<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ol>
<li><code>数组长度 &lt;= 1000</code></li>
</ol>
<p>Related Topics</p>
<p>栈</p>
<p>树</p>
<p>二叉搜索树</p>
<p>递归</p>
<p>二叉树</p>
<p>单调栈</p>
<p>👍 637</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p><strong>后序遍历定义</strong>： [ 左子树 | 右子树 | 根节点 ] ，即遍历顺序为 “左、右、根” 。</p>
<p><strong>二叉搜索树定义</strong>： 左子树中所有节点的值 &lt; 根节点的值；右子树中所有节点的值 &gt; 根节点的值；其左、右子树也分别为二叉搜索树。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599753507-JrFBjm-Picture1.png" alt="Picture1.png"></p>
<h4 id="方法一：递归分治"><a href="#方法一：递归分治" class="headerlink" title="方法一：递归分治"></a>方法一：递归分治</h4><p>根据二叉搜索树的定义，可以通过递归，判断所有子树的 <strong>正确性</strong> （即其后序遍历是否满足二叉搜索树的定义） ，若所有子树都正确，则此序列为二叉搜索树的后序遍历。</p>
<p><strong>递归解析</strong>：</p>
<ul>
<li>终止条件： 当 i≥j ，说明此子树节点数量 ≤1 ，无需判别正确性，因此直接返回 true ；</li>
<li>递推工作：<ol>
<li>划分左右子树： 遍历后序遍历的 [i, j] 区间元素，寻找 第一个大于根节点 的节点，索引记为 m 。此时，可划分出左子树区间 [i,m-1] 、右子树区间 [m, j - 1] 、根节点索引 j 。</li>
<li>判断是否为二叉搜索树：<ul>
<li>左子树区间 [i, m - 1] 内的所有节点都应 &lt;postorder[j] 。而第 <code>1.划分左右子树</code> 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。</li>
<li>右子树区间 [m, j-1] 内的所有节点都应 &gt; postorder[j] 。实现方式为遍历，当遇到 ≤postorder[j] 的节点则跳出；则可通过 p &#x3D; j 判断是否为二叉搜索树。</li>
<li>返回值： 所有子树都需正确才可判定正确，因此使用 与逻辑符 &amp;&amp; 连接。<br>p &#x3D; j ： 判断 此树 是否正确。<br>recur(i, m - 1) ： 判断 此树的左子树 是否正确。<br>recur(m, j - 1)： 判断 此树的右子树 是否正确。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599753507-TyHQkm-Picture9.png" alt="img"></p>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度 O(N^2)： 每次调用 recur(i,j) 减去一个根节点，因此递归占用O(N) ；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用 O(N) 。</li>
<li>空间复杂度 O(N) ： 最差情况下（即当树退化为链表），递归深度将达到 N 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verifyPostorder</span><span class="params">(<span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> recur(postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(<span class="type">int</span>[] postorder, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &lt; postorder[j]) p++; <span class="comment">// 找第一个&gt;根节点的节点 就是右子树的根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &gt; postorder[j]) p++;<span class="comment">// 验证右子树</span></span><br><span class="line">        <span class="keyword">return</span> p == j &amp;&amp; recur(postorder, i, m - <span class="number">1</span>) &amp;&amp; recur(postorder, m, j - <span class="number">1</span>);<span class="comment">// 分治</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：辅助单调栈"><a href="#方法二：辅助单调栈" class="headerlink" title="方法二：辅助单调栈"></a>方法二：辅助单调栈</h4><p><strong>后序遍历倒序</strong>： [ 根节点 | 右子树 | 左子树 ] 。类似 先序遍历的镜像 ，即先序遍历为 “根、左、右” 的顺序，而后序遍历的倒序为 “根、右、左” 顺序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599753507-KaeaWl-Picture10.png" alt="Picture10.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221127115157286.png" alt="image-20221127115157286"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221127115457068.png" alt="image-20221127115457068"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599753507-mgqkoF-Picture11.png" alt="Picture11.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221127115646432.png" alt="image-20221127115646432"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221127115822659.png" alt="image-20221127115822659"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599753507-LmdXnR-Picture17.png" alt="img"></p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N) ： 遍历postorder 所有节点，各节点均入栈 &#x2F; 出栈一次，使用 O(N) 时间。</li>
<li>空间复杂度 O(N) ： 最差情况下，单调栈 stackstack 存储所有节点，使用 O(N) 额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verifyPostorder</span><span class="params">(<span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> postorder.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(postorder[i] &gt; root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() &gt; postorder[i])</span><br><span class="line">                root = stack.pop();</span><br><span class="line">            stack.add(postorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-6、剑指-Offer-51-数组中的逆序对"><a href="#9-6、剑指-Offer-51-数组中的逆序对" class="headerlink" title="9.6、剑指 Offer 51. 数组中的逆序对"></a>9.6、剑指 Offer 51. 数组中的逆序对</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 数组长度 &lt;= 50000</span><br></pre></td></tr></table></figure>

<p>Related Topics</p>
<p>树状数组</p>
<p>线段树</p>
<p>数组</p>
<p>二分查找</p>
<p>分治</p>
<p>有序集合</p>
<p>归并排序</p>
<p>👍 900</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<blockquote>
<p>直观来看，使用暴力统计法即可，即遍历数组的所有数字对并统计逆序对数量。此方法时间复杂度为 O(N^2)，观察题目给定的数组长度范围 0 ≤ N ≤ 50000 ，可知此复杂度是不能接受的。</p>
</blockquote>
<p>「归并排序」与「逆序对」是息息相关的。归并排序体现了 “分而治之” 的算法思想，具体为：</p>
<ul>
<li>分： 不断将数组从中点位置划分开（即二分法），将整个数组的排序问题转化为子数组的排序问题；</li>
<li>治： 划分到子数组长度为 1 时，开始向上合并，不断将 <strong>较短排序数组</strong> 合并为 <strong>较长排序数组</strong>，直至合并至原数组时完成排序；</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1614274007-nBQbZZ-Picture1.png" alt="Picture1.png"></p>
<p><strong>合并阶段</strong> 本质上是 <strong>合并两个排序数组</strong> 的过程，而每当遇到 左子数组当前元素 &gt; 右子数组当前元素 时，意味着 「左子数组当前元素 至 末尾元素」 与 「右子数组当前元素」 构成了若干 「逆序对」 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1614274007-nIGXwT-Picture5.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1614274007-oEmevZ-Picture7.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1614274007-ounrkz-Picture13.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1614274007-YlPdBQ-Picture15.png" alt="img"></p>
<p>因此，考虑在归并排序的合并阶段统计「逆序对」数量，完成归并排序时，也随之完成所有逆序对的统计。</p>
<p>算法流程：</p>
<p><code>merge_sort()</code> 归并排序与逆序对统计：</p>
<ol>
<li>终止条件： 当 left≥right 时，代表子数组长度为 1 ，此时终止划分；(左闭右闭[])</li>
<li>递归划分： 计算数组中点 m ，递归划分左子数组 merge_sort(left, m) 和右子数组 merge_sort(m + 1, right) ；</li>
<li>合并与逆序对统计：<ol>
<li>暂存数组 nums 闭区间 [left, right] 内的元素至辅助数组 tmp ；</li>
<li>循环合并： 设置双指针 i , j 分别指向左 &#x2F; 右子数组的首元素；<ul>
<li>当 i &#x3D; m + 1 时： 代表左子数组已合并完，因此添加右子数组当前元素 tmp[j] ，并执行 j &#x3D; j + 1 ；</li>
<li>否则，当 j &#x3D; r + 1 时： 代表右子数组已合并完，因此添加左子数组当前元素 tmp[i] ，并执行 i &#x3D; i + 1 ；</li>
<li>否则，当 tmp[i]≤tmp[j] 时： 添加左子数组当前元素 tmp[i]，并执行 i &#x3D; i + 1；</li>
<li>否则（即 tmp[i] &gt; tmp[j]）时： 添加右子数组当前元素 tmp[j] ，并执行 j &#x3D; j + 1 ；此时构成 m - i + 1 个「逆序对」，统计添加至 res ；</li>
</ul>
</li>
</ol>
</li>
<li>返回值： 返回直至目前的逆序对总数 res ；</li>
</ol>
<p><code>reversePairs()</code> 主函数：</p>
<ol>
<li>初始化： 辅助数组 tmp ，用于合并阶段暂存元素；</li>
<li>返回值： 执行归并排序 merge_sort() ，并返回逆序对总数即可；</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1614274007-rtFHbG-Picture2.png" alt="Picture2.png"></p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(NlogN) ： 其中 N 为数组长度；归并排序使用 O(NlogN) 时间；</li>
<li>空间复杂度 O(N) ： 辅助数组 tmp 占用 O(N) 大小的额外空间；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums, tmp;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nums = nums;</span><br><span class="line">    tmp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">return</span> mergeSort(<span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123; <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归划分</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> mergeSort(left, mid) + mergeSort(mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">// 合并阶段</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left; k &lt;= right; k++) &#123;</span><br><span class="line">        tmp[k] = nums[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left; k &lt;= right; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == mid + <span class="number">1</span>)</span><br><span class="line">            nums[k] = tmp[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j == right + <span class="number">1</span> || tmp[i] &lt;= tmp[j])</span><br><span class="line">            nums[k] = tmp[i++];</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// tmp[i]&gt;tmp[j]</span></span><br><span class="line">            nums[k] = nums[j++];</span><br><span class="line">            res += mid - i + <span class="number">1</span>; <span class="comment">// 统计逆序数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十、排序算法"><a href="#十、排序算法" class="headerlink" title="十、排序算法"></a>十、排序算法</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>排序算法用作实现列表的排序，列表元素可以是整数，也可以是浮点数、字符串等其他数据类型。生活中有许多需要排序算法的场景，例如：</p>
<ul>
<li>整数排序： 对于一个整数数组，我们希望将所有数字从小到大排序；</li>
<li>字符串排序： 对于一个姓名列表，我们希望将所有单词按照字符先后排序；</li>
<li>自定义排序： 对于任意一个 已定义比较规则 的集合，我们希望将其按规则排序；</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1629483616-HHvvqY-Picture1.png" alt="Picture1.png"></p>
<p>同时，某些算法需要在排序算法的基础上使用（即在排序数组上运行），例如：</p>
<ul>
<li>二分查找： 根据数组已排序的特性，才能每轮确定排除两部分中的哪一部分；</li>
<li>双指针： 例如合并两个排序链表，根据已排序特性，才能通过双指针移动在线性时间内将其合并为一个排序链表。</li>
</ul>
<h4 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h4><p>常见排序算法包括「冒泡排序」、「插入排序」、「选择排序」、「快速排序」、「归并排序」、「堆排序」、「基数排序」、「桶排序」。如下图所示，为各排序算法的核心特性与时空复杂度总结。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1629483637-tmENTT-Picture2.png" alt="Picture2.png"></p>
<p>如下图所示，为在 「随机乱序」、「接近有序」、「完全倒序」、「少数独特」四类输入数据下，各常见排序算法的排序过程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1629482805-alxVCi-krahets-bubble-sort.gif" alt="krahets-bubble-sort.gif"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1629482805-MMIXPp-krahets-insertion-sort.gif" alt="krahets-insertion-sort.gif"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1629482805-vdWamx-krahets-selection-sort.gif" alt="krahets-selection-sort.gif"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1629482805-DYNZPE-krahets-quick-sort.gif" alt="krahets-quick-sort.gif"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1629482805-IjWwSz-krahets-merge-sort.gif" alt="krahets-merge-sort.gif"></p>
<h4 id="分类方法"><a href="#分类方法" class="headerlink" title="分类方法"></a>分类方法</h4><p>排序算法主要可根据 <code>稳定性</code> 、<code>就地性</code> 、<code>自适应性</code> 分类。理想的排序算法具有以下特性：</p>
<ul>
<li>具有稳定性，即相等元素的相对位置不变化；</li>
<li>具有就地性，即不使用额外的辅助空间；</li>
<li>具有自适应性，即时间复杂度受元素分布影响；</li>
</ul>
<p>特别地，任意排序算法都 <strong>不同时具有以上所有特性</strong> 。因此，排序算法的选型使用取决于具体的列表类型、元素数量、元素分布情况等应用场景特点。</p>
<p><strong>稳定性：</strong></p>
<p>根据 <code>相等元素</code> 在数组中的 <code>相对顺序</code> 是否被改变，排序算法可分为「稳定排序」和「非稳定排序」两类。</p>
<ul>
<li>「稳定排序」在完成排序后，不改变 相等元素在数组中的相对顺序。例如：冒泡排序、插入排序、归并排序、基数排序、桶排序。</li>
<li>「非稳定排序」在完成排序后，相等素在数组中的相对位置 可能被改变。例如：选择排序、快速排序、堆排序。</li>
</ul>
<blockquote>
<p><strong>何时需考虑排序算法的稳定性？</strong></p>
<p>数组排序中，由于元素皆为数字，因此稳定和非稳定排序皆可输出相同结果，此时无需考虑排序算法的稳定性。</p>
<p>非稳定排序会改变相等元素的相对次序，这在实际应用场景中可能是不能接受的。如以下代码所示，非稳定排序破坏了输入列表 people 按姓名排序的性质。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//人 = (姓名, 年龄) ，按姓名排序</span></span><br><span class="line"></span><br><span class="line">&gt;people = &#123;</span><br><span class="line">   (<span class="string">&#x27;A&#x27;</span>, <span class="number">19</span>),</span><br><span class="line">   (<span class="string">&#x27;B&#x27;</span>, <span class="number">18</span>),</span><br><span class="line">   (<span class="string">&#x27;C&#x27;</span>, <span class="number">21</span>),</span><br><span class="line">   (<span class="string">&#x27;D&#x27;</span>, <span class="number">19</span>),</span><br><span class="line">   (<span class="string">&#x27;E&#x27;</span>, <span class="number">23</span>)</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//非稳定排序（按年龄）</span></span><br><span class="line">&gt;sort_by_age(people)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//人 = (姓名, 年龄) ，按年龄排序</span></span><br><span class="line"></span><br><span class="line">&gt;people = &#123;</span><br><span class="line">   (<span class="string">&#x27;B&#x27;</span>, <span class="number">18</span>),</span><br><span class="line">   (<span class="string">&#x27;D&#x27;</span>, <span class="number">19</span>), # (<span class="string">&#x27;D&#x27;</span>, <span class="number">19</span>) 和 (<span class="string">&#x27;A&#x27;</span>, <span class="number">19</span>) 的相对位置改变，输入时按姓名排序的性质丢失</span><br><span class="line">   (<span class="string">&#x27;A&#x27;</span>, <span class="number">19</span>),</span><br><span class="line">   (<span class="string">&#x27;C&#x27;</span>, <span class="number">21</span>),</span><br><span class="line">   (<span class="string">&#x27;E&#x27;</span>, <span class="number">23</span>)</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>就地性</strong>：<br>根据排序过程中 <code>是否使用额外内存（辅助数组）</code>，排序算法可分为「原地排序」和「异地排序」两类。一般地，由于不使用外部内存，原地排序相比非原地排序的执行效率更高。</p>
<ul>
<li>「原地排序」不使用额外辅助数组，例如：冒泡排序、插入排序、选择排序、快速排序、堆排序。</li>
<li>「非原地排序」使用额外辅助数组，例如：归并排序、基数排序、桶排序。</li>
</ul>
<p><strong>自适应性</strong>：<br>根据算法 <code>时间复杂度</code> 是否 <code>受待排序数组的元素分布影响</code> ，排序算法可分为「自适应排序」和「非自适应排序」两类。</p>
<ul>
<li>「自适应排序」的时间复杂度受元素分布影响；例如：冒泡排序、插入排序、快速排序、桶排序。</li>
<li>「非自适应排序」的时间复杂度恒定；例如：选择排序、归并排序、堆排序、基数排序。</li>
</ul>
<p><strong>比较类</strong>：<br>比较类排序基于元素之间的 <code>比较算子</code>（小于、相等、大于）来决定元素的相对顺序；相对的，非比较排序则不基于比较算子实现。</p>
<ul>
<li>「比较类排序」基于元素之间的比较完成排序，例如：冒泡排序、插入排序、选择排序、快速排序、归并排序、堆排序。</li>
<li>「非比较类排序」不基于元素之间的比较完成排序，例如：基数排序、桶排序。</li>
</ul>
<blockquote>
<p>基于比较的排序算法的平均时间复杂度最优为 O(NlogN) ，而非比较排序算法可以达到线性级别的时间复杂度。</p>
</blockquote>
<h4 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h4><p>总体上看，排序算法追求时间与空间复杂度最低。而即使某些排序算法的时间复杂度相等，但实际性能还受 <strong>输入列表性质、元素数量、元素分布等</strong> 等因素影响。</p>
<blockquote>
<p>设输入列表元素数量为 N ，常见排序算法的「时间复杂度」和「空间复杂度」如下图所示。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221130102440078.png" alt="image-20221130102440078"></p>
<p>对于上表，需要特别注意：</p>
<ul>
<li>「基数排序」适用于正整数、字符串、特定格式的浮点数排序，k 为最大数字的位数；「桶排序」中 k 为桶的数量。</li>
<li>普通「冒泡排序」的最佳时间复杂度为 O(N^2)，通过增加标志位实现 提前返回 ，可以将最佳时间复杂度降低至 O(N) 。</li>
<li>在输入列表完全倒序下，普通「快速排序」的空间复杂度劣化至 O(N) ，通过代码优化 Tail Call Optimization 保持算法递归较短子数组，可以将最差递归深度降低至 logN 。</li>
<li>普通「快速排序」总以最左或最右元素为基准数，因此在输入列表有序或倒序下，时间复杂度劣化至 O(N^2)；通过 随机选择基准数 ，可极大减少此类最差情况发生，尽可能地保持 O(NlogN) 的时间复杂度。</li>
<li>若输入列表是数组，则归并排序的空间复杂度为 O(N) ；而若排序 链表 ，则「归并排序」不需要借助额外辅助空间，空间复杂度可以降低至 )O(1) 。</li>
</ul>
<h3 id="2、冒泡排序"><a href="#2、冒泡排序" class="headerlink" title="2、冒泡排序"></a>2、冒泡排序</h3><p><strong>算法解析</strong></p>
<p>冒泡排序是最基础的排序算法，由于其直观性，经常作为首个介绍的排序算法。其原理为：</p>
<ul>
<li>内循环： 使用相邻双指针 j , j + 1 从左至右遍历，依次比较相邻元素大小，若左元素大于右元素则将它们交换；遍历完成时，<code>最大元素会被交换至数组最右边</code> 。</li>
<li>外循环： 不断重复「内循环」，每轮将当前最大元素交换至 <code>剩余未排序数组最右边</code> ，直至所有元素都被交换至正确位置时结束。</li>
</ul>
<p>如下图所示，首轮「内循环」后，数组最大元素已被交换至数组最右边；接下来，只需要完成数组剩余 N - 1 个元素的排序即可（设数组元素数量为 N ）。同理，对剩余 N - 1 个元素执行「内循环」，可将第二大元素交换至剩余数组最右端，以此类推……</p>
<p>如下图所示，冒泡排序的「外循环」共 N−1 轮，每轮「内循环」都将当前最大元素交换至数组最右边，从而完成对整个数组的排序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1628616643-PvqWBM-Picture1.png" alt="Picture1.png"></p>
<p><strong>复杂度分析</strong>：<br>时间复杂度 O(N^2)： 其中 N 为输入数组的元素数量；「外循环」共 N - 1轮，使用 O(N) 时间；每轮「内循环」分别遍历 N - 1 , N - 2 ,⋯ , 2 , 1 次，平均 N&#x2F; 2 次，使用 O(N &#x2F; 2) &#x3D;O(N) 时间；因此，总体时间复杂度为 O(N^2) 。<br>空间复杂度 O(1) ： 只需原地交换元素，使用常数大小的额外空间。</p>
<p><strong>算法特性</strong>：</p>
<ul>
<li>时间复杂度为 O(N^2)，因为其是通过不断 <code>交换元素</code> 实现排序（交换 2 个元素需要 3 次赋值操作），因此速度较慢；</li>
<li>原地： 指针变量仅使用常数大小额外空间，空间复杂度为 O(1)；</li>
<li>稳定： 元素值相同时不交换，因此不会改变相同元素的相对位置；</li>
<li>自适应： 通过增加一个标志位 flag ，若某轮内循环未执行任何交换操作时，说明已经完成排序，因此直接返回。此优化使冒泡排序的最优时间复杂度达到 O(N）（当输入数组已排序时）；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;          <span class="comment">// 外循环</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; N - i - <span class="number">1</span>; j++) &#123;  <span class="comment">// 内循环</span></span><br><span class="line">			<span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j], nums[j + 1]</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">				nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">				nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效率优化</strong></p>
<blockquote>
<p>以上普通冒泡排序的时间复杂度恒为 O(N^2)<em>O</em>(<em>N</em>2) ，与输入数组的元素分布无关</p>
</blockquote>
<p>通过增加一个标志位 flag ，若在某轮「内循环」中未执行任何交换操作，则说明数组已经完成排序，直接返回结果即可。</p>
<p>优化后的冒泡排序的最差和平均时间复杂度仍为 O(N^2)；在输入数组 <code>已排序 </code>时，达到 <code>最佳时间复杂度</code>O(N) 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 初始化标志位</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; N - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">				nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">				nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">				flag = <span class="literal">true</span>;  <span class="comment">// 记录交换元素</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) <span class="keyword">break</span>;     <span class="comment">// 内循环未交换任何元素，则跳出</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、快速排序"><a href="#3、快速排序" class="headerlink" title="3、快速排序"></a>3、快速排序</h3><p><strong>算法解析</strong><br>快速排序算法有两个核心点，分别为 <code>哨兵划分</code> 和 <code>递归</code> 。</p>
<p><strong>哨兵划分</strong>：<br>以数组某个元素（一般选取首元素）为 <code>基准数</code> ，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边。</p>
<blockquote>
<p>如下图所示，为哨兵划分操作流程。通过一轮 <strong>哨兵划分</strong> ，可将数组排序问题拆分为 <strong>两个较短数组的排序问题</strong> （本文称之为左（右）子数组）。</p>
</blockquote>
<p><strong>递归</strong>：</p>
<p>对 <strong>左子数组</strong> 和 <strong>右子数组</strong> 分别递归执行 <strong>哨兵划分</strong>，直至子数组长度为 1 时终止递归，即可完成对整个数组的排序。</p>
<blockquote>
<p>如下图所示，为示例数组 [2,4,1,0,3,5] 的快速排序流程。观察发现，快速排序和 二分法 的原理类似，都是以 log 时间复杂度实现搜索区间缩小。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1612615552-rifQwI-Picture1.png" alt="Picture1.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="comment">// 左闭右闭</span></span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 哨兵划分操作</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> partition(nums, l, r);</span><br><span class="line">    <span class="comment">// 递归左（右）子数组执行哨兵划分</span></span><br><span class="line">    quickSort(nums, l, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, i + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="comment">// 以 nums[l] 作为基准数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[l]) j--;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[l]) i++;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i, l);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="comment">// 交换 nums[i] 和 nums[j]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="type">int</span>[] nums = &#123; <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line">quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>算法特性</strong></p>
<ul>
<li><p><strong>时间复杂度：</strong></p>
<ul>
<li>最佳 Ω(NlogN) ： 最佳情况下， 每轮哨兵划分操作将数组划分为等长度的两个子数组；哨兵划分操作为线性时间复杂度 O(N) ；递归轮数共 O(logN) 。</li>
<li>平均 Θ(NlogN) ： 对于随机输入数组，哨兵划分操作的递归轮数也为 O(logN) 。</li>
<li>最差 O(N^2)： 对于某些特殊输入数组，每轮哨兵划分操作都将长度为 N 的数组划分为长度为 1 和 N - 1 的两个子数组，此时递归轮数达到 N 。</li>
</ul>
<blockquote>
<p>通过 「随机选择基准数」优化，可尽可能避免出现最差情况，详情请见下文。</p>
</blockquote>
</li>
<li><p><strong>空间复杂度 O(N) ：</strong> 快速排序的递归深度最好与平均皆为 log<em>N</em> ；输入数组完全倒序下，达到最差递归深度 N 。</p>
<blockquote>
<p>通过「Tail Call」优化，可将最差空间复杂度降低至 O(\log N)<em>O</em>(log<em>N</em>) ，详情请见下文。</p>
</blockquote>
</li>
<li><p>虽然平均时间复杂度与「归并排序」和「堆排序」一致，但在实际使用中快速排序 <strong>效率更高</strong> ，这是因为：</p>
<ul>
<li>最差情况稀疏性： 虽然快速排序的最差时间复杂度为 O(N^2)，差于归并排序和堆排序，但统计意义上看，这种情况出现的机率很低。大部分情况下，快速排序以 O(NlogN) 复杂度运行。</li>
<li>缓存使用效率高： 哨兵划分操作时，将整个子数组加载入缓存中，访问元素效率很高；堆排序需要跳跃式访问元素，因此不具有此特性。</li>
<li>常数系数低： 在提及的三种算法中，快速排序的 比较、赋值、交换 三种操作的综合耗时最低（类似于插入排序快于冒泡排序的原理）。</li>
</ul>
</li>
<li><p>原地： 不用借助辅助数组的额外空间，递归仅使用 O(logN) 大小的栈帧空间。</p>
</li>
<li><p>非稳定： 哨兵划分操作可能改变相等元素的相对顺序。</p>
</li>
<li><p>自适应： 对于极少输入数据，每轮哨兵划分操作都将长度为 N 的数组划分为长度 1 和 N - 1 两个子数组，此时时间复杂度劣化至 O(N^2)。</p>
</li>
</ul>
<p><strong>算法优化</strong></p>
<p>快速排序的常见优化手段有「Tail Call」和「随机基准数」两种。</p>
<p><strong>Tail Call ：</strong></p>
<p>由于普通快速排序每轮选取「子数组最左元素」作为「基准数」，因此在输入数组 <code>完全倒序</code> 时， partition() 的递归深度会达到 N ，即 <code>最差空间复杂度</code> 为 O(N) 。</p>
<p>每轮递归时，仅对 <code>较短的子数组</code> 执行哨兵划分 partition() ，就可将最差的递归深度控制在 O(logN) （每轮递归的子数组长度都 ≤ 当前数组长度 &#x2F; 2 ），即实现最差空间复杂度 O(logN) 。</p>
<blockquote>
<p>代码仅需修改 <code>quick_sort()</code> 方法，其余方法不变，在此省略。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">// 哨兵划分操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> partition(nums, l, r);</span><br><span class="line">        <span class="comment">// 仅递归至较短子数组，控制递归深度</span></span><br><span class="line">        <span class="keyword">if</span> (i - l &lt; r - i) &#123;</span><br><span class="line">            quickSort(nums, l, i - <span class="number">1</span>);</span><br><span class="line">            l = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            quickSort(nums, i + <span class="number">1</span>, r);</span><br><span class="line">            r = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>随机基准数</strong>：<br>同样地，由于快速排序每轮选取「子数组最左元素」作为「基准数」，因此在输入数组 <code>完全有序</code> 或 <code>完全倒序</code> 时， partition() 每轮只划分一个元素，达到最差时间复杂度 O(N^2)。</p>
<p>因此，可使用 <code>随机函数</code> ，每轮在子数组中随机选择一个元素作为基准数，这样就可以极大概率避免以上劣化情况。</p>
<p>值得注意的是，由于仍然可能出现最差情况，因此快速排序的最差时间复杂度仍为 O(N^2)。</p>
<blockquote>
<p>代码仅需修改 <code>partition()</code> 方法，其余方法不变，在此省略。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="comment">// 在闭区间 [l, r] 随机选取任意索引，并与 nums[l] 交换</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ra</span> <span class="operator">=</span> (<span class="type">int</span>)(l + Math.random() * (r - l + <span class="number">1</span>));</span><br><span class="line">    swap(nums, l, ra);</span><br><span class="line">    <span class="comment">// 以 nums[l] 作为基准数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[l]) j--;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[l]) i++;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i, l);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、归并排序"><a href="#4、归并排序" class="headerlink" title="4、归并排序"></a>4、归并排序</h3><p><strong>算法解析</strong></p>
<p>归并排序体现了 “分而治之” 的算法思想，具体为：</p>
<ul>
<li>「分」： 不断将数组从 中点位置 划分开，将原数组的排序问题转化为子数组的排序问题；</li>
<li>「治」： 划分到子数组长度为 1 时，开始向上合并，不断将 左右两个较短排序数组 合并为 一个较长排序数组，直至合并至原数组时完成排序；</li>
</ul>
<blockquote>
<p>如下图所示，为数组 <code>[7,3,2,6,0,1,5,4]</code> 的归并排序过程。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1632675739-CNHaOu-Picture1.png" alt="Picture1.png"></p>
<p><strong>算法流程</strong>：</p>
<ol>
<li><p><code>递归划分</code>：</p>
<ol>
<li>计算数组中点 m ，递归划分左子数组 merge_sort(l, m) 和右子数组 merge_sort(m + 1, r) ；</li>
<li>当 l ≥ r 时，代表子数组长度为 1 或 0 ，此时 <strong>终止划分</strong> ，开始合并；</li>
</ol>
</li>
<li><p><code>合并子数组</code>：</p>
<ol>
<li>暂存数组 nums 闭区间 [l,r] 内的元素至辅助数组 tmp ；</li>
<li><code>循环合并</code>： 设置双指针 ii , jj 分别指向 tmptmp 的左 &#x2F; 右子数组的首元素；</li>
</ol>
<blockquote>
<p>注意： nums 子数组的左边界、中点、右边界分别为 l , m , r ，而辅助数组 tmp 中的对应索引为 0 , m - l, r - l；</p>
</blockquote>
<ul>
<li>当 i &#x3D;&#x3D; m - l + 1 时： 代表左子数组已合并完，因此添加右子数组元素 tmp[j] ，并执行 j &#x3D; j + 1 ；</li>
</ul>
</li>
</ol>
<ul>
<li>否则,当 j &#x3D;&#x3D; r - l + 1 时;代表右子数组已合并完，因此添加左子数组元素 tmp[i]，并执行 i &#x3D; i + 1；</li>
<li>否则，当 tmp[i]≤tmp[j] 时： 添加左子数组元素 tmp[i] ，并执行 i &#x3D; i + 1 ；</li>
<li>否则（即当 tmp[i] &gt; tmp[j] 时）： 添加右子数组元素 tmp[j] ，并执行 j &#x3D; j + 1 ；</li>
</ul>
<p>​	</p>
<blockquote>
<p>如下动图所示，为数组 <code>[7,3,2,6]</code> 的归并排序过程。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1632675727-VVDNmq-Picture11.png" alt="img"></p>
<p>为简化代码，「当 j &#x3D; r + 1时」 与 「当 tmp*[<em>i</em>]≤*tmp[j] 时」 两判断项可合并。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 递归划分</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(nums, l, m);</span><br><span class="line">    mergeSort(nums, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 合并子数组</span></span><br><span class="line">    <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[r - l + <span class="number">1</span>]; <span class="comment">// 暂存需合并区间元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= r; k++)</span><br><span class="line">        tmp[k - l] = nums[k];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = m - l + <span class="number">1</span>;       <span class="comment">// 两指针分别指向左/右子数组的首个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= r; k++) &#123;  <span class="comment">// 遍历合并左/右子数组</span></span><br><span class="line">        <span class="keyword">if</span> (i == m - l + <span class="number">1</span>)</span><br><span class="line">            nums[k] = tmp[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j == r - l + <span class="number">1</span> || tmp[i] &lt;= tmp[j])</span><br><span class="line">            nums[k] = tmp[i++];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[k] = tmp[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="type">int</span>[] nums = &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</span><br><span class="line">mergeSort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><strong>算法特性</strong></p>
<ul>
<li>时间复杂度： 最佳 Ω(NlogN) ，平均 Θ(NlogN) ，最差 O(NlogN) 。</li>
<li>空间复杂度 O(N) ： 合并过程中需要借助辅助数组 tmp ，使用 O(N) 大小的额外空间；划分的递归深度为 logN ，使用 O(logN) 大小的栈帧空间。</li>
<li>若输入数据是 <code>链表</code> ，则归并排序的空间复杂度可被优化至 O(1) ，这是因为：<ul>
<li>通过应用「双指针法」，可在 O(1) 空间下完成两个排序链表的合并，省去辅助数组 tmp 使用的额外空间；</li>
<li>通过使用「迭代」代替「递归划分」，可省去递归使用的栈帧空间；</li>
</ul>
</li>
<li>非原地： 辅助数组 tmp 需要使用额外空间。</li>
<li>稳定： 归并排序不改变相等元素的相对顺序。</li>
<li>非自适应： 对于任意输入数据，归并排序的时间复杂度皆相同。</li>
</ul>
<h3 id="5、剑指-Offer-40-最小的-k-个数"><a href="#5、剑指-Offer-40-最小的-k-个数" class="headerlink" title="5、剑指 Offer 40. 最小的 k 个数"></a>5、剑指 Offer 40. 最小的 k 个数</h3><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></li>
<li><code>0 &lt;= arr[i] &lt;= 10000</code></li>
</ul>
<p>Related Topics</p>
<p>数组</p>
<p>分治</p>
<p>快速选择</p>
<p>排序</p>
<p>堆（优先队列）</p>
<p>👍 500</p>
<p>👎 0</p>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>对数组 <code>arr</code> 执行排序，再返回前 <em>k</em> 个元素即可。使用任意排序算法皆可，本文采用并介绍 <strong>快速排序</strong> ，为下文 <strong>方法二</strong> 做铺垫。</p>
<p><strong>快速排序原理</strong>：<br>快速排序算法有两个核心点，分别为 “哨兵划分” 和 “递归” 。</p>
<p><strong>哨兵划分操作</strong>： 以数组某个元素（一般选取首元素）为 <code>基准数</code> ，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边。</p>
<blockquote>
<p>通过一轮 <strong>哨兵划分</strong> ，可将数组排序问题拆分为 <strong>两个较短数组的排序问题</strong> （本文称之为左（右）子数组）。</p>
</blockquote>
<p><strong>递归：</strong> 对 <strong>左子数组</strong> 和 <strong>右子数组</strong> 递归执行 <strong>哨兵划分</strong>，直至子数组长度为 1 时终止递归，即可完成对整个数组的排序。</p>
<blockquote>
<p>如下图所示，为示例数组 [2,4,1,0,3,5] 的快速排序流程。观察发现，快速排序和 <code>二分法</code> 的原理类似，都是以 log 时间复杂度实现搜索区间缩小。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1612615552-rifQwI-Picture1-16698640161711.png" alt="Picture1.png"></p>
<p><strong>复杂度分析</strong>：<br>时间复杂度 O(NlogN) ： 库函数、快排等排序算法的平均时间复杂度为 O(NlogN) 。<br>空间复杂度 O(N) ： 快速排序的递归深度最好（平均）为 O(logN) ，最差情况（即输入数组完全倒序）为 O(N)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(arr, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 哨兵划分操作（以 arr[l] 作为基准数）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= arr[l]) j--;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= arr[l]) i++;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, l);</span><br><span class="line">        <span class="comment">// 递归左（右）子数组执行哨兵划分</span></span><br><span class="line">        quickSort(arr, l, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基于快速排序的数组划分"><a href="#基于快速排序的数组划分" class="headerlink" title="基于快速排序的数组划分"></a>基于快速排序的数组划分</h4><p>题目只要求返回最小的 k 个数，对这 k 个数的顺序并没有要求。因此，只需要将数组划分为 <code>最小的 k 个数</code> 和 <code>其他数字</code> 两部分即可，而快速排序的哨兵划分可完成此目标。</p>
<p>根据快速排序原理，如果某次哨兵划分后 <code>基准数正好是第 k+1 小的数字</code> ，那么此时基准数左边的所有数字便是题目所求的 <code>最小的 k 个数</code> 。</p>
<p>根据此思路，考虑在每次哨兵划分后，判断基准数在数组中的索引是否等于 k ，若 true 则直接返回此时数组的前 k 个数字即可。</p>
<p><strong>算法流程</strong>：<br>getLeastNumbers() 函数：</p>
<ol>
<li>若 k 大于数组长度，则直接返回整个数组；</li>
<li>执行并返回 quick_sort() 即可；</li>
</ol>
<p>quick_sort() 函数：</p>
<blockquote>
<p>注意，此时 quick_sort() 的功能不是排序整个数组，而是搜索并返回最小的 k 个数。</p>
</blockquote>
<ol>
<li><strong>哨兵划分</strong>：<ul>
<li>划分完毕后，基准数为 arr[i] ，左 &#x2F; 右子数组区间分别为 [l, i - 1] , [i + 1, r] ；</li>
</ul>
</li>
<li>递归或返回：<ul>
<li>若 k &lt; i ，代表第 k + 1 小的数字在 <code>左子数组</code> 中，则递归左子数组；</li>
<li>若 k &gt; i ，代表第 k + 1 小的数字在 <code>右子数组</code> 中，则递归右子数组；</li>
<li>若 k &#x3D; i ，代表此时 arr[k] 即为第 k + 1 小的数字，则直接返回数组前 k 个数字即可；</li>
</ul>
</li>
</ol>
<h5 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h5><blockquote>
<p>本方法优化时间复杂度的本质是通过判断舍去了不必要的递归（哨兵划分）。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221201111603883.png" alt="image-20221201111603883"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(arr, k, <span class="number">0</span>, arr.length - <span class="number">1</span>); <span class="comment">// 左闭右闭[,]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] quickSort(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> left, <span class="type">int</span> right) &#123;</span><br><span class="line">    <span class="comment">// 哨兵划分</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= arr[left])</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= arr[left])</span><br><span class="line">            i++;</span><br><span class="line">        swap(arr, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, i, left);<span class="comment">//划分值 和 最后一个&lt;他的元素交换</span></span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; k) quickSort(arr, k, left, i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; k) quickSort(arr, k, i + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(arr, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、剑指-Offer-41-数据流中的中位数"><a href="#6、剑指-Offer-41-数据流中的中位数" class="headerlink" title="6、剑指 Offer 41. 数据流中的中位数"></a>6、剑指 Offer 41. 数据流中的中位数</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li>
<li>double findMedian() - 返回目前所有元素的中位数。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<ul>
<li>最多会对 <code>addNum、findMedian</code> 进行 <code>50000</code> 次调用。</li>
</ul>
<p>注意：本题与主站 295 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-median-from-data-stream/">https://leetcode-cn.com/problems/find-median-from-data-stream/</a></p>
<p>Related Topics</p>
<p>设计</p>
<p>双指针</p>
<p>数据流</p>
<p>排序</p>
<p>堆（优先队列）</p>
<p>👍 379</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<blockquote>
<p>给定一长度为 N 的无序数组，其中位数的计算方法：首先对数组执行排序（使用 O(NlogN) 时间），然后返回中间元素即可（使用 O(1) 时间）。</p>
</blockquote>
<p>针对本题，根据以上思路，可以将数据流保存在一个列表中，并在添加元素时 保持数组有序 。此方法的时间复杂度为 O(N) ，其中包括： 查找元素插入位置 O(logN) （二分查找）、向数组某位置插入元素 O(N) （插入位置之后的元素都需要向后移动一位）。</p>
<blockquote>
<p>借助 <strong>堆</strong> 可进一步优化时间复杂度。</p>
</blockquote>
<p>建立一个 <code>小顶堆</code> A 和 <code>大顶堆</code> B ，各保存列表的一半元素，且规定：</p>
<ul>
<li>A 保存 较大 的一半，长度为 N &#x2F; 2（ N 为偶数）或 (N + 1) &#x2F; 2（ N 为奇数）；</li>
<li>b 保存 较小 的一半，长度为 N &#x2F; 2（ N 为偶数）或 (N - 1) &#x2F; 2（ N 为奇数）；</li>
</ul>
<p>随后，中位数可仅根据 A, B 的堆顶元素计算得到。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/bcfaca2b1920d2dd6bbb01aeff990698eb36d53830c38ed499ea3239a15296b3-Picture1.png" alt="Picture1.png"></p>
<p>算法流程</p>
<blockquote>
<p>设元素总数为 N &#x3D; m + n ，其中 m 和 n分别为 A 和 B 中的元素个数。</p>
</blockquote>
<p>addNum(num) 函数：</p>
<ol>
<li>当 m &#x3D; n（即 N 为 偶数）：需向 A 添加一个元素。实现方法：将新元素 num 插入至 B ，再将 B 堆顶元素插入至 A ；</li>
<li>当 m !&#x3D; n（即 N 为 奇数）：需向 B 添加一个元素。实现方法：将新元素 num 插入至 A ，再将 A 堆顶元素插入至 B ；</li>
</ol>
<blockquote>
<p>假设插入数字 num 遇到情况 </p>
<ol>
<li>由于 num 可能属于 “较小的一半” （即属于 B ），因此不能将 nums 直接插入至 A 。而应先将 num 插入至 B ，再将 B 堆顶元素插入至 A 。这样就可以始终保持 A 保存较大一半、 B 保存较小一半。</li>
</ol>
</blockquote>
<p>findMedian() 函数：</p>
<ol>
<li>当 m &#x3D; n（ N 为 偶数）：则中位数为 ( A 的堆顶元素 + B 的堆顶元素 )&#x2F;2。</li>
<li>当 m !&#x3D;n（ N 为 奇数）：则中位数为 A 的堆顶元素。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/68a1972bd8f51f8b042717a82f2984787729d8daec41f965e9a26f0adccd3a29-Picture11.png" alt="img"></p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：<ul>
<li>查找中位数 O(1) ： 获取堆顶元素使用 O(1) 时间；</li>
<li>添加数字 O(logN) ： 堆的插入和弹出操作使用 )O(logN) 时间。</li>
</ul>
</li>
<li>空间复杂度 O(N) ： 其中 N 为数据流中的元素数量，小顶堆 A 和大顶堆 B 最多同时保存 N 个元素。</li>
</ul>
<p>Java 使用 <code>PriorityQueue&lt;&gt;((x, y) -&gt; (y - x))</code> 可方便实现大顶堆。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; A,B;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">    A = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();<span class="comment">// 小根堆，保存较大的一半</span></span><br><span class="line">    B = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x,y) -&gt; (y - x)); <span class="comment">// 大根堆，保存较大的一半</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() != B.size()) &#123; <span class="comment">// m != n 向B加入数据</span></span><br><span class="line">        A.add(num);</span><br><span class="line">        B.add(A.poll());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// m == n 向A加入数据</span></span><br><span class="line">        B.add(num);</span><br><span class="line">        A.add(B.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() == B.size()) &#123; <span class="comment">//偶数</span></span><br><span class="line">        <span class="keyword">return</span> (A.peek() + B.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 奇数</span></span><br><span class="line">        <span class="keyword">return</span> A.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、剑指-Offer-45-把数组排成最小的数"><a href="#7、剑指-Offer-45-把数组排成最小的数" class="headerlink" title="7、剑指 Offer 45. 把数组排成最小的数"></a>7、剑指 Offer 45. 把数组排成最小的数</h3><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure>



<p><strong>提示:</strong></p>
<ul>
<li><code>0 &lt; nums.length &lt;= 100</code></li>
</ul>
<p><strong>说明:</strong></p>
<ul>
<li>输出结果可能非常大，所以你需要返回一个字符串而不是整数</li>
<li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</li>
</ul>
<p>Related Topics</p>
<p>贪心</p>
<p>字符串</p>
<p>排序</p>
<p>👍 564</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>此题求拼接起来的最小数字，本质上是一个排序问题。设数组 numsnums 中任意两数字的字符串为 x 和 y ，则规定 <code>排序判断规则</code> 为：</p>
<ul>
<li>若拼接字符串 x + y &gt; y + x ，则 x “大于” y ；</li>
<li>反之，若 x + y &lt; y + x ，则 x “小于” y ；</li>
</ul>
<blockquote>
<p><em>x</em> “小于” <em>y</em> 代表：排序完成后，数组中 <em>x</em> 应在 <em>y</em> 左边；“大于” 则反之。</p>
</blockquote>
<p>根据以上规则，套用任何排序方法对 nums 执行排序即可。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/95e81dbccc44f26292d88c509afd68204a86b37d342f83d109fa7aa0cd4a6049-Picture1.png" alt="Picture1.png"></p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>初始化： 字符串列表 strs，保存各数字的字符串格式；</li>
<li>列表排序： 应用以上 “排序判断规则” ，对 strs 执行排序；</li>
<li>返回值： 拼接 strs 中的所有字符串，并返回。</li>
</ol>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(NlogN) ： N 为最终返回值的字符数量（ strs 列表的长度 ≤ N ）；使用快排或内置函数的平均时间复杂度为 O(NlogN) ，最差为 O(N^2) 。</li>
<li>空间复杂度 O(N) ： 字符串列表 strs 占用线性大小的额外空间。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/14e3e6b5a28486fc4b0e7c614d75eb239aafca71b4ac5a6907d7e4154b27784a-Picture4.png" alt="img"></p>
<p><strong>代码</strong>：<br>本文列举 快速排序 和 内置函数 两种排序方法，其他排序方法也可实现。</p>
<p><strong>快速排序</strong>：<br>需修改快速排序函数中的排序判断规则。字符串大小（字典序）对比的实现方法：<br>Java 中使用函数 A.compareTo(B)；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        quickSort(strs, <span class="number">0</span>, strs.length - <span class="number">1</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(String s : strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(String[] strs, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = r;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> strs[i];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="keyword">while</span>((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= <span class="number">0</span> &amp;&amp; i &lt; j) i++;</span><br><span class="line">            tmp = strs[i];</span><br><span class="line">            strs[i] = strs[j];</span><br><span class="line">            strs[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        strs[i] = strs[l];</span><br><span class="line">        strs[l] = tmp;</span><br><span class="line">        quickSort(strs, l, i - <span class="number">1</span>);</span><br><span class="line">        quickSort(strs, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内置函数</strong>：<br>需定义排序规则：<br>Java 定义为 (x, y) -&gt; (x + y).compareTo(y + x) ；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x));</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(String s : strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8、剑指-Offer-61-扑克牌中的顺子"><a href="#8、剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="8、剑指 Offer 61. 扑克牌中的顺子"></a>8、剑指 Offer 61. 扑克牌中的顺子</h3><p>从<strong>若干副扑克牌</strong>中随机抽 <code>5</code> 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>



<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<p>数组长度为 5</p>
<p>数组的数取值为 [0, 13] .</p>
<p>Related Topics</p>
<p>数组</p>
<p>排序</p>
<p>👍 288</p>
<p>👎 0</p>
<p><strong>解题思路：</strong></p>
<h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><ol>
<li>遍历过程中统计joker的数量，用于后续替代其他卡牌。</li>
<li>如果遇到两张相等，则直接返回false。</li>
<li>遇到不连续的情况，就让joker来替代卡牌。</li>
<li>遍历完成后，返回true。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStraight</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums); <span class="comment">// 排序：统计joker</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">joker</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            joker++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123; <span class="comment">// 排除相等的两张直接为错</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + <span class="number">1</span> != nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[i + <span class="number">1</span>] - nums[i] - <span class="number">1</span>; <span class="comment">// 需要几张joker</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt; joker) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> joker -= res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>根据题意，此 5 张牌是顺子的 <code>充分条件</code> 如下：</p>
<ol>
<li>除大小王外，所有牌 <code>无重复</code> ；</li>
<li>设此 5 张牌中最大的牌为 max ，最小的牌为 min （大小王除外），则需满足：<br>max - min &lt; 5</li>
</ol>
<p>因此可将问题转化为：此 5 张牌是否满足以上两个条件？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599885716-MGMODX-Picture1.png" alt="Picture1.png"></p>
<p>方法一： <strong>集合 Set + 遍历</strong></p>
<ul>
<li>遍历五张牌，遇到大小王（即 0 ）直接跳过。</li>
<li>判别重复： 利用 Set 实现遍历判重， Set 的查找方法的时间复杂度为 O(1)O(1) ；</li>
<li>获取最大 &#x2F; 最小的牌： 借助辅助变量 ma 和 mi ，遍历统计即可。</li>
</ul>
<p><strong>复杂度分析</strong>：<br>时间复杂度 O(1) ： 本题中给定牌数量 N≡5 ；遍历数组使用 O(N) &#x3D; O(5) &#x3D; O(1) 时间。<br>空间复杂度 O(1) ： 用于判重的辅助 Set 使用 O(N) &#x3D; O(1) 额外空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStraight</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; repeat = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, min = <span class="number">14</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 跳过大小王</span></span><br><span class="line">            max = Math.max(max, num); <span class="comment">// 最大牌</span></span><br><span class="line">            min = Math.min(min, num); <span class="comment">// 最小牌</span></span><br><span class="line">            <span class="keyword">if</span>(repeat.contains(num)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 若有重复，提前返回 false</span></span><br><span class="line">            repeat.add(num); <span class="comment">// 添加此牌至 Set</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max - min &lt; <span class="number">5</span>; <span class="comment">// 最大牌 - 最小牌 &lt; 5 则可构成顺子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：<strong>排序 + 遍历</strong></p>
<ul>
<li>先对数组执行排序。</li>
<li>判别重复： 排序数组nums[i]&#x3D;nums[i+1] 是否成立来判重。</li>
<li>获取最大 &#x2F; 最小的牌： 排序后，数组末位元素 nums[4] 为最大牌；元素 nums[joker] 为最小牌，其中 joker 为大小王的数量。</li>
</ul>
<p>复杂度分析：<br>时间复杂度 O(1) ： 本题中给定牌数量 N≡5 ；数组排序使用 O(NlogN)&#x3D;O(5log5)&#x3D;O(1) 时间。<br>空间复杂度O(1) ： 变量 joker 使用 O(1) 大小的额外空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599885716-Lqyuwk-Picture15.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStraight</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">joker</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 数组排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) joker++; <span class="comment">// 统计大小王数量</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 若有重复，提前返回 false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">4</span>] - nums[joker] &lt; <span class="number">5</span>; <span class="comment">// 最大牌 - 最小牌 &lt; 5 则可构成顺子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十一、查找算法"><a href="#十一、查找算法" class="headerlink" title="十一、查找算法"></a>十一、查找算法</h2><h3 id="1、剑指-Offer-03-数组中重复的数字"><a href="#1、剑指-Offer-03-数组中重复的数字" class="headerlink" title="1、剑指 Offer 03. 数组中重复的数字"></a>1、剑指 Offer 03. 数组中重复的数字</h3><p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 &lt;= n &lt;= 100000</span><br></pre></td></tr></table></figure>

<p>Related Topics</p>
<p>数组</p>
<p>哈希表</p>
<p>排序</p>
<p>👍 1017</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<h4 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h4><p>利用数据结构特点，容易想到使用哈希表（Set）记录数组的各个数字，当查找到重复数字则直接返回。</p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>初始化： 新建 HashSet ，记为 set ；</li>
<li>遍历数组 nums 中的每个数字 num ：<ol>
<li>当 num 在 set 中，说明重复，直接返回 num ；</li>
<li>将 num 添加至 set 中；</li>
</ol>
</li>
<li>返回 -1 。本题中一定有重复数字，因此这里返回多少都可以。</li>
</ol>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N) ： 遍历数组使用 O(N) ，HashSet 添加与查找元素皆为 O(1) 。</li>
<li>空间复杂度 O(N) ： HashSet 占用 O(N) 大小的额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 哈希set</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">     Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">         <span class="keyword">if</span> (set.contains(num)) <span class="keyword">return</span> num;</span><br><span class="line">         <span class="keyword">else</span> set.add(num);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 数组记录</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">     <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100000</span>];</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">         <span class="keyword">if</span> (arr[num] == <span class="number">1</span>) <span class="keyword">return</span> num;</span><br><span class="line">         <span class="keyword">else</span> arr[num] = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：原地交换"><a href="#方法二：原地交换" class="headerlink" title="方法二：原地交换"></a>方法二：原地交换</h4><p>题目说明尚未被充分使用，即 <code>在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内</code> 。 此说明含义：数组元素的 <strong>索引</strong> 和 <strong>值</strong> 是 <strong>一对多</strong> 的关系。</p>
<p>因此，可遍历数组并通过交换操作，使元素的 <strong>索引</strong> 与 <strong>值</strong> 一一对应（即 nums[i] &#x3D; i ）。因而，就能通过索引映射对应的值，起到与字典等价的作用。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/c1fc8ab927c2663d44d6e11ec3db3871db816999466ceeacbe57e6cf6e9de149-Picture0.png" alt="Picture0.png"></p>
<p>遍历中，第一次遇到数字 x 时，将其交换至索引 x 处；而当第二次遇到数字 x 时，一定有 nums[x] &#x3D; x ，此时即可得到一组重复数字。</p>
<p><strong>算法流程</strong>：</p>
<p>遍历数组 nums ，设索引初始值为 i &#x3D; 0 :</p>
<p>若 nums[i] &#x3D; i ： 说明此数字已在对应索引位置，无需交换，因此跳过；<br>若 nums[nums[i]] &#x3D; nums[i] ： 代表索引 nums[i] 处和索引 i 处的元素值都为 nums[i] ，即找到一组重复值，返回此值 nums[i] ；<br>否则： 交换索引为 i 和 nums[i] 的元素值，将此数字交换至对应索引位置。<br>若遍历完毕尚未返回，则返回 −1 。</p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N) ： 遍历数组使用 O(N) ，每轮遍历的判断和交换操作使用 O(1) 。</li>
<li>空间复杂度 O(1) ： 使用常数复杂度的额外空间。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/82ea50d1915609e368839cac6d4e0e615ff8297138aff645d0c2aba79e6a7b7e-Picture15.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原地交换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber3</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (i &lt; nums.length) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[i] == i) &#123; <span class="comment">// 已经有序</span></span><br><span class="line">               i++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (nums[nums[i]] == nums[i]) &#123; <span class="comment">// 排好序后，遇到了第二个这个数</span></span><br><span class="line">               <span class="keyword">return</span> nums[i];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 交换</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">           nums[i] = nums[nums[i]];</span><br><span class="line">           nums[nums[i]] = tmp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、剑指-Offer-04-二维数组中的查找"><a href="#2、剑指-Offer-04-二维数组中的查找" class="headerlink" title="2、剑指 Offer 04. 二维数组中的查找"></a>2、剑指 Offer 04. 二维数组中的查找</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右 <strong>非递减</strong> 的顺序排序，每一列都按照从上到下 <strong>非递减</strong> 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>示例:</strong></p>
<p>现有矩阵 matrix 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>给定 target &#x3D; <code>5</code>，返回 <code>true</code>。</p>
<p>给定 target &#x3D; <code>20</code>，返回 <code>false</code>。</p>
<p><strong>限制：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= n &lt;= 1000</span><br><span class="line">0 &lt;= m &lt;= 1000</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong>本题与主站 240 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">https://leetcode-cn.com/problems/search-a-2d-matrix-ii/</a></p>
<p>Related Topics</p>
<p>数组</p>
<p>二分查找</p>
<p>分治</p>
<p>矩阵</p>
<p>👍 833</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<blockquote>
<p>若使用暴力法遍历矩阵 <code>matrix</code> ，则时间复杂度为 O(NM) 。暴力法未利用矩阵 <strong>“从上到下递增、从左到右递增”</strong> 的特点，显然不是最优解法。</p>
</blockquote>
<p>如下图所示，我们将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于 <strong>二叉搜索树</strong> ，即对于每个元素，其左分支元素更小、右分支元素更大。因此，通过从 “根节点” 开始搜索，遇到比 <code>target</code> 大的元素就向左，反之向右，即可找到目标值 <code>target</code> 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png" alt="Picture1.png"></p>
<p>“根节点” 对应的是矩阵的 “左下角” 和 “右上角” 元素，本文称之为 <strong>标志数</strong> ，以 <code>matrix</code> 中的 <strong>左下角元素</strong> 为标志数 <code>flag</code> ，则有:</p>
<ol>
<li>若 flag &gt; target ，则 target 一定在 flag 所在 行的上方 ，即 flag 所在行可被消去。</li>
<li>若 flag &lt; target ，则 target 一定在 flag 所在 列的右方 ，即 flag 所在列可被消去。</li>
</ol>
<p><strong>算法流程</strong>：</p>
<ol>
<li><p>从矩阵 matrix 左下角元素（索引设为 (i, j) ）开始遍历，并与目标值对比：</p>
<ul>
<li>当 matrix[i] [j] &gt; target 时，执行 i– ，即消去第 i 行元素；</li>
<li>当 matrix[i] [j] &lt; target 时，执行 j++ ，即消去第 j 列元素；</li>
<li>当 matrix[i] [j] &#x3D; target 时，返回 true ，代表找到目标值。</li>
</ul>
</li>
<li><p>若行索引或列索引越界，则代表矩阵中无目标值，返回 false<em>f<strong>a</strong>l<strong>s</strong>e</em> 。</p>
</li>
</ol>
<blockquote>
<p>每轮 <code>i</code> 或 <code>j</code> 移动后，相当于生成了“消去一行（列）的新矩阵”， 索引<code>(i,j)</code> 指向新矩阵的左下角元素（标志数），因此可重复使用以上性质消去行（列）。</p>
</blockquote>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(M+N) ：其中，N 和 M 分别为矩阵行数和列数，此算法最多循环 M+N 次。</li>
<li>空间复杂度 O(1) : i, j 指针使用常数大小额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray2</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> matrix.length - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> traversal(matrix, matrix.length - <span class="number">1</span>, <span class="number">0</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">traversal</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> startX, <span class="type">int</span> startY, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (startX &lt; <span class="number">0</span> || startY &gt;= matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (matrix[startX][startY] ==  target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[startX][startY] &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> traversal(matrix, startX - <span class="number">1</span>, startY, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// &lt;</span></span><br><span class="line">        <span class="keyword">return</span> traversal(matrix, startX, startY + <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、剑指-Offer-11-旋转数组的最小数字"><a href="#3、剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="3、剑指 Offer 11. 旋转数组的最小数字"></a>3、剑指 Offer 11. 旋转数组的最小数字</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>
<p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>numbers</code> ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的<strong>最小元素</strong>。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一次旋转，该数组的最小值为 1。</p>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numbers = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numbers = [2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>n == numbers.length</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>-5000 &lt;= numbers[i] &lt;= 5000</code></li>
<li><code>numbers</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li>
</ul>
<p>注意：本题与主站 154 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/</a></p>
<p>Related Topics</p>
<p>数组</p>
<p>二分查找</p>
<p>👍 732</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>如下图所示，寻找旋转数组的最小元素即为寻找 <strong>右排序数组</strong> 的首个元素 nums[x]，称 x 为 <strong>旋转点</strong> 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599404042-JMvjtL-Picture1.png" alt="Picture1.png"></p>
<p>排序数组的查找问题首先考虑使用 <strong>二分法</strong> 解决，其可将 <strong>遍历法</strong> 的 <strong>线性级别</strong> 时间复杂度降低至 <strong>对数级别</strong> 。</p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>初始化： 声明 i, j 双指针分别指向 nums 数组左右两端；</li>
<li><strong>循环二分</strong>： 设 m &#x3D; (i + j) &#x2F; 2 为每次二分的中点（ “&#x2F;“ 代表向下取整除法，因此恒有 i≤m&lt;j , 左闭右开[)），可分为以下三种情况：<ol>
<li>当 nums[m] &gt; nums[j] 时： m 一定在 左排序数组 中，即旋转点 x 一定在 [m + 1, j] 闭区间内，因此执行 i &#x3D; m + 1；</li>
<li>当 nums[m] &lt; nums[j] 时： m 一定在 右排序数组 中，即旋转点 x 一定在 [i, m] 闭区间内，因此执行 j &#x3D; m；</li>
<li>当 nums[m] &#x3D; nums[j] 时： 无法判断 m 在哪个排序数组中，即无法判断旋转点 x 在 [i, m] 还是 [m + 1, j] 区间中。解决方案： 执行 j &#x3D; j - 1 缩小判断范围，分析见下文。</li>
</ol>
</li>
<li>返回值： 当 i &#x3D; j 时跳出二分循环，并返回 旋转点的值 nums[i] 即可。</li>
</ol>
<p><strong>正确性证明</strong>：</p>
<p>当 nums[m] &#x3D; nums[j] 时，无法判定 m 在左（右）排序数组，自然也无法通过二分法安全地缩小区间，因为其会导致旋转点 x 不在区间 [i, j] 内。举例如下：</p>
<blockquote>
<p>设以下两个旋转点值为 0 的示例数组，则当 i &#x3D; 0, j &#x3D; 4 时 m &#x3D; 2 ，两示例结果不同。<br>示例一 [1, 0, 1, 1, 1] ：旋转点 x &#x3D; 1 ，因此 m &#x3D; 2 在 右排序数组 中。<br>示例二 [1, 1, 1, 0, 1] ：旋转点 x &#x3D; 3 ，因此 m &#x3D; 2 在 左排序数组 中。</p>
</blockquote>
<p>而证明 j &#x3D; j - 1 正确（缩小区间安全性），需分为两种情况：</p>
<ol>
<li><p>当 x &lt; j 时： 易得执行 j &#x3D; j - 1 后，旋转点 x 仍在区间 [i, j] 内。</p>
</li>
<li><p>当 x &#x3D; j 时： 执行 j &#x3D; j - 1 后越过（丢失）了旋转点 x ，但最终返回的元素值 nums[i] 仍等于旋转点值 nums[x] 。</p>
<ol>
<li>由于 x &#x3D; j ，因此 nums[x] &#x3D; nums[j] &#x3D; nums[m] ≤ nums[i] ;</li>
<li>又由于 i ≤ m &lt; j 恒成立，因此有 m &lt; x ，即此时 m 一定在左排序数组中，因此 nums[m] ≥ nums[i] ;</li>
</ol>
</li>
</ol>
<ul>
<li><p>综合 1. , 2. ，可推出 nums[i] &#x3D; nums[m] ，且区间 [i, m] 内所有元素值相等，即有：<br>nums[i] &#x3D; nums[i+1] &#x3D; … &#x3D; nums[m] &#x3D; nums[x]</p>
</li>
<li><p>此时，执行 j &#x3D; j - 1 后虽然丢失了旋转点 x ，但之后区间 [i, j] 只包含左排序数组，二分下去返回的一定是本轮的 nums[i] ，而其与 nums[x] 相等。</p>
</li>
</ul>
<blockquote>
<p>综上所述，此方法可以保证返回值 nums[i] 等于旋转点值 nums[x] ，但在少数特例下 i !&#x3D; x ；而本题目只要求返回 “旋转点的值” ，因此本方法正确。</p>
</blockquote>
<p><strong>补充思考</strong>： 为什么本题二分法不用 nums[m] 和 nums[i] 作比较？</p>
<p>二分目的是判断 m 在哪个排序数组中，从而缩小区间。而在 nums[m] &gt; nums[i] 情况下，无法判断 m 在哪个排序数组中。本质上是由于 j 初始值肯定在右排序数组中； i 初始值无法确定在哪个排序数组中。举例如下：</p>
<blockquote>
<p>对于以下两示例，当 i &#x3D; 0, j &#x3D; 4, m &#x3D; 2 时，有 nums[m] &gt; nums[i] ，而结果不同。<br>[1, 2, 3, 4 ,5] 旋转点 x &#x3D; 0 ： m 在右排序数组（此示例只有右排序数组）；<br>[3, 4, 5, 1 ,2] 旋转点 x &#x3D; 3 ： m 在左排序数组。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599404366-ngPDoD-Picture9.png" alt="img"></p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(log N) ： 在特例情况下（例如 [1, 1, 1, 1]），会退化到 O(N)。</li>
<li>空间复杂度 O(1) ： i , j , m 变量使用常数大小的额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (numbers[m] &gt; numbers[j]) i = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (numbers[m] &lt; numbers[j]) j = m;</span><br><span class="line">        <span class="keyword">else</span> j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，当出现 nums[m] &#x3D; nums[j] 时，一定有区间 [i, m] 内所有元素相等 或 区间 [m, j] 内所有元素相等（或两者皆满足）。对于寻找此类数组的最小值问题，可直接放弃二分查找，而使用线性查找替代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray2</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (numbers[m] &gt; numbers[j]) i = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (numbers[m] &lt; numbers[j]) j = m;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[k] &lt; numbers[x]) &#123;</span><br><span class="line">                    x = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> numbers[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、剑指-Offer-50-第一个只出现一次的字符"><a href="#4、剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="4、剑指 Offer 50. 第一个只出现一次的字符"></a>4、剑指 Offer 50. 第一个只出现一次的字符</h3><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abaccdeff&quot;</span><br><span class="line">输出：&#x27;b&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;&quot; </span><br><span class="line">输出：&#x27; &#x27;</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= s 的长度 &lt;= 50000</span><br></pre></td></tr></table></figure>

<p>Related Topics</p>
<p>队列</p>
<p>哈希表</p>
<p>字符串</p>
<p>计数</p>
<p>👍 275</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>本题考察 <strong>哈希表</strong> 的使用，本文介绍 <strong>哈希表</strong> 和 <strong>有序哈希表</strong> 两种解法。其中，在字符串长度较大、重复字符很多时，“有序哈希表” 解法理论上效率更高。</p>
<h4 id="方法一：哈希表-1"><a href="#方法一：哈希表-1" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h4><ol>
<li>遍历字符串 s ，使用哈希表统计 “各字符数量 ”。</li>
<li>再遍历字符串 s ，在哈希表中找到首个 “数量为 1 的字符”，并返回。</li>
</ol>
<p><strong>算法流程</strong>：</p>
<ol>
<li>初始化： HashMap(Java)，记为 map；</li>
<li>字符统计： 遍历字符串 s 中的每个字符 c , 更新该字符在 map 中记录的个数。</li>
<li>查找数量为 1 的字符： 遍历字符串 s 中的每个字符 c ；若 map中键 c 对应的值为 1：，则返回 c 。</li>
<li>返回 ‘ ‘ ，代表字符串无数量为 1 的字符。</li>
</ol>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N) ： N 为字符串 s 的长度；需遍历 s 两轮,使用 O(N) ；HashMap 查找操作的复杂度为 O(1)；</li>
<li>空间复杂度 O(1) ： 由于题目指出 s 只包含小写字母，因此最多有 26 个不同字符，HashMap 存储需占用 O(26) &#x3D; O(1) 的额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        map.put(s.charAt(i), map.getOrDefault(s.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.get(s.charAt(i)) == <span class="number">1</span>) <span class="keyword">return</span> s.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：有序哈希表"><a href="#方法二：有序哈希表" class="headerlink" title="方法二：有序哈希表"></a>方法二：有序哈希表</h4><p>在哈希表的基础上，有序哈希表中的键值对是 <code>按照插入顺序排序</code> 的。基于此，可通过遍历有序哈希表，实现搜索首个 “数量为 1 的字符”。</p>
<p>哈希表是 <code>去重</code> 的，即哈希表中键值对数量 &lt;&#x3D; 字符串 s 的长度。因此，相比于方法一，方法二减少了第二轮遍历的循环次数。当字符串很长（重复字符很多）时，方法二则效率更高。</p>
<p><strong>复杂度分析</strong>：<br>时间和空间复杂度均与 “方法一” 相同，而具体分析：方法一 需遍历 s 两轮；方法二 遍历 s 一轮，遍历 map一轮（ map 的长度不大于 26 ）。</p>
<p>Java 使用 <code>LinkedHashMap</code> 实现有序哈希表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        map.put(s.charAt(i), map.getOrDefault(s.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; m : map.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m.getValue() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> m.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、剑指-Offer-53-II-0～n-1-中缺失的数字"><a href="#5、剑指-Offer-53-II-0～n-1-中缺失的数字" class="headerlink" title="5、剑指 Offer 53 - II. 0～n-1 中缺失的数字"></a>5、剑指 Offer 53 - II. 0～n-1 中缺失的数字</h3><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= 数组长度 &lt;= 10000</span><br></pre></td></tr></table></figure>

<p>Related Topics</p>
<p>位运算</p>
<p>数组</p>
<p>哈希表</p>
<p>数学</p>
<p>二分查找</p>
<p>👍 326</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>排序数组中的搜索问题，首先想到 <code>二分法</code> 解决。根据题意，数组可以按照以下规则划分为两部分。</p>
<ul>
<li>左子数组： nums[i] &#x3D; i ；</li>
<li>右子数组： nums[i] !&#x3D; i；</li>
</ul>
<p>缺失的数字等于 <strong>“右子数组的首位元素”</strong> 对应的索引；因此考虑使用二分法查找 “右子数组的首位元素” 。</p>
<p><strong>算法解析</strong>：</p>
<ol>
<li>初始化： 左边界 i &#x3D; 0 ，右边界 j &#x3D; len(nums) - 1 ；代表闭区间 [i, j] 。</li>
<li>循环二分： 当 i ≤ j 时循环 （即当闭区间 [i, j] 为空时跳出） ；<ol>
<li>计算中点 m &#x3D; (i + j) &#x2F;&#x2F; 2 ，其中 “&#x2F;&#x2F;“ 为向下取整除法；</li>
<li>若 nums[m] &#x3D; m ，则 “右子数组的首位元素” 一定在闭区间 [m + 1, j] 中，因此执行 i &#x3D; m + 1；</li>
<li>若 nums[m] !&#x3D;m ，则 “左子数组的末位元素” 一定在闭区间 [i, m - 1] 中，因此执行 j &#x3D; m - 1；</li>
</ol>
</li>
<li>返回值： 跳出时，变量 i 和 j 分别指向 “右子数组的首位元素” 和 “左子数组的末位元素” 。因此返回 i 即可。</li>
</ol>
<p>复杂度分析： </p>
<ul>
<li>时间复杂度 O(log N)： 二分法为对数级别复杂度。</li>
<li>空间复杂度 O(1)： 几个变量使用常数大小的额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找</span></span><br><span class="line"><span class="comment"> * 0 &lt;= nums[i] &lt;= n-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) / <span class="number">2</span>); <span class="comment">// mid</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == mid) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#6、剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="6、剑指 Offer 53 - I. 在排序数组中查找数字 I"></a>6、剑指 Offer 53 - I. 在排序数组中查找数字 I</h3><p>统计一个数字在排序数组中出现的次数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 105</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>nums</code> 是一个非递减数组</li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
</ul>
<p><strong>注意：</strong>本题与主站 34 题相同（仅返回值不同）：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
<p>Related Topics</p>
<p>数组</p>
<p>二分查找</p>
<p>👍 382</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<blockquote>
<p>排序数组中的搜索问题，首先想到 <strong>二分法</strong> 解决。</p>
</blockquote>
<p>排序数组 nums 中的所有数字 target 形成一个窗口，记窗口的 <code>左 / 右边界</code> 索引分别为 left 和 right ，分别对应窗口左边 &#x2F; 右边的首个元素。</p>
<p>本题要求统计数字 target 的出现次数，可转化为：使用二分法分别找到 左边界 left 和 右边界 right ，易得数字 target 的数量为 right - left - 1 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1600793982-pWqZGf-Picture1.png" alt="Picture1.png"></p>
<p><strong>算法解析</strong>：</p>
<ol>
<li>初始化： 左边界 i &#x3D; 0 ，右边界 j &#x3D; len(nums) - 1 。</li>
<li>循环二分： 当闭区间 [i, j] 无元素时跳出；<ol>
<li>计算中点 m &#x3D; (i + j) &#x2F; 2 （向下取整）；</li>
<li>若 nums[m] &lt; target ，则 target 在闭区间 [m + 1, j] 中，因此执行 i &#x3D; m + 1；</li>
<li>若 nums[m] &gt; target ，则 target 在闭区间 [i, m - 1] 中，因此执行 j &#x3D; m - 1；</li>
<li>若 nums[m] &#x3D; target ，则右边界 right 在闭区间 [m + 1, j] 中；左边界 left 在闭区间 [i, m-1] 中。因此分为以下两种情况：<ul>
<li>若查找 <strong>右边界</strong> right ，则执行 i &#x3D; m + 1 ；（跳出时 i 指向右边界）</li>
<li>若查找 <strong>左边界</strong> left ，则执行 j &#x3D; m - 1 ；（跳出时 j 指向左边界）</li>
</ul>
</li>
</ol>
</li>
<li>返回值： 应用两次二分，分别查找 right 和 left ，最终返回 right - left - 1 即可。</li>
</ol>
<p><strong>效率优化</strong>：</p>
<blockquote>
<p>以下优化基于：查找完右边界 right &#x3D; i 后，则 nums[j] 指向最右边的 target（若存在）。</p>
</blockquote>
<ol>
<li>查找完右边界后，可用 nums[j] &#x3D; target 判断数组中是否包含 target ，若不包含则直接提前返回 0 ，无需后续查找左边界。</li>
<li>查找完右边界后，左边界 left 一定在闭区间 [0, j] 中，因此直接从此区间开始二分查找即可。</li>
</ol>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(log N)： 二分法为对数级别复杂度。</li>
<li>空间复杂度 O(1) ： 几个变量使用常数大小的额外空间。</li>
</ul>
<h4 id="code1-两次二分"><a href="#code1-两次二分" class="headerlink" title="code1:两次二分"></a>code1:两次二分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 搜索右边界 right</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt;= target) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">// 若数组中无 target ，则提前返回</span></span><br><span class="line">        <span class="keyword">if</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] != target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 搜索左边界 right</span></span><br><span class="line">        i = <span class="number">0</span>; j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt; target) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="code2-封装二分法，简化代码"><a href="#code2-封装二分法，简化代码" class="headerlink" title="code2:封装二分法，简化代码"></a>code2:封装二分法，简化代码</h4><p>以上代码显得比较臃肿（两轮二分查找代码冗余）。为简化代码，可将二分查找右边界 right 的代码 封装至函数 helper() 。<br>如下图所示，由于数组 nums 中元素都为整数，因此可以分别二分查找 target 和 target - 1 的右边界，将两结果相减并返回即可。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1600793982-ikEYZs-Picture2.png" alt="Picture2.png"></p>
<p>本质上看， <code>helper()</code> 函数旨在查找数字 tar 在数组 nums 中的 <strong>插入点</strong> ，且若数组中存在值相同的元素，则插入到这些元素的右边。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, target) - helper(nums, target - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> tar)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt;= tar) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="code3-先二分，再两边同时逼近（顺序）"><a href="#code3-先二分，再两边同时逼近（顺序）" class="headerlink" title="code3:先二分，再两边同时逼近（顺序）"></a>code3:先二分，再两边同时逼近（顺序）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 左闭右闭[,]</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 顺序 查找</span></span><br><span class="line">                <span class="keyword">if</span> (nums[right] != target) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] != target) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[right] == nums[left]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、剑指-Offer-25-合并两个排序的链表"><a href="#7、剑指-Offer-25-合并两个排序的链表" class="headerlink" title="7、剑指 Offer 25. 合并两个排序的链表"></a>7、剑指 Offer 25. 合并两个排序的链表</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= 链表长度 &lt;= 1000</span><br></pre></td></tr></table></figure>

<p>注意：本题与主站 21 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p>
<p>Related Topics</p>
<p>递归</p>
<p>链表</p>
<p>👍 299</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<ul>
<li><p>根据题目描述， 链表 l1 , l2 是 <strong>递增</strong> 的，因此容易想到使用双指针 cur1, cur2 遍历两链表，根据 l1.vall 和 l2.val 的大小关系确定节点添加顺序，两节点指针交替前进，直至遍历完毕。</p>
</li>
<li><p>引入伪头节点： 由于初始状态合并链表中无节点，因此循环第一轮时无法将节点添加到合并链表中。解决方案：初始化一个辅助节点 dum 作为合并链表的伪头节点，将各节点添加至 dum 之后。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/e4c8c97883da50d81498fd1f1e6cdd575429bd65f9f2babb00dc2b709f7ad8b2-Picture1.png" alt="Picture1.png"></p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>初始化： 伪头节点 dum ，节点 cur 指向 dumdum 。</li>
<li>循环合并： 当 l1 或 l2 为空时跳出；<ol>
<li>当 l1.val &lt; l2.val 时： cur 的后继节点指定为 l1 ，并 l1 向前走一步；</li>
<li>当 l1.val ≥ l2.val 时： cur 的后继节点指定为 l2 ，并 l2 向前走一步 ；</li>
<li>节点 cur 向前走一步，即 cur &#x3D; cur.next 。</li>
</ol>
</li>
<li>合并剩余尾部： 跳出时有两种情况，即 l1 为空 或 l2 为空。<ol>
<li>若 l1 !&#x3D; null ： 将 l1 添加至节点 cur 之后；</li>
<li>否则： 将 l2 添加至节点 cur 之后。</li>
</ol>
</li>
<li>返回值： 合并链表在伪头节点 dum 之后，因此返回 dum.next 即可。</li>
</ol>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度 O(M+N) ： M, N 分别为链表 l1 , l2 的长度，合并操作需遍历两链表。</li>
<li>空间复杂度 O(1) ： 节点引用 dum , cur 使用常数大小的额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>), cur = dum;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = l1 != <span class="literal">null</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、剑指-Offer-52-两个链表的第一个公共节点"><a href="#8、剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="8、剑指 Offer 52. 两个链表的第一个公共节点"></a>8、剑指 Offer 52. 两个链表的第一个公共节点</h3><p>输入两个链表，找出它们的第一个公共节点。</p>
<p>如下面的两个链表<strong>：</strong></p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/160_statement.png" alt="img"></a></p>
<p>在节点 c1 开始相交。</p>
<p><strong>示例 1：</strong></p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/160_example_1.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Reference of the node with value = 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>



<p><strong>示例 2：</strong></p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/160_example_2.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Reference of the node with value = 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>



<p><strong>示例 3：</strong></p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/160_example_3.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong></p>
<ul>
<li>如果两个链表没有交点，返回 <code>null</code>.</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li>
<li>本题与主站 160 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></li>
</ul>
<p>Related Topics</p>
<p>哈希表</p>
<p>链表</p>
<p>双指针</p>
<p>👍 568</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>设「第一个公共节点」为 node ，「链表 headA」的节点数量为 a ，「链表 headB」的节点数量为 b ，「两链表的公共尾部」的节点数量为 c ，则有：</p>
<ul>
<li>头节点 <code>headA</code> 到 <code>node</code> 前，共有 a - c 个节点；</li>
<li>头节点 <code>headB</code> 到 <code>node</code> 前，共有 b - c 个节点；</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1615224578-EBRtwv-Picture1.png" alt="Picture1.png"></p>
<p>考虑构建两个节点指针 <code>A</code> , <code>B</code> 分别指向两链表头节点 <code>headA</code> , <code>headB</code> ，做如下操作：</p>
<ul>
<li><p>指针 A 先遍历完链表 headA ，再开始遍历链表 headB ，当走到 node 时，共走步数为：a + (b - c)</p>
</li>
<li><p>指针 B 先遍历完链表 headB ，再开始遍历链表 headA ，当走到 node 时，共走步数为：b + (a - c)</p>
</li>
</ul>
<p>如下式所示，此时指针 <code>A</code> , <code>B</code> 重合，并有两种情况： a + (b - c) &#x3D; b + (a - c)</p>
<ul>
<li>若两链表 有 公共尾部 (即 c &gt; 0 ) ：指针 A , B 同时指向「第一个公共节点」node 。</li>
<li>若两链表 无 公共尾部 (即 c &#x3D; 0 ) ：指针 A , B 同时指向 null 。<br>因此返回 <code>A</code> 即可。</li>
</ul>
<blockquote>
<p>如下图所示，为 a &#x3D; 5, b &#x3D; 3 , c &#x3D; 2 示例的算法执行过程。</p>
</blockquote>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(a + b) ： 最差情况下（即 |a - b| &#x3D; 1 , c &#x3D; 0 ），此时需遍历 a + b 个节点。</li>
<li>空间复杂度 O(1) ： 节点指针 A , B 使用常数大小的额外空间。</li>
</ul>
<h4 id="code1-循环遍历"><a href="#code1-循环遍历" class="headerlink" title="code1 循环遍历"></a>code1 循环遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">A</span> <span class="operator">=</span> headA, B = headB;</span><br><span class="line">        <span class="keyword">while</span> (A != B) &#123;</span><br><span class="line">            A = A != <span class="literal">null</span> ? A.next : headB;</span><br><span class="line">            B = B != <span class="literal">null</span> ? B.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="code2-差值法"><a href="#code2-差值法" class="headerlink" title="code2 差值法"></a>code2 差值法</h4><ol>
<li>先计算两个链表的长度</li>
<li>让长的链表先走差值的大小</li>
<li>遍历，看是否有共同节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur2</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// a 的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lenB</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// b 的长度</span></span><br><span class="line">        <span class="comment">// 计算长度</span></span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            cur1 = cur1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            cur2 = cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 长的先走 len1 - len2 步</span></span><br><span class="line">        cur1 = headA;</span><br><span class="line">        cur2 = headB;</span><br><span class="line">        <span class="keyword">if</span> (lenA &gt; lenB) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> lenA - lenB;</span><br><span class="line">            <span class="keyword">while</span> (len-- != <span class="number">0</span>) &#123;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> lenB - lenA;</span><br><span class="line">            <span class="keyword">while</span> (len-- != <span class="number">0</span>) &#123;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历 看有没有共同节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur1 == cur2) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur1;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9、剑指-Offer-57-和为-s-的两个数字"><a href="#9、剑指-Offer-57-和为-s-的两个数字" class="headerlink" title="9、剑指 Offer 57. 和为 s 的两个数字"></a>9、剑指 Offer 57. 和为 s 的两个数字</h3><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,26,30,31,47,60], target = 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^6</code></li>
</ul>
<p>Related Topics</p>
<p>数组</p>
<p>双指针</p>
<p>二分查找</p>
<p>👍 218</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：<br>利用 HashMap 可以通过遍历数组找到数字组合，时间和空间复杂度均为 O(N) ；<br>注意本题的 nums 是 <code>排序数组</code> ，因此可使用 <code>双指针法</code> 将空间复杂度降低至 O(1) 。</p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>初始化： 双指针 i , j 分别指向数组 nums 的左右两端 （俗称对撞双指针）。</li>
<li>循环搜索： 当双指针相遇时跳出；<ol>
<li>计算和 s &#x3D; nums[i] + nums[j] ；</li>
<li>若 s &gt; target ，则指针 j 向左移动，即执行 j &#x3D; j - 1 ；</li>
<li>若 s &lt; target ，则指针 i 向右移动，即执行 i &#x3D; i + 1 ；</li>
<li>若 s &#x3D; target ，立即返回数组 [nums[i], nums[j]] ；</li>
</ol>
</li>
<li>若循环结束，则返回空数组，代表无和为 target 的数字组合。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1600794717-MdyQXK-Picture5.png" alt="img"></p>
<p>正确性证明：</p>
<blockquote>
<p>记每个状态为 S(i, j) ，即 S(i, j) &#x3D; nums[i] + nums[j] 。假设 S(i, j) &lt; target, 则执行 i &#x3D; i + 1 ，即状态切换至 S(i + 1, j) 。</p>
</blockquote>
<p>状态 S(i, j) 切换至 S(i + 1, j) ，则会消去一行元素，相当于 <code>消去了状态集合</code> {S(i, i + 1), S(i, i + 2), …, S(i, j - 2), S(i, j - 1), S(i, j)} 。（由于双指针都是向中间收缩，因此这些状态之后不可能再遇到）。</p>
<p>由于 nums 是排序数组，因此这些 <code>消去的状态</code> 都一定满足 S(i, j) &lt; target ，即这些状态都 <code>不是解</code> 。</p>
<p><strong>结论</strong>： 以上分析已证明 “每次指针 i 的移动操作，都不会导致解的丢失” ，即指针 i 的移动操作是安全的；同理，对于指针 j 可得出同样推论；因此，此双指针法是正确的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1600794717-VSmNyQ-Picture1.png" alt="Picture1.png"></p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N) ： N 为数组 nums 的长度；双指针共同线性遍历整个数组。</li>
<li>空间复杂度 O(1) ： 变量 i, j 使用常数大小的额外空间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] + nums[right] &gt; target) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[left], nums[right]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10、剑指-Offer-58-I-翻转单词顺序"><a href="#10、剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="10、剑指 Offer 58 - I. 翻转单词顺序"></a>10、剑指 Offer 58 - I. 翻转单词顺序</h3><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong></p>
<ul>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ul>
<p><strong>注意：</strong>本题与主站 151 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a></p>
<p><strong>注意：</strong>此题对比原题有改动</p>
<p>Related Topics</p>
<p>双指针</p>
<p>字符串</p>
<p>👍 254</p>
<p>👎 0</p>
<h4 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h4><p><strong>算法解析</strong>：</p>
<ul>
<li>倒序遍历字符串 s ，记录单词左右索引边界 i , j ；</li>
<li>每确定一个单词的边界，则将其添加至单词列表 res ；</li>
<li>最终，将单词列表拼接为字符串，并返回即可。</li>
</ul>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N) ： 其中 N 为字符串 s 的长度，线性遍历字符串。</li>
<li>空间复杂度 O(N) ： 新建的 StringBuilder(Java) 中的字符串总长度 ≤ N ，占用 O(N) 大小的额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s = s.trim();                                    <span class="comment">// 删除首尾空格</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, i = j;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span>) i--;     <span class="comment">// 搜索首个空格</span></span><br><span class="line">            res.append(s.substring(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="string">&quot; &quot;</span>); <span class="comment">// 添加单词</span></span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>) i--;     <span class="comment">// 跳过单词间空格</span></span><br><span class="line">            j = i;                                       <span class="comment">// j 指向下个单词的尾字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim();                    <span class="comment">// 转化为字符串并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：分割-倒序"><a href="#方法二：分割-倒序" class="headerlink" title="方法二：分割 + 倒序"></a>方法二：分割 + 倒序</h4><p>利用 “字符串分割”、“列表倒序” 的内置函数 （面试时不建议使用） ，可简便地实现本题的字符串翻转要求。</p>
<p>算法解析：</p>
<p>Java ： 以空格为分割符完成字符串分割后，若两单词间有 x &gt; 1 个空格，则在单词列表 strs 中，此两单词间会多出 x - 1 个 “空单词” （即 “” ）。解决方法：倒序遍历单词列表，并将单词逐个添加至 StringBuilder ，遇到空单词时跳过。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1600795186-RmKJXL-Picture2.png" alt="Picture2.png"></p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N) ： 总体为线性时间复杂度，各函数时间复杂度和参考资料链接如下。<ul>
<li>split() 方法： 为 O(N) ；</li>
<li>trim() 和 strip() 方法： 最差情况下（当字符串全为空格时），为 O(N) ；</li>
<li>join() 方法： 为 O(N) ；</li>
<li>reverse() 方法： 为 O(N) ；</li>
</ul>
</li>
<li>空间复杂度 O(N) ： 单词列表 strs 占用线性大小的额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        String[] strs = s.trim().split(<span class="string">&quot; &quot;</span>);        <span class="comment">// 删除首尾空格，分割字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> strs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒序遍历单词列表</span></span><br><span class="line">            <span class="keyword">if</span>(strs[i].equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">continue</span>;        <span class="comment">// 遇到空单词则跳过</span></span><br><span class="line">            res.append(strs[i] + <span class="string">&quot; &quot;</span>);              <span class="comment">// 将单词拼接至 StringBuilder</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim();               <span class="comment">// 转化为字符串，删除尾部空格，并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十二、位运算"><a href="#十二、位运算" class="headerlink" title="十二、位运算"></a>十二、位运算</h2><h3 id="1、剑指-Offer-15-二进制中-1-的个数"><a href="#1、剑指-Offer-15-二进制中-1-的个数" class="headerlink" title="1、剑指 Offer 15. 二进制中 1 的个数"></a>1、剑指 Offer 15. 二进制中 1 的个数</h3><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Hamming_weight">汉明重量</a>).）。</p>
<p><strong>提示：</strong></p>
<ul>
<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>
<li>在 Java 中，编译器使用 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284">二进制补码</a> 记法来表示有符号整数。因此，在上面的 <strong>示例 3</strong> 中，输入表示有符号整数 <code>-3</code>。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 11 (控制台输入 00000000000000000000000000001011)</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 128 (控制台输入 00000000000000000000000010000000)</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li>
</ul>
<p>注意：本题与主站 191 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-1-bits/">https://leetcode-cn.com/problems/number-of-1-bits/</a></p>
<p>Related Topics</p>
<p>位运算</p>
<p>👍 290</p>
<p>👎 0</p>
<h4 id="方法一：逐位判断"><a href="#方法一：逐位判断" class="headerlink" title="方法一：逐位判断"></a>方法一：逐位判断</h4><ul>
<li>根据 <strong>与运算</strong> 定义，设二进制数字 nn ，则有：<ul>
<li>若 n &amp; 1 &#x3D; 0，则 n 二进制 最右一位 为 0 ；</li>
<li>若 n &amp; 1 &#x3D; 1，则 n 二进制 最右一位 为 1 。</li>
</ul>
</li>
<li>根据以上特点，考虑以下 <strong>循环判断</strong> ：<ul>
<li>判断 n 最右一位是否为 1 ，根据结果计数。</li>
<li>将 n 右移一位（本题要求把数字 n 看作无符号数，因此使用 <strong>无符号右移</strong> 操作）。</li>
</ul>
</li>
</ul>
<p><strong>算法流程</strong>：</p>
<ol>
<li>初始化数量统计变量 res &#x3D; 0 。</li>
<li>循环逐位判断： 当 n &#x3D; 0 时跳出。<ol>
<li><code>res += n &amp; 1</code> ： 若 n &amp; 1 &#x3D; 1 ，则统计数 res 加一。</li>
<li><code>n &gt;&gt;= 1</code> ： 将二进制数字 n 无符号右移一位（ Java 中无符号右移为 “&gt;&gt;&gt;” ） 。<br>返回统计数量 res 。</li>
</ol>
</li>
</ol>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(log n) ： 此算法循环内部仅有 移位、与、加 等基本运算，占用 O(1) ；逐位判断需循环 log n 次，其中 log n 代表数字 n 最高位 1 的所在位数（例如 log 4 &#x3D; 2  log 16 &#x3D; 4）。</li>
<li>空间复杂度 O(1) ： 变量 res 使用常数大小额外空间。</li>
</ul>
<h4 id="方法二：巧用-n-amp-n-1-n-amp-n−1"><a href="#方法二：巧用-n-amp-n-1-n-amp-n−1" class="headerlink" title="方法二：巧用 n &amp; (n - 1)n&amp;(n−1)"></a>方法二：巧用 n &amp; (n - 1)<em>n</em>&amp;(<em>n</em>−1)</h4><ul>
<li>(n−1) 解析： 二进制数字 n 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。</li>
<li>n &amp; (n - 1) 解析： 二进制数字 n 最右边的 1 变成 0 ，其余不变。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/f23d9ef4fcfd65d7fbe29e477cbf36110b2f34558020e8cff09a1e13c0275c43-Picture1.png" alt="Picture1.png"></p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>初始化数量统计变量 resres 。</li>
<li>循环消去最右边的 1 ：当 n &#x3D; 0 时跳出。<ol>
<li>res +&#x3D; 1 ： 统计变量加 1 ；</li>
<li>n &amp;&#x3D; n - 1 ： 消去数字 n 最右边的 1 。</li>
</ol>
</li>
<li>返回统计数量 res 。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/d16a9a6cfdba918c655679373632afc8ddeaf9b64912aa1fbf7b57371736ccaa-Picture11.png" alt="img"></p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(M) ： n &amp; (n - 1) 操作仅有减法和与运算，占用 O(1) ；设 M 为二进制数字 n 中 1 的个数，则需循环 M 次（每轮消去一个 1 ），占用 O(M) 。</li>
<li>空间复杂度 O(1) ： 变量 res 使用常数大小额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        n &amp;= n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、剑指-Offer-65-不用加减乘除做加法"><a href="#2、剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="2、剑指 Offer 65. 不用加减乘除做加法"></a>2、剑指 Offer 65. 不用加减乘除做加法</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“&#x2F;” 四则运算符号。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: a = 1, b = 1</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>a</code>, <code>b</code> 均可能是负数或 0</li>
<li>结果不会溢出 32 位整数</li>
</ul>
<p>Related Topics</p>
<p>位运算</p>
<p>数学</p>
<p>👍 366</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：<br>本题考察对位运算的灵活使用，即使用位运算实现加法。<br>设两数字的二进制形式 a, b ，其求和 s &#x3D; a + b ，a(i) 代表 a 的二进制第 i 位，则分为以下四种情况：</p>
<table>
<thead>
<tr>
<th>a(i)</th>
<th>b(i)</th>
<th>无进位和 n(i)</th>
<th>进位 c(i+1)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>观察发现，<strong>无进位和</strong> 与 <strong>异或运算</strong> 规律相同，<strong>进位</strong> 和 <strong>与运算</strong> 规律相同（并需左移一位）。因此，无进位和 n 与进位 c 的计算公式如下；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221214145340991.png" alt="image-20221214145340991"></p>
<p>循环求 n 和 c ，直至进位 c &#x3D; 0 ；此时 s &#x3D; n ，返回 n 即可。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/9716b1a1ead21824b8216c7d54910bee4d838c011581f4e3d82a14f71cb392a1-Picture1.png" alt="Picture1.png"></p>
<blockquote>
<p>Q ： 若数字 a 和 b 中有负数，则变成了减法，如何处理？<br>A ： 在计算机系统中，数值一律用 <strong>补码</strong> 来表示和存储。<strong>补码的优势</strong>： 加法、减法可以统一处理（CPU只有加法器）。因此，以上方法 <strong>同时适用于正数和负数的加法</strong> 。</p>
</blockquote>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(1) ： 最差情况下（例如 a &#x3D; 0x7fffffff , b &#x3D; 1 时），需循环 32 次，使用 O(1) 时间；每轮中的常数次位操作使用 O(1) 时间。</li>
<li>空间复杂度 O(1) ： 使用常数大小的额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>) &#123; <span class="comment">// 当进位为 0 时跳出</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (a &amp; b) &lt;&lt; <span class="number">1</span>;  <span class="comment">// c = 进位</span></span><br><span class="line">            a ^= b; <span class="comment">// a = 非进位和</span></span><br><span class="line">            b = c; <span class="comment">// b = 进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3、剑指-Offer-56-I-数组中数字出现的次数"><a href="#3、剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="3、剑指 Offer 56 - I. 数组中数字出现的次数"></a>3、剑指 Offer 56 - I. 数组中数字出现的次数</h3><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 10000</code></li>
</ul>
<p>Related Topics</p>
<p>位运算</p>
<p>数组</p>
<p>👍 737</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>题目要求时间复杂度 O(N) ，空间复杂度 O(1) ，因此首先排除 <code>暴力法</code> 和 <code>哈希表统计法</code> 。</p>
<blockquote>
<p><strong>简化问题</strong>： 一个整型数组 nums 里除 一个 数字之外，其他数字都出现了两次。</p>
</blockquote>
<p>设整型数组 nums 中出现一次的数字为 x ，出现两次的数字为 a, a, b, b, …，即：</p>
<p>​								nums &#x3D; [a, a, b, b, …, x]</p>
<p>异或运算有个重要的性质，两个相同数字异或为 0 ，即对于任意整数 a 有 a ⊕ a &#x3D; 0 。因此，若将 nums 中所有数字执行异或运算，留下的结果则为 出现一次的数字 x ，即：</p>
<pre><code>                          a ⊕ a ⊕ b ⊕ b ⊕ ... ⊕ x
                       = 0 ⊕ 0 ⊕ ... ⊕ x
                       = x
</code></pre>
<p>异或运算满足交换律 a <em>⊕</em> b*&#x3D;*b <em>⊕</em> a ，即以上运算结果与 nums 的元素顺序无关。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] singleNumber(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums)  <span class="comment">// 1. 遍历 nums 执行异或运算</span></span><br><span class="line">        x ^= num;</span><br><span class="line">    <span class="keyword">return</span> x;            <span class="comment">// 2. 返回出现一次的数字 x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设 nums &#x3D; [3, 3, 4, 4, 1] ，以上计算流程如下图所示。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1611393960-EnUIaQ-Picture1.png" alt="Picture1.png"></p>
<blockquote>
<p><strong>本题难点：</strong> 数组 nums 有 <strong>两个</strong> 只出现一次的数字，因此无法通过异或直接得到这两个数字。</p>
</blockquote>
<p>设两个只出现一次的数字为 x , y ，由于 x !&#x3D; y ，则 x 和 y 二进制至少有一位不同（即分别为 0 和 1 ），根据此位可以将 nums 拆分为分别包含 x 和 y 的两个子数组。</p>
<p>易知两子数组都满足 「除一个数字之外，其他数字都出现了两次」。因此，仿照以上简化问题的思路，分别对两子数组遍历执行异或操作，即可得到两个只出现一次的数字 x, y 。</p>
<p><strong>算法流程</strong>：</p>
<ol>
<li><p>遍历 nums 执行异或：</p>
<ul>
<li>设整型数组 nums &#x3D; [a, a, b, b, …, x, y]nums&#x3D;[a,a,b,b,…,x,y] ，对 numsnums 中所有数字执行异或，得到的结果为 x ⊕ y ，即：</li>
</ul>
<p>​		a ⊕ a ⊕ b ⊕ b ⊕ … ⊕ x ⊕ y</p>
<p>​		&#x3D; 0 ⊕ 0 ⊕ … ⊕ x ⊕ y</p>
<p>​		&#x3D; x ⊕ y</p>
</li>
<li><p>循环左移计算 m ：<br>根据异或运算定义，若整数 x ⊕ y 某二进制位为 1 ，则 x 和 y 的此二进制位一定不同。换言之，找到 x ⊕ y 某为 1 的二进制位，即可将数组 nums 拆分为上述的两个子数组。根据与运算特点，可知对于任意整数 a 有：</p>
<ul>
<li>若 a &amp; 0001 !&#x3D; 0 ，则 a 的第一位为 1 ；</li>
<li>若 a &amp; 0010 !&#x3D; 0 ，则 a 的第二位为 1 ；</li>
<li>以此类推……</li>
</ul>
</li>
</ol>
<ul>
<li>因此，初始化一个辅助变量 m &#x3D; 1 ，通过与运算从右向左循环判断，可 获取整数 x ⊕ y 首位 1 ，记录于 m 中，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(z &amp; m == <span class="number">0</span>) <span class="comment">// m 循环左移一位，直到 z &amp; m ！= 0</span></span><br><span class="line">    m &lt;&lt;== <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>拆分 nums 为两个子数组：</p>
</li>
<li><p>分别遍历两个子数组执行异或：</p>
</li>
</ol>
<ul>
<li>通过遍历判断 nums 中各数字和 m 做与运算的结果，可将数组拆分为两个子数组，并分别对两个子数组遍历求异或，则可得到两个只出现一次的数字，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> num: nums) &#123;</span><br><span class="line">    <span class="keyword">if</span>((num &amp; m) != <span class="number">0</span>) x ^= num;  <span class="comment">// 若 num &amp; m != 0 , 划分至子数组 1 ，执行遍历异或</span></span><br><span class="line">    <span class="keyword">else</span> y ^= num;                <span class="comment">// 若 num &amp; m == 0 , 划分至子数组 2 ，执行遍历异或</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;x, y&#125;;          <span class="comment">// 遍历异或完毕，返回只出现一次的数字 x 和 y</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>返回值：</li>
</ol>
<ul>
<li>返回只出现一次的数字 x, y 即可</li>
</ul>
<blockquote>
<p>设 nums &#x3D; [3, 3, 4, 4, 1, 6] ，以上计算流程如下图所示。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1614836837-oygHyk-Picture2.png" alt="Picture2.png"></p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N) ： 线性遍历 nums 使用 O(N) 时间，遍历 x ⊕ y 二进制位使用 O(32) &#x3D; O(1) 时间。</li>
<li>空间复杂度 O(1) ： 辅助变量 a , b , x , y 使用常数大小额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] singleNumbers(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>, n = <span class="number">0</span>, m = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)               <span class="comment">// 1. 遍历异或</span></span><br><span class="line">            n ^= num;</span><br><span class="line">        <span class="keyword">while</span>((n &amp; m) == <span class="number">0</span>)               <span class="comment">// 2. 循环左移，计算 m</span></span><br><span class="line">            m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: nums) &#123;              <span class="comment">// 3. 遍历 nums 分组</span></span><br><span class="line">            <span class="keyword">if</span>((num &amp; m) != <span class="number">0</span>) x ^= num;  <span class="comment">// 4. 当 num &amp; m != 0</span></span><br><span class="line">            <span class="keyword">else</span> y ^= num;                <span class="comment">// 4. 当 num &amp; m == 0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;x, y&#125;;          <span class="comment">// 5. 返回出现一次的数字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#4、剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="4、剑指 Offer 56 - II. 数组中数字出现的次数 II"></a>4、剑指 Offer 56 - II. 数组中数字出现的次数 II</h3><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,4,3,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10000</code></li>
<li><code>1 &lt;= nums[i] &lt; 2^31</code></li>
</ul>
<p>Related Topics</p>
<p>位运算</p>
<p>数组</p>
<p>👍 401</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>如下图所示，考虑数字的二进制形式，对于出现三次的数字，各 二进制位 出现的次数都是 3 的倍数。<br>因此，统计所有数字的各二进制位中 1 的出现次数，并对 3 求余，结果则为只出现一次的数字。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1603022900-quEtJr-Picture1.png" alt="Picture1.png"></p>
<h4 id="方法一：有限状态自动机"><a href="#方法一：有限状态自动机" class="headerlink" title="方法一：有限状态自动机"></a>方法一：有限状态自动机</h4><p>各二进制位的 <code>位运算规则相同</code> ，因此只需考虑一位即可。如下图所示，对于所有数字中的某二进制位 1 的个数，存在 3 种状态，即对 3 余数为 0, 1, 2 。</p>
<p>若输入二进制位 1 ，则状态按照以下顺序转换；<br>若输入二进制位 0 ，则状态不变。</p>
<p>​								    0 → 1 → 2 → 0 → ⋯</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1603022900-GNKGMP-Picture2.png" alt="Picture2.png"></p>
<p>如下图所示，由于二进制只能表示 0, 1 ，因此需要使用两个二进制位来表示 3 个状态。设此两位分别为 two , one ，则状态转换变为：</p>
<p>​								00 → 01 → 10 → 00 → ⋯</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1603022900-nPXQLk-Picture3.png" alt="Picture3.png"></p>
<p>接下来，需要通过 <code>状态转换表</code> 导出 <code>状态转换的计算公式</code> 。首先回忆一下位运算特点，对于任意二进制位 x ，有：</p>
<ul>
<li>异或运算：x ^ 0 &#x3D; x ， x ^ 1 &#x3D; ~x</li>
<li>与运算：x &amp; 0 &#x3D; 0 ， x &amp; 1 &#x3D; x</li>
</ul>
<p>计算 oneone 方法：</p>
<p>设当前状态为 two one ，此时输入二进制位 n 。如下图所示，通过对状态表的情况拆分，可推出 one 的计算方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> two == <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span></span><br><span class="line">    one = one</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span></span><br><span class="line">    one = !one</span><br><span class="line"><span class="keyword">if</span> two == <span class="number">1</span></span><br><span class="line">    one = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>引入 <strong>异或运算</strong> ，可将以上拆分简化为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> two == <span class="number">0</span>:</span><br><span class="line">    one = one ^ n</span><br><span class="line"><span class="keyword">if</span> two == <span class="number">1</span>:</span><br><span class="line">    one = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>引入 <strong>与运算</strong> ，可继续简化为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one = one ^ n &amp; ~two</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1603022900-qIFpAR-Picture4.png" alt="Picture4.png"></p>
<p>计算 two 方法：</p>
<p>由于是先计算 one ，因此应在新 one 的基础上计算 two。<br>如下图所示，修改为新 one 后，得到了新的状态图。观察发现，可以使用同样的方法计算 two ，即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">two = two ^ n &amp; ~one</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1603022900-hnUxBz-Picture5.png" alt="Picture5.png"></p>
<p><strong>返回值</strong>：</p>
<p>以上是对数字的二进制中 “一位” 的分析，而 int 类型的其他 31 位具有相同的运算规则，因此可将以上公式直接套用在 32 位数上。</p>
<p>遍历完所有数字后，各二进制位都处于状态 00 和状态 01 （取决于 “只出现一次的数字” 的各二进制位是 1 还是 0 ），而此两状态是由 one 来记录的（此两状态下 twos 恒为 0 ），因此返回 ones 即可。</p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N) ： 其中 N 位数组 nums 的长度；遍历数组占用 O(N) ，每轮中的常数个位运算操作占用 O(32×3×2)&#x3D;O(1) 。</li>
<li>空间复杂度 O(1) ： 变量 ones , twos 使用常数大小的额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ones</span> <span class="operator">=</span> <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            ones = ones ^ num &amp; ~twos;</span><br><span class="line">            twos = twos ^ num &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：遍历统计"><a href="#方法二：遍历统计" class="headerlink" title="方法二：遍历统计"></a>方法二：遍历统计</h4><blockquote>
<p>此方法相对容易理解，但效率较低，总体推荐方法一。</p>
</blockquote>
<p>使用 与运算 ，可获取二进制数字 num 的最右一位 n1： n1&#x3D;num&amp;i</p>
<p>配合 右移操作 ，可从低位至高位，获取 num 所有位的值（设 int 类型从低至高的位数为第 0 位 至第 31 位，即 n0~n31   num &#x3D; num &gt;&gt; 1</p>
<p>建立一个长度为 32 的数组 counts ，通过以上方法可记录所有数字的各二进制位的 1 的出现次数之和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        counts[i] += num &amp; <span class="number">1</span>; <span class="comment">// 更新第 i 位 1 的个数之和</span></span><br><span class="line">        num &gt;&gt;= <span class="number">1</span>;            <span class="comment">// 第 i 位 --&gt; 第 i + 1 位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 counts 各元素对 3 求余，则结果为 “只出现一次的数字” 的各二进制位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> counts[i] %= <span class="number">3</span>; <span class="comment">// 得到 “只出现一次的数字” 的第 i 位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 <strong>左移操作</strong> 和 <strong>或运算</strong> ，可将 counts 数组中各二进位的值恢复到数字 res 上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    res &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    res |= counts[i] % <span class="number">3</span>; <span class="comment">// 恢复第 i 位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终返回 res 即可</p>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度 O(N) ： 其中 N 位数组 nums 的长度；遍历数组占用 O(N) ，每轮中的常数个位运算操作占用 O(1) 。</li>
<li>空间复杂度 O(1) ： 数组 counts 长度恒为 32 ，占用常数大小的额外空间。</li>
</ul>
<p>实际上，只需要修改求余数值 <em>m</em> ，即可实现解决 <strong>除了一个数字以外，其余数字都出现 m次</strong> 的通用问题。</p>
<blockquote>
<p>设 int 类型从低至高的位数为第 0 位 至第 31 位。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                counts[i] += num &amp; <span class="number">1</span>; <span class="comment">// 更新第 i 位 1 的个数之和</span></span><br><span class="line">                num &gt;&gt;= <span class="number">1</span>;            <span class="comment">// 第 i 位 --&gt; 第 i 位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, m = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            res |= counts[i] % m;     <span class="comment">// 恢复第 i 位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十三、数学"><a href="#十三、数学" class="headerlink" title="十三、数学"></a>十三、数学</h2><h3 id="1、剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#1、剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="1、剑指 Offer 39. 数组中出现次数超过一半的数字"></a>1、剑指 Offer 39. 数组中出现次数超过一半的数字</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= 数组长度 &lt;= 50000</span><br></pre></td></tr></table></figure>



<p>注意：本题与主站 169 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">https://leetcode-cn.com/problems/majority-element/</a></p>
<p>Related Topics</p>
<p>数组</p>
<p>哈希表</p>
<p>分治</p>
<p>计数</p>
<p>排序</p>
<p>👍 335</p>
<p>👎 0</p>
<blockquote>
<p>本文将 “数组中出现次数超过一半的数字” 简称为 <strong>“众数”</strong> 。<br>需要注意的是，数学中众数的定义为 “数组中出现次数最多的数字” ，与本文定义不同。</p>
</blockquote>
<p>本题常见的三种解法：</p>
<ol>
<li><strong>哈希表统计法</strong>： 遍历数组 nums ，用 HashMap 统计各数字的数量，即可找出 众数 。此方法时间和空间复杂度均为 O(N) 。</li>
<li><strong>数组排序法</strong>： 将数组 nums 排序，<code>数组中点的元素</code> 一定为众数。按照排序算法的时间复杂度和空间复杂度来计算，库函数为快速排序，时间复杂度为 O(NlogN), 空间复杂度 O(N);</li>
<li><strong>摩尔投票法</strong>： 核心理念为 <code>票数正负抵消</code> 。此方法时间和空间复杂度分别为 O(N) 和 O(1) ，为本题的最佳解法。</li>
</ol>
<h4 id="摩尔投票法："><a href="#摩尔投票法：" class="headerlink" title="摩尔投票法："></a>摩尔投票法：</h4><blockquote>
<p>设输入数组 <code>nums</code> 的众数为 x ，数组长度为 n 。</p>
</blockquote>
<p>推论一： 若记 <code>众数</code> 的票数为 +1 ，<code>非众数</code> 的票数为 −1 ，则一定有所有数字的 <code>票数和</code> &gt; 0 。</p>
<p>推论二： 若数组的前 a 个数字的 票数和 &#x3D; 0 ，则 数组剩余 (n-a) 个数字的 票数和一定仍 &gt;0 ，即后 (n-a) 个数字的 众数仍为 x 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1603612327-bOQxzq-Picture1.png" alt="Picture1.png"></p>
<p>根据以上推论，记数组首个元素为 n1 ，众数为 x ，遍历并统计票数。当发生 <code>票数和 = 0</code> 时，<strong>剩余数组的众数一定不变</strong> ，这是由于：</p>
<ul>
<li>当 n1 &#x3D;&#x3D; x ： 抵消的所有数字，有一半是众数 x 。</li>
<li>当 n1 !&#x3D; x ： 抵消的所有数字，众数 x 的数量最少为 0 个，最多为一半。</li>
</ul>
<p>利用此特性，每轮假设发生 <strong>票数和 &#x3D; 0</strong> 都可以 <strong>缩小剩余数组区间</strong> 。当遍历完成时，最后一轮假设的数字即为众数。</p>
<p><strong>算法流程</strong>:</p>
<ol>
<li>初始化： 票数统计 votes &#x3D; 0 ， 众数 x；</li>
<li>循环： 遍历数组 nums 中的每个数字 num ；<ul>
<li>当 票数 votes 等于 0 ，则假设当前数字 num 是众数；</li>
<li>当 num &#x3D; x 时，票数 votes 自增 1 ；当 num !&#x3D; x 时，票数 votes 自减 1 ；</li>
</ul>
</li>
<li>返回值： 返回 x 即可；</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1603612327-WvtbDg-Picture7.png" alt="img"></p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N) ： N 为数组 <code>nums</code> 长度。</li>
<li>空间复杂度 O(1) ： <code>votes</code> 变量使用常数大小的额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 摩尔投票</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, vote = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vote == <span class="number">0</span>) x = num;</span><br><span class="line">        <span class="keyword">if</span> (num == x) vote++;</span><br><span class="line">        <span class="keyword">else</span> vote--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>拓展</strong>： 由于题目说明 <code>给定的数组总是存在多数元素</code> ，因此本题不用考虑 <code>数组不存在众数</code> 的情况。若考虑，需要加入一个 “验证环节” ，遍历数组 nums 统计 x 的数量。</p>
<ul>
<li>若 x 的数量超过数组长度一半，则返回 x ；</li>
<li>否则，返回未找到众数；</li>
</ul>
<p>时间和空间复杂度不变，仍为 O(N) 和 O(1) 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, votes = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(votes == <span class="number">0</span>) x = num;</span><br><span class="line">        votes += num == x ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 验证 x 是否为众数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums)</span><br><span class="line">        <span class="keyword">if</span>(num == x) count++;</span><br><span class="line">    <span class="keyword">return</span> count &gt; nums.length / <span class="number">2</span> ? x : <span class="number">0</span>; <span class="comment">// 当无众数时返回 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="排序法："><a href="#排序法：" class="headerlink" title="排序法："></a>排序法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、剑指-Offer-66-构建乘积数组"><a href="#2、剑指-Offer-66-构建乘积数组" class="headerlink" title="2、剑指 Offer 66. 构建乘积数组"></a>2、剑指 Offer 66. 构建乘积数组</h3><p>给定一个数组 <code>A[0,1,…,n-1]</code>，请构建一个数组 <code>B[0,1,…,n-1]</code>，其中 <code>B[i]</code> 的值是数组 <code>A</code> 中除了下标 <code>i</code> 以外的元素的积, 即 <code>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</code>。不能使用除法。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>所有元素乘积之和不会溢出 32 位整数</li>
<li><code>a.length &lt;= 100000</code></li>
</ul>
<p>Related Topics</p>
<p>数组</p>
<p>前缀和</p>
<p>👍 279</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>本题的难点在于 <code>不能使用除法</code> ，即需要 <code>只用乘法</code> 生成数组 B 。根据题目对 B[i] 的定义，可列表格，如下图所示。</p>
<p>根据表格的主对角线（全为 1 ），可将表格分为 <code>上三角</code> 和 <code>下三角</code> 两部分。分别迭代计算下三角和上三角两部分的乘积，即可 <code>不使用除法</code> 就获得结果。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1624619180-vpyyqh-Picture1.png" alt="Picture1.png"></p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>初始化：数组 B ，其中 B[0] &#x3D; 1 ；辅助变量 tmp &#x3D; 1 ；</li>
<li>计算 B[i] 的 <code>下三角</code> 各元素的乘积，直接乘入 B[i] ；</li>
<li>计算 B[i] 的 <code>上三角</code> 各元素的乘积，记为 tmp ，并乘入 B[i] ；</li>
<li>返回 B 。</li>
</ol>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(N) ： 其中 N 为数组长度，两轮遍历数组 a ，使用 O(N) 时间。</li>
<li>空间复杂度 O(1) ： 变量 tmp 使用常数大小额外空间（数组 b 作为返回值，不计入复杂度考虑）。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599920669-atltNE-Picture4.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599920669-ufmhnT-Picture8.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] constructArr(<span class="type">int</span>[] a) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123; <span class="comment">// 左下角</span></span><br><span class="line">        b[i] = b[i - <span class="number">1</span>] * a[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 右上角</span></span><br><span class="line">        temp *= a[i + <span class="number">1</span>];</span><br><span class="line">        b[i] *= temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、剑指-Offer-14-I-剪绳子"><a href="#3、剑指-Offer-14-I-剪绳子" class="headerlink" title="3、剑指 Offer 14- I. 剪绳子"></a>3、剑指 Offer 14- I. 剪绳子</h3><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m-1]</code> 。请问 <code>k[0]*k[1]*...*k[m-1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 58</code></li>
</ul>
<p>注意：本题与主站 343 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/integer-break/">https://leetcode-cn.com/problems/integer-break/</a></p>
<p>Related Topics</p>
<p>数学</p>
<p>动态规划</p>
<p>👍 529</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<h4 id="数学法"><a href="#数学法" class="headerlink" title="数学法"></a>数学法</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221220093051857.png" alt="image-20221220093051857"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221220093350891.png" alt="image-20221220093350891"></p>
<p><strong>切分规则</strong>：<br>最优： 3 。把绳子尽可能切为多个长度为 3 的片段，留下的最后一段绳子的长度可能为 0,1,2 三种情况。<br>次优： 2 。若最后一段绳子长度为 2 ；则保留，不再拆为 1+1 。<br>最差： 1 。若最后一段绳子长度为 1 ；则应把一份 3 + 1 替换为 2 + 2，因为 2×2 &gt; 3×1。</p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>当 n ≤ 3 时，按照规则应不切分，但由于题目要求必须剪成 m &gt; 1 段，因此必须剪出一段长度为 1 的绳子，即返回 n - 1 。</li>
<li>当 n &gt; 3 时，求 n 除以 3 的 整数部分 a 和 余数部分 b （即 n &#x3D; 3a + b ），并分为以下三种情况：<ul>
<li>当 b &#x3D; 0 时，直接返回 3 ^ a；</li>
<li>当 b &#x3D; 1 时，要将一个 1 + 3 转换为 2 + 2，因此返回 3^(a−1) × 4；</li>
<li>当 b &#x3D; 2b&#x3D;2 时，返回 3^a × 2。</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1f9adeaa7b9fff0ab19c9d29e3a8f98749011d22dc162d67bdbe223f1a38119f-Picture1.png" alt="Picture1.png"></p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li><p>时间复杂度 O(1) ： 仅有求整、求余、次方运算。</p>
<ul>
<li>求整和求余运算：资料提到不超过机器数的整数可以看作是 O(1) ；</li>
<li>幂运算：查阅资料，提到浮点取幂为 O(1) 。</li>
</ul>
</li>
<li><p>空间复杂度 O(1) ： 变量 a 和 b 使用常数大小额外空间。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> n / <span class="number">3</span>, b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>, a);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>, a) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221220095148305.png" alt="image-20221220095148305"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221220095204014.png" alt="image-20221220095204014"></p>
<h4 id="动态规划-4"><a href="#动态规划-4" class="headerlink" title="动态规划"></a>动态规划</h4><p><strong>思路</strong></p>
<p>对于的长度为n的绳子，当 n ≥ 2 时，可以剪成至少两个绳子。令 k 是剪出的第一段绳子，则剩下的部分是 n−k，n−k 可以不继续剪，或者继续剪成至少两段绳子（一个问题可以分解为相似的子问题因此想到动态规划）。由于每个绳子长度对应的最大乘积取决于比它小的绳子对应的最大乘积，因此可以使用<code>动态规划</code>求解。</p>
<ol>
<li>确定dp数组以及下标的含义<br>dp[i] 表示将长度为 i 的绳子剪成至少两段绳子之后，这些绳子长度的最大乘积</li>
<li>确定状态转移方程<ul>
<li>当 i ≥ 2 时，假设对长度为 i 绳子剪出的第一段绳子长度是 j（1≤j&lt;i），则有以下两种方案：<ul>
<li>将 i 剪成 j 和 i-j 长度的绳子，且 i−j 不再继续剪，此时的乘积是 j×(i−j) ；</li>
<li>将 i 剪成 j 和 i−j 长度的绳子，且 i−j 继续剪成多段长度的绳子，此时的乘积是 j×dp[i−j] 。</li>
<li>因此，当 j 固定时，有 dp[i]&#x3D;max(j×(i−j),j×dp[i−j])。由于 j 的取值范围是 1 到 i ，需要遍历所有的 j 得到dp[i]的</li>
</ul>
</li>
</ul>
</li>
<li>初始化状态<br>0 不是正整数，1 是最小的正整数，0 和 1 都不能拆分，因此 dp[0]&#x3D;dp[1]&#x3D;0。</li>
<li>遍历顺序<br>由状态转移方程知道dp[i] 是从 j×(i−j)和j×dp[i−j] 且j 的取值范围是 1 到 i−1 ，需要遍历所有的 j 得到dp[i]所以从前往后遍历。</li>
<li>返回值<br>最终得到dp[n]的值即为将长度为n的绳子拆分成至少两段绳子之后，这些绳子长度的最大乘积。</li>
</ol>
<p>再优化一下：遍历j的时候只需要遍历至绳子长度的一半即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 长度为 i 的绳子剪成至少两段绳子之后，这些绳子长度的最大乘积</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[i - j] * j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n ^ 2)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h3 id="4、剑指-Offer-14-II-剪绳子-II"><a href="#4、剑指-Offer-14-II-剪绳子-II" class="headerlink" title="4、剑指 Offer 14- II. 剪绳子 II"></a>4、剑指 Offer 14- II. 剪绳子 II</h3><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m - 1]</code> 。请问 <code>k[0]*k[1]*...*k[m - 1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 1000</code></li>
</ul>
<p>注意：本题与主站 343 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/integer-break/">https://leetcode-cn.com/problems/integer-break/</a></p>
<p>Related Topics</p>
<p>数学</p>
<p>动态规划</p>
<p>👍 221</p>
<p>👎 0</p>
<h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h4><p><strong>切分规则</strong>：</p>
<ol>
<li>最优： 3 。把绳子尽可能切为多个长度为 3 的片段，留下的最后一段绳子的长度可能为 0,1,2 三种情况。</li>
<li>次优： 2 。若最后一段绳子长度为 2 ；则保留，不再拆为 1+1 。</li>
<li>最差： 1 。若最后一段绳子长度为 1 ；则应把一份 3 + 1 替换为 2 + 2，因为 2×2 &gt; 3×1。</li>
</ol>
<p><strong>算法流程</strong>：</p>
<ol>
<li>当 n ≤ 3 时，按照规则应不切分，但由于题目要求必须剪成 m &gt; 1 段，因此必须剪出一段长度为 1 的绳子，即返回 n - 1 。</li>
<li>当 n &gt; 3 时，求 n 除以 3 的 整数部分 a 和 余数部分 b （即 n &#x3D; 3a + b ），并分为以下三种情况（设求余操作符号为 “⊙” ）：<ul>
<li>当 b &#x3D; 0 时，直接返回 3 ^ a ⊙ 1000000007；</li>
<li>当 b &#x3D; 1 时，要将一个 1 + 3 转换为 2 + 2，因此返回 3^(a−1) × 4 ⊙ 1000000007；</li>
<li>当 b &#x3D; 2b&#x3D;2 时，返回 3^a × 2 ⊙ 1000000007。</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1f9adeaa7b9fff0ab19c9d29e3a8f98749011d22dc162d67bdbe223f1a38119f-Picture1-16715070085052.png" alt="Picture1.png"></p>
<p><strong>大数求余解法</strong>：</p>
<p><strong>大数越界</strong>： 当 a 增大时，最后返回的 3^a 大小以指数级别增长，可能超出 int32 甚至 int64 的取值范围，导致返回值错误。</p>
<p><strong>大数求余问题</strong>： 在仅使用 int32 类型存储的前提下，正确计算 x^a 对 p 求余（即 x^a ⊙p ）的值。</p>
<p><strong>解决方案</strong>： 循环求余 、 快速幂求余 ，其中后者的时间复杂度更低，两种方法均基于以下求余运算规则推出：<br>(xy)⊙p&#x3D;[(x⊙p)(y⊙p)]⊙p</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221220113438247.png" alt="image-20221220113438247"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221220113610097.png" alt="image-20221220113610097"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221220113729433.png" alt="image-20221220113729433"></p>
<p><strong>复杂度分析</strong>：</p>
<blockquote>
<p>以下为 二分求余法 的复杂度。</p>
</blockquote>
<ul>
<li>时间复杂度 O(logN) ： 其中 N&#x3D;a ，二分法为对数级别复杂度，每轮仅有求整、求余、次方运算。</li>
<li>空间复杂度 O(1) ： 变量 a, b, p, x, rem 使用常数大小额外空间。</li>
</ul>
<p>Java&#x2F;C++ 代码： 根据二分法计算原理，至少要保证变量 x 和 rem 可以正确存储 1000000007^2，而 2^64 &gt; 1000000007^2 &gt; 2^32，因此我们选取 long 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> n % <span class="number">3</span>, p = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">rem</span> <span class="operator">=</span> <span class="number">1</span>, x = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> n / <span class="number">3</span> - <span class="number">1</span>; a &gt; <span class="number">0</span>; a /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a % <span class="number">2</span> == <span class="number">1</span>) rem = (rem * x) % p;</span><br><span class="line">            x = (x * x) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="type">int</span>)(rem * <span class="number">3</span> % p);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="type">int</span>)(rem * <span class="number">4</span> % p);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(rem * <span class="number">6</span> % p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态规划-5"><a href="#动态规划-5" class="headerlink" title="动态规划"></a>动态规划</h4><p>用BigInteger</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        BigInteger[] dp = <span class="keyword">new</span> <span class="title class_">BigInteger</span>[n + <span class="number">1</span>];</span><br><span class="line">         Arrays.fill(dp, BigInteger.valueOf(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// dp[1] = BigInteger.valueOf(1);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                dp[i] = dp[i].max(BigInteger.valueOf(j * (i - j))).max(dp[i - j].multiply(BigInteger.valueOf(j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n].mod(BigInteger.valueOf(<span class="number">1000000007</span>)).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、剑指-Offer-57-II-和为-s-的连续正数序列"><a href="#5、剑指-Offer-57-II-和为-s-的连续正数序列" class="headerlink" title="5、剑指 Offer 57 - II. 和为 s 的连续正数序列"></a>5、剑指 Offer 57 - II. 和为 s 的连续正数序列</h3><p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= target &lt;= 10^5</code></li>
</ul>
<p>Related Topics</p>
<p>数学</p>
<p>双指针</p>
<p>枚举</p>
<p>👍 495</p>
<p>👎 0</p>
<h4 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h4><p><strong>解题思路</strong>：</p>
<p>利用双指针维护一个区间来计算和值，根据 和值 与 target 的大小，来增缩区间。当 和值 和 target 相等时，把数组加入到结果集。 </p>
<p>算法流程：</p>
<ol>
<li><p>当 target &lt;&#x3D; 2 时，不满足题意，直接返回。</p>
</li>
<li><p>slow 表示左边界， faster 表示有区间, sum 维护区间的和值。当 slow &lt; faster 并且  faster &lt;&#x3D; target &#x2F; 2 + 1开始搜索。</p>
</li>
<li><p>sum &lt; target 扩右区间, faster++, sum +&#x3D; faster;</p>
</li>
<li><p>sum &gt; target 缩左区间, sum -&#x3D; slow,slow++；</p>
</li>
<li><p>记录数组</p>
</li>
<li><p>返回res。</p>
</li>
</ol>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度O(N)</li>
<li>空间复杂度O(N)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] findContinuousSequence(<span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[][] &#123;&#125;;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 左边界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">faster</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">// 右边界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">3</span>;  <span class="comment">// 维护的区间的和</span></span><br><span class="line">    <span class="keyword">while</span> (faster &lt;= target / <span class="number">2</span> + <span class="number">1</span> &amp;&amp; slow &lt; faster) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target) &#123; <span class="comment">// 扩右区间</span></span><br><span class="line">            sum += ++faster;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123; <span class="comment">// 缩左区间</span></span><br><span class="line">            sum -= slow++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 加入数组</span></span><br><span class="line">            <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[faster - slow + <span class="number">1</span>];</span><br><span class="line">            temp[<span class="number">0</span>] = slow;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">                temp[i] = temp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">            sum -= slow++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数学-1"><a href="#数学-1" class="headerlink" title="数学"></a>数学</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221222112119650.png" alt="image-20221222112119650"></p>
<blockquote>
<p>当 target &#x3D; 9 时，以上求解流程如下图所示：</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1611494538-VUzxtS-Picture1.png" alt="Picture1.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221222112427812.png" alt="image-20221222112427812"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] findContinuousSequence(<span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2.0</span>;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            j = (-<span class="number">1</span> + Math.sqrt(<span class="number">1</span> + <span class="number">4</span> * (<span class="number">2</span> * target + (<span class="type">long</span>) i * i - i))) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(j == (<span class="type">int</span>)j) &#123;</span><br><span class="line">                <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[(<span class="type">int</span>)j - i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i; k &lt;= (<span class="type">int</span>)j; k++)</span><br><span class="line">                    ans[k - i] = k;</span><br><span class="line">                res.add(ans);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、剑指-Offer-62-圆圈中最后剩下的数字"><a href="#6、剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="6、剑指 Offer 62. 圆圈中最后剩下的数字"></a>6、剑指 Offer 62. 圆圈中最后剩下的数字</h3><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 5, m = 3</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 10, m = 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>1 &lt;= m &lt;= 10^6</code></li>
</ul>
<p>Related Topics</p>
<p>递归</p>
<p>数学</p>
<p>👍 716</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>模拟整个删除过程最直观，即构建一个长度为 n 的链表，各节点值为对应的顺序索引；每轮删除第 m 个节点，直至链表长度为 1 时结束，返回最后剩余节点的值即可。</p>
<p>模拟法需要循环删除 n - 1 轮，每轮在链表中寻找删除节点需要 m 次访问操作（链表线性遍历），因此总体时间复杂度为 O(nm) 。题目给定的 m, n 取值范围如下所示，观察可知此时间复杂度是不可接受的。<br>                                1≤n≤10 ^5</p>
<p>​								1≤m≤10 ^6</p>
<blockquote>
<p>实际上，本题是著名的 “约瑟夫环” 问题，可使用 <strong>动态规划</strong> 解决。</p>
</blockquote>
<p>输入 n, m ，记此约瑟夫环问题为 「n, m 问题」 ，设解（即最后留下的数字）为 f(n) ，则有：</p>
<ul>
<li>「n, m 问题」：数字环为 0, 1, 2, …, n - 1 ，解为 f(n)；</li>
<li>「n-1, m 问题」：数字环为 0, 1, 2, …, n - 2 ，解为 f(n-1) ；<br>以此类推……</li>
</ul>
<p>请注意，数字环是 <strong>首尾相接</strong> 的，为方便行文，本文使用列表形式表示。</p>
<p>对于「n, m 问题」，首轮删除环中第 m 个数字后，得到一个长度为 n - 1 的数字环。由于有可能 m &gt; n ，因此删除的数字为 (m - 1) % n ，删除后的数字环从下个数字（即 m % n）开始，设 t &#x3D; m % n ，可得数字环：</p>
<p>t, t + 1, t + 2, …, 0, 1, …, t - 3, t - 2</p>
<p>删除一轮后的数字环也变为一个「n-1, m 问题」，观察以下数字编号对应关系：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221222113836052.png" alt="image-20221222113836052"></p>
<p>设「n-1, m 问题」某数字为 x ，则可得递推关系：<br>                                x→(x+t)%n</p>
<p>换而言之，若已知「n-1, m 问题」的解 f(n - 1) ，则可通过以上公式计算得到「n, m 问题」的解 f(n) ，即：<br>f(n)&#x3D;(f(n−1)+t)%n<br>    &#x3D;(f(n−1)+m%n)%n<br>    &#x3D;(f(n−1)+m)%n</p>
<blockquote>
<p>以 n &#x3D; 5 , m &#x3D; 3 的示例如下图所示。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1615096532-kUoKUe-Picture1.png" alt="Picture1.png"></p>
<p>f(n) 可由 f(n - 1) 得到，f(n - 1) 可由 f(n - 2) 得到，……，f(2) 可由 f(1) 得到；因此，若给定 f(1) 的值，就可以递推至任意 f(n) 。而「1, m 问题」的解 f(1) &#x3D; 0 恒成立，即无论 m 为何值，长度为 1 的数字环留下的是一定是数字 0 。</p>
<blockquote>
<p>以上数学推导本质是得出动态规划的 转移方程 和 初始状态 。</p>
</blockquote>
<p><strong>动态规划解析</strong>：</p>
<ol>
<li><p>状态定义： 设「i, m 问题」的解为 dp[i] ；</p>
</li>
<li><p>转移方程： 通过以下公式可从 dp[i - 1] 递推得到 dp[i] ；dp[i] &#x3D; (dp[i - 1] + m) % i</p>
</li>
<li><p>初始状态：「1, m 问题」的解恒为 0 ，即 dp[1] &#x3D; 0 ；</p>
</li>
<li><p>返回值： 返回「n, m 问题」的解 dp[n] ；</p>
</li>
</ol>
<blockquote>
<p>如下图所示，为 n &#x3D; 5 , m &#x3D; 3 时的状态转移和对应的模拟删除过程。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1613584667-AQpTlK-Picture2.png" alt="Picture2.png"></p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(n) ： 状态转移循环 n - 1 次使用 O(n) 时间，状态转移方程计算使用 O(1) 时间；</li>
<li>空间复杂度 O(1) ： 使用常数大小的额外空间；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            x = (x + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、剑指-Offer-43-1～n-整数中-1-出现的次数"><a href="#7、剑指-Offer-43-1～n-整数中-1-出现的次数" class="headerlink" title="7、剑指 Offer 43. 1～n 整数中 1 出现的次数"></a>7、剑指 Offer 43. 1～n 整数中 1 出现的次数</h3><p>输入一个整数 <code>n</code> ，求1～n这n个整数的十进制表示中1出现的次数。</p>
<p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt; 2^31</code></li>
</ul>
<p>注意：本题与主站 233 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-digit-one/">https://leetcode-cn.com/problems/number-of-digit-one/</a></p>
<p>Related Topics</p>
<p>递归</p>
<p>数学</p>
<p>动态规划</p>
<p>👍 387</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>将 1 ~ n 的个位、十位、百位、…的 1 出现次数相加，即为 1 出现的总次数。</p>
<p>设数字 n 是 x 位数，记 n 的第 i 位为 ni  ，则可将 n 写为 nx nx-1 …n2 n1 ；</p>
<p>本文名词规定如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221224143843898.png" alt="image-20221224143843898"></p>
<p>某位中 1 出现次数的计算方法：</p>
<p>根据当前位 cur 值的不同，分为以下三种情况：</p>
<ol>
<li>当 cur &#x3D; 0 时： 此位 1 的出现次数只由高位 high 决定，计算公式为：<br>high×digit</li>
</ol>
<blockquote>
<p>如下图所示，以 n &#x3D; 2304 为例，求 digit &#x3D; 10 （即十位）的 1 出现次数。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599887431-cVmcVA-Picture1.png" alt="Picture1.png"></p>
<ol start="2">
<li>当 cur &#x3D; 1 时： 此位 1 的出现次数由高位 high 和低位 low 决定，计算公式为：</li>
</ol>
<p>high<em>×</em>digit*+*low+1</p>
<blockquote>
<p>如下图所示，以 n &#x3D; 2314 为例，求 digit &#x3D; 1 （即十位）的 1 出现次数。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599887431-HAAvVp-Picture2.png" alt="Picture2.png"></p>
<ol start="3">
<li>当 cur &#x3D; 2, 3,…, 9 时： 此位 1 的出现次数只由高位 high 决定，计算公式为：</li>
</ol>
<p>(<em>high</em>+1)×digit</p>
<blockquote>
<p>如下图所示，以 n &#x3D; 2324 为例，求 digit &#x3D; 10 （即十位）的 1 出现次数。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599887431-djUZTe-Picture3.png" alt="Picture3.png"></p>
<p>变量递推公式：<br>设计按照 “个位、十位、…” 的顺序计算，则 high &#x2F; cur &#x2F; low &#x2F; digit 应初始化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> n / <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 个位</span></span><br></pre></td></tr></table></figure>

<p>因此，从个位到最高位的变量递推公式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(high != <span class="number">0</span> || cur != <span class="number">0</span>) &#123; <span class="comment">// 当 high 和 cur 同时为 0 时，说明已经越过最高位，因此跳出</span></span><br><span class="line">    low += cur * digit; <span class="comment">// 将 cur 加入 low ，组成下轮 low</span></span><br><span class="line">    cur = high % <span class="number">10</span>; <span class="comment">// 下轮 cur 是本轮 high 的最低位</span></span><br><span class="line">    high /= <span class="number">10</span>; <span class="comment">// 将本轮 high 最低位删除，得到下轮 high</span></span><br><span class="line">    digit *= <span class="number">10</span>; <span class="comment">// 位因子每轮 × 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(logn) ： 循环内的计算操作使用 O(1) 时间；循环次数为数字 n 的位数，即 logn ，因此循环使用 O(logn) 时间。</li>
<li>空间复杂度 O(1)O(1) ： 几个变量使用常数大小的额外空间。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599886793-BBSKuG-Picture8.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> n / <span class="number">10</span>, cur = n % <span class="number">10</span>, low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(high != <span class="number">0</span> || cur != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="number">0</span>) res += high * digit;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur == <span class="number">1</span>) res += high * digit + low + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> res += (high + <span class="number">1</span>) * digit;</span><br><span class="line">            low += cur * digit;</span><br><span class="line">            cur = high % <span class="number">10</span>;</span><br><span class="line">            high /= <span class="number">10</span>;</span><br><span class="line">            digit *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、剑指-Offer-44-数字序列中某一位的数字"><a href="#8、剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="8、剑指 Offer 44. 数字序列中某一位的数字"></a>8、剑指 Offer 44. 数字序列中某一位的数字</h3><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p>
<p>请写一个函数，求任意第n位对应的数字。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 11</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= n &lt; 2^31</code></li>
</ul>
<p>注意：本题与主站 400 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/nth-digit/">https://leetcode-cn.com/problems/nth-digit/</a></p>
<p>Related Topics</p>
<p>数学</p>
<p>二分查找</p>
<p>👍 301</p>
<p>👎 0</p>
<p><strong>解题思路</strong>：</p>
<p>名词规定如下：</p>
<ol>
<li>将 101112 ⋯ 中的每一位称为 <strong>数位</strong> ，记为 n ；</li>
<li>将 10, 11, 12, ⋯ 称为 <strong>数字</strong> ，记为 num ；</li>
<li>数字 10 是一个两位数，称此数字的 <strong>位数</strong> 为 2 ，记为 digit ；</li>
<li>每 digit 位数的起始数字（即：1, 10, 100, ⋯），记为 start ；</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599888213-CYhLfm-Picture1.png" alt="Picture1.png"></p>
<p>观察上表，可推出各 digit 下的数位数量 count 的计算公式：<br>count&#x3D;9×start×digit</p>
<p>根据以上分析，可将求解分为三步：</p>
<ol>
<li><p>确定 n 所在 <strong>数字</strong> 的 <strong>位数</strong> ，记为 digit ；</p>
</li>
<li><p>确定 n 所在的 <strong>数字</strong> ，记为 num ；</p>
</li>
<li><p>确定 n 是 num 中的哪一数位，并返回结果；</p>
</li>
<li><p>确定所求数位的所在数字的位数</p>
</li>
</ol>
<p>如下图所示，循环执行 n 减去 一位数、两位数、… 的数位数量 count ，直至 n ≤ count 时跳出。</p>
<p>由于 n 已经减去了一位数、两位数、…、(digit-1) 位数的 数位数量 count ，因而此时的 n 是从起始数字 start 开始计数的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="keyword">while</span> (n &gt; count) &#123;</span><br><span class="line">   n -= count;</span><br><span class="line">   start *= <span class="number">10</span>; <span class="comment">// 1, 10, 100, ...</span></span><br><span class="line">   digit += <span class="number">1</span>;  <span class="comment">// 1,  2,  3, ...</span></span><br><span class="line">   count = digit * start * <span class="number">9</span>; <span class="comment">// 9, 180, 2700, ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong> 所求数位 ① 在某个 digit 位数中； ② 为从数字 start 开始的第 <em>n</em> 个数位。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599888496-HivJvS-Picture2.png" alt="Picture2.png"></p>
<ol start="2">
<li>确定所求数位所在的数字</li>
</ol>
<p>如下图所示，所求数位 在从数字 start 开始的第 [(n - 1) &#x2F; digit] 个 数字 中（ start 为第 0 个数字）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> start + (n - <span class="number">1</span>) / digit;</span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong> 所求数位在数字 num 中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599888213-gCcnEA-Picture3.png" alt="Picture3.png"></p>
<ol start="3">
<li>确定所求数位在 num 的哪一数位</li>
</ol>
<p>如下图所示，所求数位为数字 num 的第 (n - 1) % digit 位（ 数字的首个数位为第 0 位）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Long.toString(num); <span class="comment">// 转化为 string</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> s.charAt((n - <span class="number">1</span>) % digit) - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 获得 num 的 第 (n - 1) % digit 个数位，并转化为 int</span></span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong> 所求数位是 res 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599888395-oeWGAH-Picture4.png" alt="Picture4.png"></p>
<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度 O(logn) ： 所求数位 n 对应数字 num 的位数 digit 最大为 O(logn) ；第一步最多循环 O(logn) 次；第三步中将 num 转化为字符串使用 O(logn) 时间；因此总体为 O(logn) 。</li>
<li>空间复杂度 O(logn) ： 将数字 num 转化为字符串 str(num) ，占用 O(logn) 的额外空间。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599888213-wmVktF-Picture5.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599888213-vPFqup-Picture6.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1599888796-IlfLEc-Picture7.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; count) &#123; <span class="comment">// 1.</span></span><br><span class="line">            n -= count;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            digit += <span class="number">1</span>;</span><br><span class="line">            count = digit * start * <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> start + (n - <span class="number">1</span>) / digit; <span class="comment">// 2.</span></span><br><span class="line">        <span class="keyword">return</span> Long.toString(num).charAt((n - <span class="number">1</span>) % digit) - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 3.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9、LC1759-统计同构子字符串的数目"><a href="#9、LC1759-统计同构子字符串的数目" class="headerlink" title="9、LC1759. 统计同构子字符串的数目"></a>9、LC1759. 统计同构子字符串的数目</h3><p>给你一个字符串 <code>s</code> ，返回 <code>s</code> 中 <strong>同构子字符串</strong> 的数目。由于答案可能很大，只需返回对 <code>10^9 + 7</code> <strong>取余</strong> 后的结果。</p>
<p><strong>同构字符串</strong> 的定义为：如果一个字符串中的所有字符都相同，那么该字符串就是同构字符串。</p>
<p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abbcccaa&quot;</span><br><span class="line">输出：13</span><br><span class="line">解释：同构子字符串如下所列：</span><br><span class="line">&quot;a&quot;   出现 3 次。</span><br><span class="line">&quot;aa&quot;  出现 1 次。</span><br><span class="line">&quot;b&quot;   出现 2 次。</span><br><span class="line">&quot;bb&quot;  出现 1 次。</span><br><span class="line">&quot;c&quot;   出现 3 次。</span><br><span class="line">&quot;cc&quot;  出现 2 次。</span><br><span class="line">&quot;ccc&quot; 出现 1 次。</span><br><span class="line">3 + 1 + 2 + 1 + 3 + 2 + 1 = 13</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;xy&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：同构子字符串是 &quot;x&quot; 和 &quot;y&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;zzzzz&quot;</span><br><span class="line">输出：15</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s</code> 由小写字符串组成</li>
</ul>
<p>Related Topics</p>
<p>数学</p>
<p>字符串</p>
<p><strong>解题思路</strong>:</p>
<p>要求的是同构字符的数量，把原字符串进行切割，切割成相等的字符串。”abbcccaa” 切割为 “a” “bb” “ccc” “aa”。对切割后的各部分算同构字符串的贡献，累加。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../images/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221226111209255.png" alt="image-20221226111209255"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countHomogenous</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (tmp == c) len++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += (<span class="type">long</span>) len * (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                len = <span class="number">1</span>;</span><br><span class="line">                tmp = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += (<span class="type">long</span>) len * (len + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 处理最后一个分组</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (ans % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度O(N);</li>
<li>空间复杂度O(1);</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://www.haungrd.top">Huang RD</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.haungrd.top/2022/12/26/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">http://www.haungrd.top/2022/12/26/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.haungrd.top" target="_blank">Huang Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></div><div class="post_share"><div class="social-share" data-image="https://www.huangrd.top/images/agentina/14.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/26/RabbitMQ1/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/9.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RabbitMQ微服务复习</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/24/Docker%E5%AE%9E%E7%94%A8%E7%AF%87/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Docker</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C/" title="数据结构实验"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-22</div><div class="title">数据结构实验</div></div></a></div><div><a href="/2022/11/29/GUI/" title="java GUI基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-29</div><div class="title">java GUI基础</div></div></a></div><div><a href="/2022/11/22/Netty04-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81/" title="Netty 优化与源码"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.huangrd.top/images/agentina/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-22</div><div class="title">Netty 优化与源码</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://getwallpapers.com/wallpaper/full/a/1/8/1057222-free-download-cool-nature-backgrounds-1920x1200-windows-10.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Huang RD</div><div class="author-info__description">Huang Rui Dong Blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/A-JAVAer-HRD"><i class="fab fa-github"></i><span>了解���..</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/A-JAVAer-HRD" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:huangruidong.xauat@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢�����������������客��</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-text">算法总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="toc-text">一、二分搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81%E5%B7%A6%E9%97%AD%E5%8F%B3%E9%97%AD"><span class="toc-text">1.1、左闭右闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E3%80%81%E5%B7%A6%E9%97%AD%E5%8F%B3%E5%BC%80"><span class="toc-text">1.2、左闭右开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E3%80%81LC69-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="toc-text">1.3、LC69 x 的平方根</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%E3%80%81LC367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-text">1.4、LC367 有效的完全平方数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-text">二、双指针法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81%E7%A7%BB%E9%99%A4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-text">2.1、移除数组元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81LC11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">2.2、LC11. 盛最多水的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81LC141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-text">2.3、LC141. 环形链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E3%80%81LC142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II"><span class="toc-text">2.4、LC142. 环形链表II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E3%80%81%E5%89%91%E6%8C%87-Offer-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">2.5、剑指 Offer 18. 删除链表的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6%E3%80%81%E5%89%91%E6%8C%87-Offer-21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="toc-text">2.6、剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7%E3%80%81%E5%89%91%E6%8C%87-Offer-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-text">2.7、剑指 Offer 22. 链表中倒数第 k 个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8%E3%80%81LC206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">2.8、LC206. 反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">双指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text">递归</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">三、滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81LC209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-text">3.1、LC209. 长度最小的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81LC904-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE"><span class="toc-text">3.2、LC904. 水果成篮</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E3%80%81LC76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%97%E4%B8%B2"><span class="toc-text">3.3、LC76. 最小覆盖字串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E3%80%81LC3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-text">3.4、LC3. 无重复字符的最长子串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%A8%A1%E6%8B%9F"><span class="toc-text">四、模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E3%80%81LC54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-text">4.1、LC54. 螺旋矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E3%80%81LC59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II"><span class="toc-text">4.2、LC59. 螺旋矩阵II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E3%80%81%E5%89%91%E6%8C%87Offer29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="toc-text">4.3、剑指Offer29. 顺时针打印矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4%E3%80%81%E5%89%91%E6%8C%87-Offer-31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="toc-text">4.4、剑指 Offer 31. 栈的压入、弹出序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87"><span class="toc-text">五、数据结构篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E3%80%81%E5%89%91%E6%8C%87-Offer05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="toc-text">5.1、剑指 Offer05. 替换空格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E3%80%81%E5%89%91%E6%8C%87-Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="toc-text">5.2、剑指 Offer 06. 从尾到头打印链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E3%80%81%E5%89%91%E6%8C%87-Offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-text">5.3、剑指 Offer 09. 用两个栈实现队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%80"><span class="toc-text">思路一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%BA%8C"><span class="toc-text">思路二</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4%E3%80%81%E5%89%91%E6%8C%87-Offer-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">5.4、剑指 Offer 24. 反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3"><span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92-1"><span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5%E3%80%81%E5%89%91%E6%8C%87-Offer-30-%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="toc-text">5.5、剑指 Offer 30. 包含 min 函数的栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6%E3%80%81%E5%89%91%E6%8C%87-Offer-35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">5.6、剑指 Offer 35. 复杂链表的复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AE%B0%E5%BD%95%E6%B3%95"><span class="toc-text">哈希表记录法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5%E6%8B%86%E5%88%86"><span class="toc-text">拼接拆分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7%E3%80%81%E5%89%91%E6%8C%87-Offer-58-II-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">5.7、剑指 Offer 58 - II. 左旋转字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87"><span class="toc-text">字符串切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E9%81%8D%E5%8E%86%E6%8B%BC%E6%8E%A5"><span class="toc-text">列表遍历拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%81%8D%E5%8E%86%E6%8B%BC%E6%8E%A5"><span class="toc-text">字符串遍历拼接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8%E3%80%81%E5%89%91%E6%8C%87-Offer-59-I-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">5.8、剑指 Offer 59 - I. 滑动窗口的最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9%E3%80%81%E5%89%91%E6%8C%87-Offer-59-II-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">5.9、剑指 Offer 59 - II. 队列的最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-10%E3%80%81%E5%89%91%E6%8C%87-Offer-67-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0"><span class="toc-text">5.10、剑指 Offer 67. 把字符串转换成整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-11%E3%80%81LC2-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">5.11、LC2. 两数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B0%E9%93%BE%E8%A1%A8"><span class="toc-text">构造新链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%8E%9F%E9%93%BE%E8%A1%A8%E4%B8%8A%E6%93%8D%E4%BD%9C"><span class="toc-text">在原链表上操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88FSM%EF%BC%89"><span class="toc-text">六、有限状态自动机（FSM）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E3%80%81%E5%BA%94%E7%94%A8%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="toc-text">6.1、应用有限自动机解题步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E3%80%81%E5%89%91%E6%8C%87-Offer-20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">6.2、剑指 Offer 20. 表示数值的字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">七、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA"><span class="toc-text">7.1、动态规划理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%E3%80%81%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98%E4%BE%8B%E9%A2%98%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-text">7.2、重叠子问题例题：斐波那契数列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92"><span class="toc-text">暴力递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92"><span class="toc-text">记忆化递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E5%B0%8F%E7%BB%93"><span class="toc-text">示例小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3%E3%80%81%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E4%BE%8B%E9%A2%98%EF%BC%9A%E8%9B%8B%E7%B3%95%E5%94%AE%E4%BB%B7"><span class="toc-text">7.3、最优子结构例题：蛋糕售价</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92-1"><span class="toc-text">暴力递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92-1"><span class="toc-text">记忆化递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4%E3%80%8101%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">7.4、01背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4dp"><span class="toc-text">二维dp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4dp%EF%BC%88%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%EF%BC%89"><span class="toc-text">一维dp（滚动数组）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5%E3%80%81%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">7.5、完全背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E6%A1%86%E6%9E%B6"><span class="toc-text">7.6、动态规划解题框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5%E3%80%81%E5%89%91%E6%8C%87-Offer-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-text">7.5、剑指 Offer 10- I. 斐波那契数列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-text">记忆化搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6%E3%80%81%E5%89%91%E6%8C%87-Offer-19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-text">7.6、剑指 Offer 19. 正则表达式匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7%E3%80%81%E5%89%91%E6%8C%87-Offer-46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">7.7、剑指 Offer 46. 把数字翻译成字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8%E3%80%81%E5%89%91%E6%8C%87-Offer-47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="toc-text">7.8、剑指 Offer 47. 礼物的最大价值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9%E3%80%81%E5%89%91%E6%8C%87-Offer-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">7.9、剑指 Offer 48. 最长不含重复字符的子字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-49-%E4%B8%91%E6%95%B0"><span class="toc-text">剑指 Offer 49. 丑数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-10%E3%80%81%E5%89%91%E6%8C%87-Offer-60-n-%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0"><span class="toc-text">7.10、剑指 Offer 60. n 个骰子的点数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E6%B3%95"><span class="toc-text">暴力法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-11%E3%80%81%E5%89%91%E6%8C%87-Offer-63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="toc-text">7.11、剑指 Offer 63. 股票的最大利润</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-text">八、搜索与回溯算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1%E3%80%81%E5%89%91%E6%8C%87-Offer-12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">8.1、剑指 Offer 12. 矩阵中的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2%E3%80%81%E5%89%91%E6%8C%87-Offer-13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="toc-text">8.2、剑指 Offer 13. 机器人的运动范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3%E3%80%81%E5%89%91%E6%8C%87-Offer-26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-text">8.3、剑指 Offer 26. 树的子结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4%E3%80%81%E5%89%91%E6%8C%87-Offer-27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-text">8.4、剑指 Offer 27. 二叉树的镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5%E3%80%81%E5%89%91%E6%8C%87-Offer-28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">8.5、剑指 Offer 28. 对称的二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6%E3%80%81%E5%89%91%E6%8C%87-Offer-32-I-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">8.6、剑指 Offer 32 - I. 从上到下打印二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7%E3%80%81%E5%89%91%E6%8C%87-Offer-32-II-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-II"><span class="toc-text">8.7、剑指 Offer 32 - II. 从上到下打印二叉树 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8%E3%80%81%E5%89%91%E6%8C%87-Offer-32-III-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-III"><span class="toc-text">8.8、剑指 Offer 32 - III. 从上到下打印二叉树 III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-9%E3%80%81%E5%89%91%E6%8C%87-Offer-34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">8.9、剑指 Offer 34. 二叉树中和为某一值的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-10%E3%80%81%E5%89%91%E6%8C%87-Offer-36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">8.10、剑指 Offer 36. 二叉搜索树与双向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-11%E3%80%81%E5%89%91%E6%8C%87-Offer-37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">8.11、剑指 Offer 37. 序列化二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-12%E3%80%81%E5%89%91%E6%8C%87-Offer-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="toc-text">8.12、剑指 Offer 38. 字符串的排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-13%E3%80%81%E5%89%91%E6%8C%87-Offer-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="toc-text">8.13、剑指 Offer 54. 二叉搜索树的第 k 大节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-14%E3%80%81%E5%89%91%E6%8C%87-Offer-55-I-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-text">8.14、剑指 Offer 55 - I. 二叉树的深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-15%E3%80%81%E5%89%91%E6%8C%87-Offer-55-II-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">8.15、剑指 Offer 55 - II. 平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-16%E3%80%81%E5%89%91%E6%8C%87-Offer-64-%E6%B1%82-1-2-%E2%80%A6-n"><span class="toc-text">8.16、剑指 Offer 64. 求 1 + 2 + … + n</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-17%E3%80%81%E5%89%91%E6%8C%87-Offer-68-II-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">8.17、剑指 Offer 68 - II. 二叉搜索树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%B3%95%EF%BC%9A"><span class="toc-text">递归法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3-1"><span class="toc-text">迭代</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-18%E3%80%81%E5%89%91%E6%8C%87-Offer-68-II-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96"><span class="toc-text">8.18、剑指 Offer 68 - II. 二叉树的最近公共祖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95"><span class="toc-text">九、分治算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%E3%80%81%E5%89%91%E6%8C%87-Offer-07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">9.1、剑指 Offer 07. 重建二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2%E3%80%81106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">9.2、106.从中序与后序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3%E3%80%81%E5%89%91%E6%8C%87-Offer-16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="toc-text">9.3、剑指 Offer 16. 数值的整数次方</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95"><span class="toc-text">暴力解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E8%A7%A3%E6%9E%90%EF%BC%88%E5%88%86%E6%B2%BB%E6%B3%95%E8%A7%92%E5%BA%A6%EF%BC%89"><span class="toc-text">快速幂解析（分治法角度）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A7%92%E5%BA%A6%EF%BC%89"><span class="toc-text">快速幂解析（二进制角度）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4%E3%80%81%E5%89%91%E6%8C%87-Offer-17-%E6%89%93%E5%8D%B0%E4%BB%8E-1-%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84-n-%E4%BD%8D%E6%95%B0"><span class="toc-text">9.4、剑指 Offer 17. 打印从 1 到最大的 n 位数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E6%89%93%E5%8D%B0%E8%A7%A3%E6%B3%95%EF%BC%9A"><span class="toc-text">大数打印解法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5%E3%80%81%E5%89%91%E6%8C%87-Offer-33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-text">9.5、剑指 Offer 33. 二叉搜索树的后序遍历序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB"><span class="toc-text">方法一：递归分治</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E8%BE%85%E5%8A%A9%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-text">方法二：辅助单调栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6%E3%80%81%E5%89%91%E6%8C%87-Offer-51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-text">9.6、剑指 Offer 51. 数组中的逆序对</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">十、排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-text">1、简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-text">常见算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">分类方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">时空复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">2、冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">3、快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">4、归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%89%91%E6%8C%87-Offer-40-%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0"><span class="toc-text">5、剑指 Offer 40. 最小的 k 个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84%E5%88%92%E5%88%86"><span class="toc-text">基于快速排序的数组划分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-text">复杂度分析：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%89%91%E6%8C%87-Offer-41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-text">6、剑指 Offer 41. 数据流中的中位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%89%91%E6%8C%87-Offer-45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="toc-text">7、剑指 Offer 45. 把数组排成最小的数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E5%89%91%E6%8C%87-Offer-61-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90"><span class="toc-text">8、剑指 Offer 61. 扑克牌中的顺子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80"><span class="toc-text">解法一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C"><span class="toc-text">解法二</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-text">十一、查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">1、剑指 Offer 03. 数组中重复的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">方法一：哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8E%9F%E5%9C%B0%E4%BA%A4%E6%8D%A2"><span class="toc-text">方法二：原地交换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%89%91%E6%8C%87-Offer-04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-text">2、剑指 Offer 04. 二维数组中的查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%89%91%E6%8C%87-Offer-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="toc-text">3、剑指 Offer 11. 旋转数组的最小数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%89%91%E6%8C%87-Offer-50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-text">4、剑指 Offer 50. 第一个只出现一次的字符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8-1"><span class="toc-text">方法一：哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E6%9C%89%E5%BA%8F%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">方法二：有序哈希表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%89%91%E6%8C%87-Offer-53-II-0%EF%BD%9En-1-%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">5、剑指 Offer 53 - II. 0～n-1 中缺失的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%89%91%E6%8C%87-Offer-53-I-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-I"><span class="toc-text">6、剑指 Offer 53 - I. 在排序数组中查找数字 I</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#code1-%E4%B8%A4%E6%AC%A1%E4%BA%8C%E5%88%86"><span class="toc-text">code1:两次二分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code2-%E5%B0%81%E8%A3%85%E4%BA%8C%E5%88%86%E6%B3%95%EF%BC%8C%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="toc-text">code2:封装二分法，简化代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code3-%E5%85%88%E4%BA%8C%E5%88%86%EF%BC%8C%E5%86%8D%E4%B8%A4%E8%BE%B9%E5%90%8C%E6%97%B6%E9%80%BC%E8%BF%91%EF%BC%88%E9%A1%BA%E5%BA%8F%EF%BC%89"><span class="toc-text">code3:先二分，再两边同时逼近（顺序）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%89%91%E6%8C%87-Offer-25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-text">7、剑指 Offer 25. 合并两个排序的链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E5%89%91%E6%8C%87-Offer-52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="toc-text">8、剑指 Offer 52. 两个链表的第一个公共节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#code1-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86"><span class="toc-text">code1 循环遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code2-%E5%B7%AE%E5%80%BC%E6%B3%95"><span class="toc-text">code2 差值法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E5%89%91%E6%8C%87-Offer-57-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-text">9、剑指 Offer 57. 和为 s 的两个数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E5%89%91%E6%8C%87-Offer-58-I-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F"><span class="toc-text">10、剑指 Offer 58 - I. 翻转单词顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">方法一：双指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%88%86%E5%89%B2-%E5%80%92%E5%BA%8F"><span class="toc-text">方法二：分割 + 倒序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">十二、位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%89%91%E6%8C%87-Offer-15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-text">1、剑指 Offer 15. 二进制中 1 的个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E9%80%90%E4%BD%8D%E5%88%A4%E6%96%AD"><span class="toc-text">方法一：逐位判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%B7%A7%E7%94%A8-n-amp-n-1-n-amp-n%E2%88%921"><span class="toc-text">方法二：巧用 n &amp; (n - 1)n&amp;(n−1)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%89%91%E6%8C%87-Offer-65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95"><span class="toc-text">2、剑指 Offer 65. 不用加减乘除做加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%89%91%E6%8C%87-Offer-56-I-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-text">3、剑指 Offer 56 - I. 数组中数字出现的次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%89%91%E6%8C%87-Offer-56-II-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-II"><span class="toc-text">4、剑指 Offer 56 - II. 数组中数字出现的次数 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-text">方法一：有限状态自动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E9%81%8D%E5%8E%86%E7%BB%9F%E8%AE%A1"><span class="toc-text">方法二：遍历统计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E6%95%B0%E5%AD%A6"><span class="toc-text">十三、数学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%89%91%E6%8C%87-Offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">1、剑指 Offer 39. 数组中出现次数超过一半的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95%EF%BC%9A"><span class="toc-text">摩尔投票法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%B3%95%EF%BC%9A"><span class="toc-text">排序法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%89%91%E6%8C%87-Offer-66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84"><span class="toc-text">2、剑指 Offer 66. 构建乘积数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%89%91%E6%8C%87-Offer-14-I-%E5%89%AA%E7%BB%B3%E5%AD%90"><span class="toc-text">3、剑指 Offer 14- I. 剪绳子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E6%B3%95"><span class="toc-text">数学法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-text">贪心算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-4"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%89%91%E6%8C%87-Offer-14-II-%E5%89%AA%E7%BB%B3%E5%AD%90-II"><span class="toc-text">4、剑指 Offer 14- II. 剪绳子 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6"><span class="toc-text">数学</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-5"><span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%89%91%E6%8C%87-Offer-57-II-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97"><span class="toc-text">5、剑指 Offer 57 - II. 和为 s 的连续正数序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="toc-text">双指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6-1"><span class="toc-text">数学</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%89%91%E6%8C%87-Offer-62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">6、剑指 Offer 62. 圆圈中最后剩下的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%89%91%E6%8C%87-Offer-43-1%EF%BD%9En-%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-text">7、剑指 Offer 43. 1～n 整数中 1 出现的次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E5%89%91%E6%8C%87-Offer-44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">8、剑指 Offer 44. 数字序列中某一位的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81LC1759-%E7%BB%9F%E8%AE%A1%E5%90%8C%E6%9E%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-text">9、LC1759. 统计同构子字符串的数目</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Huang RD</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>